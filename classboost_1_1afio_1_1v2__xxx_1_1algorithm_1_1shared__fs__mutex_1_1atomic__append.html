<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Boost.AFIO: boost::afio::v2_xxx::algorithm::shared_fs_mutex::atomic_append Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.AFIO
   &#160;<span id="projectnumber">v2.00 early alpha</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1atomic__append.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1atomic__append-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">boost::afio::v2_xxx::algorithm::shared_fs_mutex::atomic_append Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Scalable many entity shared/exclusive file system based lock.  
 <a href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1atomic__append.html#details">More...</a></p>

<p><code>#include &quot;atomic_append.hpp&quot;</code></p>
<div class="dynheader">
Inheritance diagram for boost::afio::v2_xxx::algorithm::shared_fs_mutex::atomic_append:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1atomic__append.png" usemap="#boost::afio::v2_xxx::algorithm::shared_fs_mutex::atomic_append_map" alt=""/>
  <map id="boost::afio::v2_xxx::algorithm::shared_fs_mutex::atomic_append_map" name="boost::afio::v2_xxx::algorithm::shared_fs_mutex::atomic_append_map">
<area href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html" title="Abstract base class for an object which protects shared filing system resources." alt="boost::afio::v2_xxx::algorithm::shared_fs_mutex::shared_fs_mutex" shape="rect" coords="0,0,373,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0077428ce79aeba4e529024de8fb2664"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0077428ce79aeba4e529024de8fb2664"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1atomic__append.html#a0077428ce79aeba4e529024de8fb2664">entity_type</a> = <a class="el" href="structboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex_1_1entity__type.html">shared_fs_mutex::entity_type</a></td></tr>
<tr class="memdesc:a0077428ce79aeba4e529024de8fb2664"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of an entity id. <br/></td></tr>
<tr class="separator:a0077428ce79aeba4e529024de8fb2664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f7a092579354a2189a1b541d1993557"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f7a092579354a2189a1b541d1993557"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1atomic__append.html#a7f7a092579354a2189a1b541d1993557">entities_type</a> = <a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html#a02af43575220c42252610c818e109b72">shared_fs_mutex::entities_type</a></td></tr>
<tr class="memdesc:a7f7a092579354a2189a1b541d1993557"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a sequence of entities. <br/></td></tr>
<tr class="separator:a7f7a092579354a2189a1b541d1993557"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abfb079133767800c93165b78629f4435"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abfb079133767800c93165b78629f4435"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1atomic__append.html#abfb079133767800c93165b78629f4435">atomic_append</a> (<a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1atomic__append.html">atomic_append</a> &amp;&amp;o) noexcept</td></tr>
<tr class="memdesc:abfb079133767800c93165b78629f4435"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. <br/></td></tr>
<tr class="separator:abfb079133767800c93165b78629f4435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dbf4e731e06b9ee79a32d31f713de09"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1dbf4e731e06b9ee79a32d31f713de09"></a>
<a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1atomic__append.html">atomic_append</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1atomic__append.html#a1dbf4e731e06b9ee79a32d31f713de09">operator=</a> (<a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1atomic__append.html">atomic_append</a> &amp;&amp;o) noexcept</td></tr>
<tr class="memdesc:a1dbf4e731e06b9ee79a32d31f713de09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assign. <br/></td></tr>
<tr class="separator:a1dbf4e731e06b9ee79a32d31f713de09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f4ce4442c8011ec8ac2b7e53ff04e71"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f4ce4442c8011ec8ac2b7e53ff04e71"></a>
const <a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1file__handle.html">file_handle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1atomic__append.html#a5f4ce4442c8011ec8ac2b7e53ff04e71">handle</a> () const noexcept</td></tr>
<tr class="memdesc:a5f4ce4442c8011ec8ac2b7e53ff04e71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the handle to file being used for this lock. <br/></td></tr>
<tr class="separator:a5f4ce4442c8011ec8ac2b7e53ff04e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca5a30951f774a86874c53f090e1a6ab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca5a30951f774a86874c53f090e1a6ab"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1atomic__append.html#aca5a30951f774a86874c53f090e1a6ab">unlock</a> (<a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1atomic__append.html#a7f7a092579354a2189a1b541d1993557">entities_type</a> entities, unsigned long long hint) noexceptoverridefinal</td></tr>
<tr class="memdesc:aca5a30951f774a86874c53f090e1a6ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock a previously locked sequence of entities. <br/></td></tr>
<tr class="separator:aca5a30951f774a86874c53f090e1a6ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d121be3d16ec5fcd15d61e59f8b66bd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d121be3d16ec5fcd15d61e59f8b66bd"></a>
<a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1atomic__append.html#a0077428ce79aeba4e529024de8fb2664">entity_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html#a6d121be3d16ec5fcd15d61e59f8b66bd">entity_from_buffer</a> (const char *buffer, size_t bytes, bool exclusive=true) noexcept</td></tr>
<tr class="memdesc:a6d121be3d16ec5fcd15d61e59f8b66bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates an entity id from a sequence of bytes. <br/></td></tr>
<tr class="separator:a6d121be3d16ec5fcd15d61e59f8b66bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc91b1e075ed52fc277c59213cf7b357"><td class="memTemplParams" colspan="2"><a class="anchor" id="adc91b1e075ed52fc277c59213cf7b357"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:adc91b1e075ed52fc277c59213cf7b357"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1atomic__append.html#a0077428ce79aeba4e529024de8fb2664">entity_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html#adc91b1e075ed52fc277c59213cf7b357">entity_from_string</a> (const std::basic_string&lt; T &gt; &amp;str, bool exclusive=true) noexcept</td></tr>
<tr class="memdesc:adc91b1e075ed52fc277c59213cf7b357"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates an entity id from a string. <br/></td></tr>
<tr class="separator:adc91b1e075ed52fc277c59213cf7b357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a493872c8b5dbfa83fdf82242b928e112"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a493872c8b5dbfa83fdf82242b928e112"></a>
<a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1atomic__append.html#a0077428ce79aeba4e529024de8fb2664">entity_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html#a493872c8b5dbfa83fdf82242b928e112">random_entity</a> (bool exclusive=true) noexcept</td></tr>
<tr class="memdesc:a493872c8b5dbfa83fdf82242b928e112"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a cryptographically random entity id. <br/></td></tr>
<tr class="separator:a493872c8b5dbfa83fdf82242b928e112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50848058867ee3533b812378aff20b03"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50848058867ee3533b812378aff20b03"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html#a50848058867ee3533b812378aff20b03">fill_random_entities</a> (span&lt; <a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1atomic__append.html#a0077428ce79aeba4e529024de8fb2664">entity_type</a> &gt; seq, bool exclusive=true) noexcept</td></tr>
<tr class="memdesc:a50848058867ee3533b812378aff20b03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a sequence of entity ids with cryptographic randomness. Much faster than calling random_entity() individually. <br/></td></tr>
<tr class="separator:a50848058867ee3533b812378aff20b03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19fafd3b1f9a098c9e60212e7ba97e32"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19fafd3b1f9a098c9e60212e7ba97e32"></a>
<a class="el" href="namespaceboost_1_1afio_1_1v2__xxx.html#ac8d06ecaa9660e7251c1251d88c1305c">result</a>&lt; <a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex_1_1entities__guard.html">entities_guard</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html#a19fafd3b1f9a098c9e60212e7ba97e32">lock</a> (<a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1atomic__append.html#a7f7a092579354a2189a1b541d1993557">entities_type</a> entities, <a class="el" href="structdeadline.html">deadline</a> d=<a class="el" href="structdeadline.html">deadline</a>(), bool spin_not_sleep=false) noexcept</td></tr>
<tr class="memdesc:a19fafd3b1f9a098c9e60212e7ba97e32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock all of a sequence of entities for exclusive or shared access. <br/></td></tr>
<tr class="separator:a19fafd3b1f9a098c9e60212e7ba97e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade23c2f167c550c66fa5522ad3e27b7e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade23c2f167c550c66fa5522ad3e27b7e"></a>
<a class="el" href="namespaceboost_1_1afio_1_1v2__xxx.html#ac8d06ecaa9660e7251c1251d88c1305c">result</a>&lt; <a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex_1_1entities__guard.html">entities_guard</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html#ade23c2f167c550c66fa5522ad3e27b7e">lock</a> (<a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1atomic__append.html#a0077428ce79aeba4e529024de8fb2664">entity_type</a> entity, <a class="el" href="structdeadline.html">deadline</a> d=<a class="el" href="structdeadline.html">deadline</a>(), bool spin_not_sleep=false) noexcept</td></tr>
<tr class="memdesc:ade23c2f167c550c66fa5522ad3e27b7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock a single entity for exclusive or shared access. <br/></td></tr>
<tr class="separator:ade23c2f167c550c66fa5522ad3e27b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a851d41aee26d0d58cc7e6371724dfd80"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a851d41aee26d0d58cc7e6371724dfd80"></a>
<a class="el" href="namespaceboost_1_1afio_1_1v2__xxx.html#ac8d06ecaa9660e7251c1251d88c1305c">result</a>&lt; <a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex_1_1entities__guard.html">entities_guard</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html#a851d41aee26d0d58cc7e6371724dfd80">try_lock</a> (<a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1atomic__append.html#a7f7a092579354a2189a1b541d1993557">entities_type</a> entities) noexcept</td></tr>
<tr class="memdesc:a851d41aee26d0d58cc7e6371724dfd80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to lock all of a sequence of entities for exclusive or shared access. <br/></td></tr>
<tr class="separator:a851d41aee26d0d58cc7e6371724dfd80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8f772f5f052920879526dbb66a90823"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8f772f5f052920879526dbb66a90823"></a>
<a class="el" href="namespaceboost_1_1afio_1_1v2__xxx.html#ac8d06ecaa9660e7251c1251d88c1305c">result</a>&lt; <a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex_1_1entities__guard.html">entities_guard</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html#ad8f772f5f052920879526dbb66a90823">try_lock</a> (<a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1atomic__append.html#a0077428ce79aeba4e529024de8fb2664">entity_type</a> entity) noexcept</td></tr>
<tr class="memdesc:ad8f772f5f052920879526dbb66a90823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to lock a single entity for exclusive or shared access. <br/></td></tr>
<tr class="separator:ad8f772f5f052920879526dbb66a90823"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a4ad149b7199d2fb919b73ef17a1d61b8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceboost_1_1afio_1_1v2__xxx.html#ac8d06ecaa9660e7251c1251d88c1305c">result</a>&lt; <a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1atomic__append.html">atomic_append</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1atomic__append.html#a4ad149b7199d2fb919b73ef17a1d61b8">fs_mutex_append</a> (file_handle::path_type lockfile, bool nfs_compatibility=false, bool skip_hashing=false) noexcept</td></tr>
<tr class="separator:a4ad149b7199d2fb919b73ef17a1d61b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a4c16831d072f5e2ec9a33532b6764616"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceboost_1_1afio_1_1v2__xxx.html#ac8d06ecaa9660e7251c1251d88c1305c">result</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1atomic__append.html#a4c16831d072f5e2ec9a33532b6764616">_lock</a> (<a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex_1_1entities__guard.html">entities_guard</a> &amp;out, <a class="el" href="structdeadline.html">deadline</a> d, bool spin_not_sleep) noexceptoverridefinal</td></tr>
<tr class="separator:a4c16831d072f5e2ec9a33532b6764616"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Scalable many entity shared/exclusive file system based lock. </p>
<p>Lock files and byte ranges scale poorly to the number of items being concurrently locked with typically an exponential drop off in performance as the number of items being concurrently locked rises. This file system algorithm solves this problem using IPC via a shared append-only lock file.</p>
<ul>
<li>Compatible with networked file systems (NFS too if the special nfs_compatibility flag is true. Note turning this on is not free of cost if you don't need NFS compatibility).</li>
<li>Nearly constant time to number of entities being locked.</li>
<li>Nearly constant time to number of processes concurrently using the lock (i.e. number of waiters).</li>
<li>Can sleep until a lock becomes free in a power-efficient manner.</li>
<li>Sudden power loss during use is recovered from.</li>
</ul>
<p>Caveats:</p>
<ul>
<li>Much slower than byte_ranges for few waiters or small number of entities.</li>
<li>Sudden process exit with locks held will deadlock all other users.</li>
<li>Maximum of twelve entities may be locked concurrently.</li>
<li>Wasteful of disk space if used on a non-extents based filing system (e.g. FAT32, ext3). It is best used in <code>/tmp</code> if possible (<code>file_handle::temp_file()</code>). If you really must use a non-extents based filing system, destroy and recreate the object instance periodically to force resetting the lock file's length to zero.</li>
<li>Similarly older operating systems (e.g. Linux &lt; 3.0) do not implement extent hole punching and therefore will also see excessive disk space consumption. Note at the time of writing OS X doesn't implement hole punching at all.</li>
<li>If your OS doesn't have sane byte range locks (OS X, BSD, older Linuxes) and multiple objects in your process use the same lock file, misoperation will occur. Use lock_files instead.</li>
</ul>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd><p class="startdd">Implement hole punching once I port that code from AFIO v1. </p>
<p>Decide on some resolution mechanism for sudden process exit. </p>
<p class="enddd">There is a 1 out of 2^64-2 chance of unique id collision. It would be nice if we actually formally checked that our chosen unique id is actually unique. </p>
</dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a4c16831d072f5e2ec9a33532b6764616"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceboost_1_1afio_1_1v2__xxx.html#ac8d06ecaa9660e7251c1251d88c1305c">result</a>&lt;void&gt; boost::afio::v2_xxx::algorithm::shared_fs_mutex::atomic_append::_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex_1_1entities__guard.html">entities_guard</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdeadline.html">deadline</a>&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>spin_not_sleep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd>Read from header.last_known_good immediately if possible in order to avoid a duplicate read later </dd></dl>

<p>Implements <a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html">boost::afio::v2_xxx::algorithm::shared_fs_mutex::shared_fs_mutex</a>.</p>
<div class="fragment"><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;      {</div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;        BOOST_AFIO_LOG_FUNCTION_CALL(<span class="keyword">this</span>);</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;        atomic_append_detail::lock_request lock_request;</div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;        <span class="keywordflow">if</span>(out.entities.size() &gt; <span class="keyword">sizeof</span>(lock_request.entities) / <span class="keyword">sizeof</span>(lock_request.entities[0]))</div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;          <span class="keywordflow">return</span> make_errored_result&lt;void&gt;(stl11::errc::argument_list_too_long);</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;</div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;        stl11::chrono::steady_clock::time_point began_steady;</div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;        stl11::chrono::system_clock::time_point end_utc;</div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;        <span class="keywordflow">if</span>(d)</div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;        {</div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;          <span class="keywordflow">if</span>((d).steady)</div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;            began_steady = stl11::chrono::steady_clock::now();</div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;          <span class="keywordflow">else</span></div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;            end_utc = (d).to_time_point();</div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;        }</div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;        <span class="comment">// Fire this if an error occurs</span></div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;        <span class="keyword">auto</span> disableunlock = undoer([&amp;] { out.release(); });</div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;</div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;        <span class="comment">// Write my lock request immediately</span></div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;        memset(&amp;lock_request, 0, <span class="keyword">sizeof</span>(lock_request));</div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;        lock_request.unique_id = _unique_id;</div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;        <span class="keyword">auto</span> count = stl11::chrono::system_clock::now() - stl11::chrono::system_clock::from_time_t(_header.time_offset);</div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;        lock_request.us_count = stl11::chrono::duration_cast&lt;stl11::chrono::microseconds&gt;(count).count();</div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;        lock_request.items = out.entities.size();</div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;        memcpy(lock_request.entities, out.entities.data(), <span class="keyword">sizeof</span>(lock_request.entities[0]) * out.entities.size());</div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;        <span class="keywordflow">if</span>(!_skip_hashing)</div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;          lock_request.hash = boost_lite::algorithm::hash::fast_hash::hash(((<span class="keywordtype">char</span> *) &amp;lock_request) + 16, <span class="keyword">sizeof</span>(lock_request) - 16);</div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;        <span class="comment">// My lock request will be the file&#39;s current length or higher</span></div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;        BOOST_OUTCOME_TRY(my_lock_request_offset, _h.<a class="code" href="classboost_1_1afio_1_1v2__xxx_1_1file__handle.html#a6e4524b6bd5de76631bcc7ab68bab7bd">length</a>());</div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;        {</div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;          _h.<a class="code" href="classboost_1_1afio_1_1v2__xxx_1_1handle.html#adf964e787e0666fc5b7d94c2715ee6f5">set_append_only</a>(<span class="keyword">true</span>);</div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;          <span class="keyword">auto</span> undo = undoer([<span class="keyword">this</span>] { _h.<a class="code" href="classboost_1_1afio_1_1v2__xxx_1_1handle.html#adf964e787e0666fc5b7d94c2715ee6f5">set_append_only</a>(<span class="keyword">false</span>); });</div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;          file_handle::extent_guard append_guard;</div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;          <span class="keywordflow">if</span>(_nfs_compatibility)</div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;          {</div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;            file_handle::extent_type lastbyte = (file_handle::extent_type) -1;</div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;            <span class="comment">// Lock up to the beginning of the shadow lock space</span></div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;            lastbyte &amp;= ~(1ULL &lt;&lt; 63);</div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;            BOOST_OUTCOME_TRY(append_guard_, _h.<a class="code" href="classboost_1_1afio_1_1v2__xxx_1_1io__handle.html#aebd9c90a901e6364c94d466425db6e0f" title="Tries to lock the range of bytes specified for shared or exclusive access. Be aware this passes throu...">lock</a>(my_lock_request_offset, lastbyte, <span class="keyword">true</span>));</div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;            append_guard = std::move(append_guard_);</div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;          }</div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;          BOOST_OUTCOME_TRYV(_h.<a class="code" href="classboost_1_1afio_1_1v2__xxx_1_1io__handle.html#a8890b6a6046fb562f9f0ab943b79dfb4" title="Write data to the open handle.">write</a>(0, (<span class="keywordtype">char</span> *) &amp;lock_request, <span class="keyword">sizeof</span>(lock_request)));</div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;        }</div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;</div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;        <span class="comment">// Find the record I just wrote</span></div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;        alignas(64) char _buffer[4096 + 2048];  <span class="comment">// 6Kb cache line aligned buffer</span></div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;        <span class="comment">// Read onwards from length as reported before I wrote my lock request</span></div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;        <span class="comment">// until I find my lock request. This loop should never actually iterate</span></div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;        <span class="comment">// except under extreme load conditions.</span><span class="comment"></span></div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;<span class="comment">        //! \todo Read from header.last_known_good immediately if possible in order</span></div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;<span class="comment">        //! to avoid a duplicate read later</span></div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;<span class="comment"></span>        for(;;)</div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;        {</div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;          file_handle::io_result&lt;file_handle::buffer_type&gt; readoutcome = _h.<a class="code" href="classboost_1_1afio_1_1v2__xxx_1_1io__handle.html#ab371d8427aeb4bd0ca5f8a39a98ea5a2" title="Read data from the open handle.">read</a>(my_lock_request_offset, _buffer, <span class="keyword">sizeof</span>(_buffer));</div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;          <span class="comment">// Should never happen :)</span></div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;          <span class="keywordflow">if</span>(readoutcome.has_error())</div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;          {</div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;            BOOST_AFIO_LOG_FATAL(<span class="keyword">this</span>, <span class="stringliteral">&quot;atomic_append::lock() saw an error when searching for just written data&quot;</span>);</div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;            std::terminate();</div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;          }</div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;          <span class="keyword">const</span> atomic_append_detail::lock_request *record, *lastrecord;</div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;          <span class="keywordflow">for</span>(record = (<span class="keyword">const</span> atomic_append_detail::lock_request *) readoutcome.get().first, lastrecord = (<span class="keyword">const</span> atomic_append_detail::lock_request *) (readoutcome.get().first + readoutcome.get().second); record &lt; lastrecord &amp;&amp; record-&gt;hash != lock_request.hash; ++record)</div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;            my_lock_request_offset += <span class="keyword">sizeof</span>(atomic_append_detail::lock_request);</div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;          <span class="keywordflow">if</span>(record-&gt;hash == lock_request.hash)</div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;            <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;        }</div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;</div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;        <span class="comment">// extent_guard is now valid and will be unlocked on error</span></div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;        out.hint = my_lock_request_offset;</div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;        disableunlock.dismiss();</div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;</div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;        <span class="comment">// Lock my request for writing so others can sleep on me</span></div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;        file_handle::extent_guard my_request_guard;</div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;        <span class="keywordflow">if</span>(!spin_not_sleep)</div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;        {</div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;          <span class="keyword">auto</span> lock_offset = my_lock_request_offset;</div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;          <span class="comment">// Set the top bit to use the shadow lock space on Windows</span></div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;          lock_offset |= (1ULL &lt;&lt; 63);</div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;          BOOST_OUTCOME_TRY(my_request_guard_, _h.<a class="code" href="classboost_1_1afio_1_1v2__xxx_1_1io__handle.html#aebd9c90a901e6364c94d466425db6e0f" title="Tries to lock the range of bytes specified for shared or exclusive access. Be aware this passes throu...">lock</a>(lock_offset, <span class="keyword">sizeof</span>(lock_request), <span class="keyword">true</span>));</div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;          my_request_guard = std::move(my_request_guard_);</div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;        }</div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;</div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;        <span class="comment">// Read every record preceding mine until header.first_known_good inclusive</span></div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;        <span class="keyword">auto</span> record_offset = my_lock_request_offset - <span class="keyword">sizeof</span>(atomic_append_detail::lock_request);</div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;        <span class="keywordflow">do</span></div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;        {</div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;        reload:</div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;          <span class="comment">// Refresh the header and load a snapshot of everything between record_offset</span></div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;          <span class="comment">// and first_known_good or -6Kb, whichever the sooner</span></div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;          _read_header();</div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;          <span class="comment">// If there are no preceding records, we&#39;re done</span></div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;          <span class="keywordflow">if</span>(record_offset &lt; _header.first_known_good)</div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;            <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;          <span class="keyword">auto</span> start_offset = record_offset;</div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;          <span class="keywordflow">if</span>(start_offset &gt; <span class="keyword">sizeof</span>(_buffer) - <span class="keyword">sizeof</span>(atomic_append_detail::lock_request))</div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;            start_offset -= <span class="keyword">sizeof</span>(_buffer) - <span class="keyword">sizeof</span>(atomic_append_detail::lock_request);</div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;          <span class="keywordflow">else</span></div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;            start_offset = <span class="keyword">sizeof</span>(atomic_append_detail::lock_request);</div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;          <span class="keywordflow">if</span>(start_offset &lt; _header.first_known_good)</div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;            start_offset = _header.first_known_good;</div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;          assert(record_offset &gt;= start_offset);</div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;          assert(record_offset - start_offset &lt;= <span class="keyword">sizeof</span>(_buffer));</div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;          BOOST_OUTCOME_TRY(batchread, _h.<a class="code" href="classboost_1_1afio_1_1v2__xxx_1_1io__handle.html#ab371d8427aeb4bd0ca5f8a39a98ea5a2" title="Read data from the open handle.">read</a>(start_offset, _buffer, (<span class="keywordtype">size_t</span>)(record_offset - start_offset) + <span class="keyword">sizeof</span>(atomic_append_detail::lock_request)));</div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;          assert(batchread.second == record_offset - start_offset + <span class="keyword">sizeof</span>(atomic_append_detail::lock_request));</div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;          <span class="keyword">const</span> atomic_append_detail::lock_request *record = (atomic_append_detail::lock_request *) (batchread.first + batchread.second - <span class="keyword">sizeof</span>(atomic_append_detail::lock_request));</div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;          <span class="keyword">const</span> atomic_append_detail::lock_request *firstrecord = (atomic_append_detail::lock_request *) batchread.first;</div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;</div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;          <span class="comment">// Skip all completed lock requests or not mentioning any of my entities</span></div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;          <span class="keywordflow">for</span>(; record &gt;= firstrecord; record_offset -= <span class="keyword">sizeof</span>(atomic_append_detail::lock_request), --record)</div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;          {</div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;            <span class="comment">// If a completed lock request, skip</span></div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;            <span class="keywordflow">if</span>(!record-&gt;hash &amp;&amp; !record-&gt;unique_id)</div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;              <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;            <span class="comment">// If record hash doesn&#39;t match contents it&#39;s a torn read, reload</span></div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;            <span class="keywordflow">if</span>(!_skip_hashing)</div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;            {</div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;              <span class="keywordflow">if</span>(record-&gt;hash != boost_lite::algorithm::hash::fast_hash::hash(((<span class="keywordtype">char</span> *) record) + 16, <span class="keyword">sizeof</span>(atomic_append_detail::lock_request) - 16))</div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;                <span class="keywordflow">goto</span> reload;</div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;            }</div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;</div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;            <span class="comment">// Does this record lock anything I am locking?</span></div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;            <span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;entity : out.entities)</div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;            {</div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;              <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> n = 0; n &lt; record-&gt;items; n++)</div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;              {</div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;                <span class="keywordflow">if</span>(record-&gt;entities[n].value == entity.value)</div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;                {</div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;                  <span class="comment">// Is the lock I want exclusive or the lock he wants exclusive?</span></div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;                  <span class="comment">// If so, need to block</span></div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;                  <span class="keywordflow">if</span>(record-&gt;entities[n].exclusive || entity.exclusive)</div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;                    <span class="keywordflow">goto</span> beginwait;</div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;                }</div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;              }</div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;            }</div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;          }</div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;          <span class="comment">// None of this batch of records has anything to do with my request, so keep going</span></div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;          <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;</div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;        beginwait:</div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;          <span class="comment">// Sleep until this record is freed using a shared lock</span></div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;          <span class="comment">// on the record in our way. Note there is a race here</span></div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;          <span class="comment">// between when the lock requester writes the lock</span></div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;          <span class="comment">// request and when he takes an exclusive lock on it,</span></div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;          <span class="comment">// so if our shared lock succeeds we need to immediately</span></div>
<div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;          <span class="comment">// unlock and retry based on the data.</span></div>
<div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;          stl11::this_thread::yield();</div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;          <span class="keywordflow">if</span>(!spin_not_sleep)</div>
<div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;          {</div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;            <a class="code" href="structdeadline.html" title="A time deadline in either relative-to-now or absolute (system clock) terms.">deadline</a> nd;</div>
<div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;            <span class="keywordflow">if</span>(d)</div>
<div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;            {</div>
<div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;              <span class="keywordflow">if</span>((d).steady)</div>
<div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;              {</div>
<div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;                stl11::chrono::nanoseconds ns = stl11::chrono::duration_cast&lt;stl11::chrono::nanoseconds&gt;((began_steady + stl11::chrono::nanoseconds((d).nsecs)) - stl11::chrono::steady_clock::now());</div>
<div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;                <span class="keywordflow">if</span>(ns.count() &lt; 0)</div>
<div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;                  (nd).nsecs = 0;</div>
<div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;                <span class="keywordflow">else</span></div>
<div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;                  (nd).nsecs = ns.count();</div>
<div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;              }</div>
<div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;              <span class="keywordflow">else</span></div>
<div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;                (nd) = (d);</div>
<div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;            }</div>
<div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;            <span class="keyword">auto</span> lock_offset = record_offset;</div>
<div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;            <span class="comment">// Set the top bit to use the shadow lock space on Windows</span></div>
<div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;            lock_offset |= (1ULL &lt;&lt; 63);</div>
<div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;            BOOST_OUTCOME_TRY(record_guard_, _h.<a class="code" href="classboost_1_1afio_1_1v2__xxx_1_1io__handle.html#aebd9c90a901e6364c94d466425db6e0f" title="Tries to lock the range of bytes specified for shared or exclusive access. Be aware this passes throu...">lock</a>(lock_offset, <span class="keyword">sizeof</span>(record), <span class="keyword">false</span>, nd));</div>
<div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;          }</div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;          <span class="comment">// Make sure we haven&#39;t timed out during this wait</span></div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;          <span class="keywordflow">if</span>(d)</div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;          {</div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;            <span class="keywordflow">if</span>((d).steady)</div>
<div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;            {</div>
<div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;              <span class="keywordflow">if</span>(stl11::chrono::steady_clock::now() &gt;= (began_steady + stl11::chrono::nanoseconds((d).nsecs)))</div>
<div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;                <span class="keywordflow">return</span> make_errored_result&lt;void&gt;(stl11::errc::timed_out);</div>
<div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;            }</div>
<div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;            <span class="keywordflow">else</span></div>
<div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;            {</div>
<div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;              <span class="keywordflow">if</span>(stl11::chrono::system_clock::now() &gt;= end_utc)</div>
<div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;                <span class="keywordflow">return</span> make_errored_result&lt;void&gt;(stl11::errc::timed_out);</div>
<div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;            }</div>
<div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;          }</div>
<div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;        } <span class="keywordflow">while</span>(record_offset &gt;= _header.first_known_good);</div>
<div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;        <span class="keywordflow">return</span> make_valued_result&lt;void&gt;();</div>
<div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;      }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a4ad149b7199d2fb919b73ef17a1d61b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespaceboost_1_1afio_1_1v2__xxx.html#ac8d06ecaa9660e7251c1251d88c1305c">result</a>&lt;<a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1atomic__append.html">atomic_append</a>&gt; boost::afio::v2_xxx::algorithm::shared_fs_mutex::atomic_append::fs_mutex_append </td>
          <td>(</td>
          <td class="paramtype">file_handle::path_type&#160;</td>
          <td class="paramname"><em>lockfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>nfs_compatibility</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>skip_hashing</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialises a shared filing system mutex using the file at <em>lockfile</em> </p>
<dl class="section return"><dt>Returns</dt><dd>An implementation of shared_fs_mutex using the atomic_append algorithm. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lockfile</td><td>The path to the file to use for IPC. </td></tr>
    <tr><td class="paramname">nfs_compatibility</td><td>Make this true if the lockfile could be accessed by NFS. </td></tr>
    <tr><td class="paramname">skip_hashing</td><td>Some filing systems (typically the copy on write ones e.g. ZFS, btrfs) guarantee atomicity of updates and therefore torn writes are never observed by readers. For these, hashing can be safely disabled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd>fs_mutex_append needs to check if file still exists after lock is granted, awaiting path fetching. </dd></dl>
<div class="fragment"><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;      {</div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;        BOOST_AFIO_LOG_FUNCTION_CALL(0);</div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;        BOOST_OUTCOME_TRY(ret, <a class="code" href="classboost_1_1afio_1_1v2__xxx_1_1file__handle.html#af912595f8964b78186236a2cec1150a4">file_handle::file</a>(std::move(lockfile), file_handle::mode::write, file_handle::creation::if_needed, file_handle::caching::temporary));</div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;        atomic_append_detail::header header;</div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;        <span class="comment">// Lock the entire header for exclusive access</span></div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;        <span class="keyword">auto</span> lockresult = ret.try_lock(0, <span class="keyword">sizeof</span>(header), <span class="keyword">true</span>);<span class="comment"></span></div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;<span class="comment">        //! \todo fs_mutex_append needs to check if file still exists after lock is granted, awaiting path fetching.</span></div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;<span class="comment"></span>        <span class="keywordflow">if</span>(lockresult.has_error())</div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;        {</div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;          <span class="keywordflow">if</span>(lockresult.get_error().value() != ETIMEDOUT)</div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;            <span class="keywordflow">return</span> lockresult.get_error();</div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;          <span class="comment">// Somebody else is also using this file</span></div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;        }</div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;        <span class="keywordflow">else</span></div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;        {</div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;          <span class="comment">// I am the first person to be using this (stale?) file, so write a new header and truncate</span></div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;          ret.truncate(<span class="keyword">sizeof</span>(header));</div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;          memset(&amp;header, 0, <span class="keyword">sizeof</span>(header));</div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;          header.time_offset = stl11::chrono::system_clock::to_time_t(stl11::chrono::system_clock::now());</div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;          header.first_known_good = <span class="keyword">sizeof</span>(header);</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;          header.first_after_hole_punch = <span class="keyword">sizeof</span>(header);</div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;          <span class="keywordflow">if</span>(!skip_hashing)</div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;            header.hash = boost_lite::algorithm::hash::fast_hash::hash(((<span class="keywordtype">char</span> *) &amp;header) + 16, <span class="keyword">sizeof</span>(header) - 16);</div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;          BOOST_OUTCOME_TRY(_, ret.write(0, (<span class="keywordtype">char</span> *) &amp;header, <span class="keyword">sizeof</span>(header)));</div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;          (void) _;</div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;        }</div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;        <span class="comment">// Open a shared lock on last byte in header to prevent other users zomping the file</span></div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;        BOOST_OUTCOME_TRY(guard, ret.lock(<span class="keyword">sizeof</span>(header) - 1, 1, <span class="keyword">false</span>));</div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;        <span class="comment">// Unlock any exclusive lock I gained earlier now</span></div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;        <span class="keywordflow">if</span>(lockresult)</div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;          lockresult.get().unlock();</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;        <span class="comment">// The constructor will read and cache the header</span></div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;        <span class="keywordflow">return</span> atomic_append(std::move(ret), std::move(guard), nfs_compatibility, skip_hashing);</div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;      }</div>
</div><!-- fragment -->
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/boost/afio/v2.0/algorithm/shared_fs_mutex/<a class="el" href="atomic__append_8hpp.html">atomic_append.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceboost.html">boost</a></li><li class="navelem"><a class="el" href="namespaceboost_1_1afio.html">afio</a></li><li class="navelem"><a class="el" href="namespaceboost_1_1afio_1_1v2__xxx.html">v2_xxx</a></li><li class="navelem"><a class="el" href="namespaceboost_1_1afio_1_1v2__xxx_1_1algorithm.html">algorithm</a></li><li class="navelem"><a class="el" href="namespaceboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex.html">shared_fs_mutex</a></li><li class="navelem"><a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1atomic__append.html">atomic_append</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.3.1 </li>
  </ul>
</div>
</body>
</html>
