<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>AFIO: afio_v2_xxx::algorithm::shared_fs_mutex::memory_map&lt; Hasher, HashIndexSize, SpinlockType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">AFIO
   &#160;<span id="projectnumber">v2.00 late alpha</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classafio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="classafio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">afio_v2_xxx::algorithm::shared_fs_mutex::memory_map&lt; Hasher, HashIndexSize, SpinlockType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Many entity memory mapped shared/exclusive file system based lock.  
 <a href="classafio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html#details">More...</a></p>

<p><code>#include &quot;memory_map.hpp&quot;</code></p>
<div class="dynheader">
Inheritance diagram for afio_v2_xxx::algorithm::shared_fs_mutex::memory_map&lt; Hasher, HashIndexSize, SpinlockType &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classafio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.png" usemap="#afio_v2_xxx::algorithm::shared_fs_mutex::memory_map&lt; Hasher, HashIndexSize, SpinlockType &gt;_map" alt=""/>
  <map id="afio_v2_xxx::algorithm::shared_fs_mutex::memory_map&lt; Hasher, HashIndexSize, SpinlockType &gt;_map" name="afio_v2_xxx::algorithm::shared_fs_mutex::memory_map&lt; Hasher, HashIndexSize, SpinlockType &gt;_map">
<area href="classafio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html" title="Abstract base class for an object which protects shared filing system resources. " alt="afio_v2_xxx::algorithm::shared_fs_mutex::shared_fs_mutex" shape="rect" coords="0,0,559,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structafio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map_1_1__entity__idx.html">_entity_idx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a33d3ab28b81a5b1eedcc8eb217f78eab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33d3ab28b81a5b1eedcc8eb217f78eab"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classafio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html#a33d3ab28b81a5b1eedcc8eb217f78eab">entity_type</a> = <a class="el" href="structafio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex_1_1entity__type.html">shared_fs_mutex::entity_type</a></td></tr>
<tr class="memdesc:a33d3ab28b81a5b1eedcc8eb217f78eab"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of an entity id. <br/></td></tr>
<tr class="separator:a33d3ab28b81a5b1eedcc8eb217f78eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95880c30e654cff3c8539a98e8051cc2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95880c30e654cff3c8539a98e8051cc2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classafio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html#a95880c30e654cff3c8539a98e8051cc2">entities_type</a> = <a class="el" href="classafio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html#ab9b3f3598d373786919eafc643d78633">shared_fs_mutex::entities_type</a></td></tr>
<tr class="memdesc:a95880c30e654cff3c8539a98e8051cc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a sequence of entities. <br/></td></tr>
<tr class="separator:a95880c30e654cff3c8539a98e8051cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1acefdfab9ed10056232777b82c7725d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1acefdfab9ed10056232777b82c7725d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classafio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html#a1acefdfab9ed10056232777b82c7725d">hasher_type</a> = Hasher&lt; <a class="el" href="structafio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex_1_1entity__type.html#a51e399ed65877f238f840fb90b8a3e20">entity_type::value_type</a> &gt;</td></tr>
<tr class="memdesc:a1acefdfab9ed10056232777b82c7725d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the hasher being used. <br/></td></tr>
<tr class="separator:a1acefdfab9ed10056232777b82c7725d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80fcaf9fcaddc442e8517e11f20fcab9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80fcaf9fcaddc442e8517e11f20fcab9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classafio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html#a80fcaf9fcaddc442e8517e11f20fcab9">spinlock_type</a> = SpinlockType</td></tr>
<tr class="memdesc:a80fcaf9fcaddc442e8517e11f20fcab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the spinlock being used. <br/></td></tr>
<tr class="separator:a80fcaf9fcaddc442e8517e11f20fcab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a89e52feca9dfdc21f0934ffe178ec496"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a89e52feca9dfdc21f0934ffe178ec496"></a>
<a class="el" href="classafio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html">shared_fs_mutex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classafio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html#a89e52feca9dfdc21f0934ffe178ec496">fallback</a> () const noexcept</td></tr>
<tr class="memdesc:a89e52feca9dfdc21f0934ffe178ec496"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the fallback lock. <br/></td></tr>
<tr class="separator:a89e52feca9dfdc21f0934ffe178ec496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a869e5a388b53cc46a026ae534d2dc16f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a869e5a388b53cc46a026ae534d2dc16f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classafio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html#a869e5a388b53cc46a026ae534d2dc16f">fallback</a> (<a class="el" href="classafio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html">shared_fs_mutex</a> *fbl) noexcept</td></tr>
<tr class="memdesc:a869e5a388b53cc46a026ae534d2dc16f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the fallback lock. <br/></td></tr>
<tr class="separator:a869e5a388b53cc46a026ae534d2dc16f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b939f02167fe69a9b10fae2554826a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b939f02167fe69a9b10fae2554826a6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classafio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html#a4b939f02167fe69a9b10fae2554826a6">is_degraded</a> () const noexcept</td></tr>
<tr class="memdesc:a4b939f02167fe69a9b10fae2554826a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this lock has degraded due to a network user trying to use it. <br/></td></tr>
<tr class="separator:a4b939f02167fe69a9b10fae2554826a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af066bb4d3f9f7020b60733ff0bcc99df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af066bb4d3f9f7020b60733ff0bcc99df"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classafio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html#af066bb4d3f9f7020b60733ff0bcc99df">memory_map</a> (<a class="el" href="classafio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html">memory_map</a> &amp;&amp;o) noexcept</td></tr>
<tr class="memdesc:af066bb4d3f9f7020b60733ff0bcc99df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. <br/></td></tr>
<tr class="separator:af066bb4d3f9f7020b60733ff0bcc99df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45a6e65f4a2fe737c10a23b357fc1349"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a45a6e65f4a2fe737c10a23b357fc1349"></a>
<a class="el" href="classafio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html">memory_map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classafio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html#a45a6e65f4a2fe737c10a23b357fc1349">operator=</a> (<a class="el" href="classafio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html">memory_map</a> &amp;&amp;o) noexcept</td></tr>
<tr class="memdesc:a45a6e65f4a2fe737c10a23b357fc1349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assign. <br/></td></tr>
<tr class="separator:a45a6e65f4a2fe737c10a23b357fc1349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf62428585d7179c4490934f02c8d24"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aacf62428585d7179c4490934f02c8d24"></a>
const <a class="el" href="classafio__v2__xxx_1_1file__handle.html">file_handle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classafio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html#aacf62428585d7179c4490934f02c8d24">handle</a> () const noexcept</td></tr>
<tr class="memdesc:aacf62428585d7179c4490934f02c8d24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the handle to file being used for this lock. <br/></td></tr>
<tr class="separator:aacf62428585d7179c4490934f02c8d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc0f8bf3c61cb2dd0bc74c4db7d316f7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc0f8bf3c61cb2dd0bc74c4db7d316f7"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classafio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html#adc0f8bf3c61cb2dd0bc74c4db7d316f7">unlock</a> (<a class="el" href="classafio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html#ab9b3f3598d373786919eafc643d78633">entities_type</a> entities, unsigned long long hint) noexceptoverridefinal</td></tr>
<tr class="memdesc:adc0f8bf3c61cb2dd0bc74c4db7d316f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock a previously locked sequence of entities. <br/></td></tr>
<tr class="separator:adc0f8bf3c61cb2dd0bc74c4db7d316f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b28acf46a3d4ebe93b6031d90f79ac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96b28acf46a3d4ebe93b6031d90f79ac"></a>
<a class="el" href="classafio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html#a33d3ab28b81a5b1eedcc8eb217f78eab">entity_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classafio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html#a96b28acf46a3d4ebe93b6031d90f79ac">entity_from_buffer</a> (const char *buffer, size_t bytes, bool exclusive=true) noexcept</td></tr>
<tr class="memdesc:a96b28acf46a3d4ebe93b6031d90f79ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates an entity id from a sequence of bytes. <br/></td></tr>
<tr class="separator:a96b28acf46a3d4ebe93b6031d90f79ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd51b21b55c1ed21fcea0edaefdae85"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3cd51b21b55c1ed21fcea0edaefdae85"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3cd51b21b55c1ed21fcea0edaefdae85"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classafio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html#a33d3ab28b81a5b1eedcc8eb217f78eab">entity_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classafio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html#a3cd51b21b55c1ed21fcea0edaefdae85">entity_from_string</a> (const std::basic_string&lt; T &gt; &amp;str, bool exclusive=true) noexcept</td></tr>
<tr class="memdesc:a3cd51b21b55c1ed21fcea0edaefdae85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates an entity id from a string. <br/></td></tr>
<tr class="separator:a3cd51b21b55c1ed21fcea0edaefdae85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17f374fc7863784f478498eac95dcc70"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17f374fc7863784f478498eac95dcc70"></a>
<a class="el" href="classafio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html#a33d3ab28b81a5b1eedcc8eb217f78eab">entity_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classafio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html#a17f374fc7863784f478498eac95dcc70">random_entity</a> (bool exclusive=true) noexcept</td></tr>
<tr class="memdesc:a17f374fc7863784f478498eac95dcc70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a cryptographically random entity id. <br/></td></tr>
<tr class="separator:a17f374fc7863784f478498eac95dcc70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d2d3fb211c48b0322333c55e1d019a5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d2d3fb211c48b0322333c55e1d019a5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classafio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html#a1d2d3fb211c48b0322333c55e1d019a5">fill_random_entities</a> (span&lt; <a class="el" href="classafio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html#a33d3ab28b81a5b1eedcc8eb217f78eab">entity_type</a> &gt; seq, bool exclusive=true) noexcept</td></tr>
<tr class="memdesc:a1d2d3fb211c48b0322333c55e1d019a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a sequence of entity ids with cryptographic randomness. Much faster than calling random_entity() individually. <br/></td></tr>
<tr class="separator:a1d2d3fb211c48b0322333c55e1d019a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e82ae0ca11932f5287b0ca2f4834da6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e82ae0ca11932f5287b0ca2f4834da6"></a>
result&lt; <a class="el" href="classafio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex_1_1entities__guard.html">entities_guard</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classafio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html#a2e82ae0ca11932f5287b0ca2f4834da6">lock</a> (<a class="el" href="classafio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html#ab9b3f3598d373786919eafc643d78633">entities_type</a> entities, <a class="el" href="structafio__v2__xxx_1_1deadline.html">deadline</a> d=<a class="el" href="structafio__v2__xxx_1_1deadline.html">deadline</a>(), bool spin_not_sleep=false) noexcept</td></tr>
<tr class="memdesc:a2e82ae0ca11932f5287b0ca2f4834da6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock all of a sequence of entities for exclusive or shared access. <br/></td></tr>
<tr class="separator:a2e82ae0ca11932f5287b0ca2f4834da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1dbb5f7b7887690b47b1d24940a054d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac1dbb5f7b7887690b47b1d24940a054d"></a>
result&lt; <a class="el" href="classafio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex_1_1entities__guard.html">entities_guard</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classafio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html#ac1dbb5f7b7887690b47b1d24940a054d">lock</a> (<a class="el" href="classafio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html#a33d3ab28b81a5b1eedcc8eb217f78eab">entity_type</a> entity, <a class="el" href="structafio__v2__xxx_1_1deadline.html">deadline</a> d=<a class="el" href="structafio__v2__xxx_1_1deadline.html">deadline</a>(), bool spin_not_sleep=false) noexcept</td></tr>
<tr class="memdesc:ac1dbb5f7b7887690b47b1d24940a054d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock a single entity for exclusive or shared access. <br/></td></tr>
<tr class="separator:ac1dbb5f7b7887690b47b1d24940a054d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0987b9c6c93a65acb2715e589d45c273"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0987b9c6c93a65acb2715e589d45c273"></a>
result&lt; <a class="el" href="classafio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex_1_1entities__guard.html">entities_guard</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classafio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html#a0987b9c6c93a65acb2715e589d45c273">try_lock</a> (<a class="el" href="classafio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html#ab9b3f3598d373786919eafc643d78633">entities_type</a> entities) noexcept</td></tr>
<tr class="memdesc:a0987b9c6c93a65acb2715e589d45c273"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to lock all of a sequence of entities for exclusive or shared access. <br/></td></tr>
<tr class="separator:a0987b9c6c93a65acb2715e589d45c273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebdc3d01ccb30b297950130c7ebac57b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aebdc3d01ccb30b297950130c7ebac57b"></a>
result&lt; <a class="el" href="classafio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex_1_1entities__guard.html">entities_guard</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classafio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html#aebdc3d01ccb30b297950130c7ebac57b">try_lock</a> (<a class="el" href="classafio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html#a33d3ab28b81a5b1eedcc8eb217f78eab">entity_type</a> entity) noexcept</td></tr>
<tr class="memdesc:aebdc3d01ccb30b297950130c7ebac57b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to lock a single entity for exclusive or shared access. <br/></td></tr>
<tr class="separator:aebdc3d01ccb30b297950130c7ebac57b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a5706f64aff5256b56b54f9f8b2a99d3b"><td class="memItemLeft" align="right" valign="top">static result&lt; <a class="el" href="classafio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html">memory_map</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classafio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html#a5706f64aff5256b56b54f9f8b2a99d3b">fs_mutex_map</a> (const <a class="el" href="classafio__v2__xxx_1_1path__handle.html">path_handle</a> &amp;base, <a class="el" href="classafio__v2__xxx_1_1path__view.html">path_view</a> lockfile, <a class="el" href="classafio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html">shared_fs_mutex</a> *fallbacklock=nullptr) noexcept</td></tr>
<tr class="separator:a5706f64aff5256b56b54f9f8b2a99d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aa9686424aec6d97205000cd6f0c952ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa9686424aec6d97205000cd6f0c952ca"></a>
virtual result&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_lock</b> (<a class="el" href="classafio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex_1_1entities__guard.html">entities_guard</a> &amp;out, <a class="el" href="structafio__v2__xxx_1_1deadline.html">deadline</a> d, bool spin_not_sleep) noexceptoverridefinal</td></tr>
<tr class="separator:aa9686424aec6d97205000cd6f0c952ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:ae9db904ce395dbe22387d53e79e3e2cf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9db904ce395dbe22387d53e79e3e2cf"></a>
static span&lt; <a class="el" href="structafio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map_1_1__entity__idx.html">_entity_idx</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_hash_entities</b> (<a class="el" href="structafio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map_1_1__entity__idx.html">_entity_idx</a> *entity_to_idx, <a class="el" href="classafio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html#ab9b3f3598d373786919eafc643d78633">entities_type</a> &amp;entities)</td></tr>
<tr class="separator:ae9db904ce395dbe22387d53e79e3e2cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;template&lt; class &gt; class Hasher = QUICKCPPLIB_NAMESPACE::algorithm::hash::fnv1a_hash, size_t HashIndexSize = 4096, class SpinlockType = QUICKCPPLIB_NAMESPACE::configurable_spinlock::shared_spinlock&lt;&gt;&gt;<br/>
class afio_v2_xxx::algorithm::shared_fs_mutex::memory_map&lt; Hasher, HashIndexSize, SpinlockType &gt;</h3>

<p>Many entity memory mapped shared/exclusive file system based lock. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Hasher</td><td>A STL compatible hash algorithm to use (defaults to <code>fnv1a_hash</code>) </td></tr>
    <tr><td class="paramname">HashIndexSize</td><td>The size in bytes of the hash index to use (defaults to 4Kb) </td></tr>
    <tr><td class="paramname">SpinlockType</td><td>The type of spinlock to use (defaults to a <code>SharedMutex</code> concept spinlock)</td></tr>
  </table>
  </dd>
</dl>
<p>This is the highest performing filing system mutex in AFIO, but it comes with a long list of potential gotchas. It works by creating a random temporary file somewhere on the system and placing its path in a file at the lock file location. The random temporary file is mapped into memory by all processes using the lock where an open addressed hash table is kept. Each entity is hashed into somewhere in the hash table and its individual spin lock is used to implement the exclusion. As with <code>byte_ranges</code>, each entity is locked individually in sequence but if a particular lock fails, all are unlocked and the list is randomised before trying again. Because this locking implementation is entirely implemented in userspace using shared memory without any kernel syscalls, performance is probably as fast as any many-arbitrary-entity shared locking system could be.</p>
<p>Performance ought to be excellent so long as no lock user attempts to use the lock from across a networked filing system. As soon as a locking entity fails to find the temporary file given in the lock file location, it will <em>permanently</em> degrade the memory mapped lock into the "fallback" lock specified in the constructor (if you do not specify one, <code>EBUSY</code> will be forever returned from then on when trying to lock). It is up to the end user to decide when it might be time to destroy and reconstruct <code>memory_map</code> in order to restore full performance.</p>
<ul>
<li>Compatible with networked file systems, though with a substantial performance degrade as described above.</li>
<li>Linear complexity to number of concurrent users up until hash table starts to get full or hashed entries collide.</li>
<li>Sudden power loss during use is recovered from.</li>
<li>Safe for multithreaded usage of the same instance.</li>
<li>In the lightly contended case, an order of magnitude faster than any other <code>shared_fs_mutex</code> algorithm.</li>
</ul>
<p>Caveats:</p>
<ul>
<li>A transition between mapped and fallback locks will not complete until all current mapped memory users have realised the transition has happened. This can take a very significant amount of time if a lock user does not regularly lock its locks.</li>
<li>No ability to sleep until a lock becomes free, so CPUs are spun at 100%.</li>
<li>Sudden process exit with locks held will deadlock all other users.</li>
<li>Exponential complexity to number of entities being concurrently locked.</li>
<li>Exponential complexity to concurrency if entities hash to the same cache line. Most SMP and especially NUMA systems have a finite bandwidth for atomic compare and swap operations, and every attempt to lock or unlock an entity under this implementation is several of those operations. Under heavy contention, whole system performance very noticeably nose dives from excessive atomic operations, things like audio and the mouse pointer will stutter.</li>
<li>Sometimes different entities hash to the same offset and collide with one another, causing very poor performance.</li>
<li>Byte range locks need to work properly on your system. Misconfiguring NFS or Samba to cause byte range locks to not work right will produce bad outcomes.</li>
<li>Memory mapped files need to be cache unified with normal i/o in your OS kernel. Known OSs which don't use a unified cache for memory mapped and normal i/o are QNX, OpenBSD. Furthermore, doing normal i/o and memory mapped i/o to the same file needs to not corrupt the file. In the past, there have been editions of the Linux kernel and the OS X kernel which did this.</li>
<li>If your OS doesn't have sane byte range locks (OS X, BSD, older Linuxes) and multiple objects in your process use the same lock file, misoperation will occur.</li>
</ul>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd><p class="startdd">It should be possible to auto early out from a memory_map transition by scanning the memory map for any locked items, and if none then to proceed. </p>
<p>fs_mutex_map needs to check if this inode is that at the path after lock is granted, awaiting stat_t port. </p>
<p>memory_map::_hash_entities needs to hash x16, x8 and x4 at a time to encourage auto vectorisation </p>
<p class="enddd">memory_map::unlock() degrade is racy when single instance being used by multiple threads </p>
</dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a5706f64aff5256b56b54f9f8b2a99d3b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class &gt; class Hasher = QUICKCPPLIB_NAMESPACE::algorithm::hash::fnv1a_hash, size_t HashIndexSize = 4096, class SpinlockType  = QUICKCPPLIB_NAMESPACE::configurable_spinlock::shared_spinlock&lt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static result&lt;<a class="el" href="classafio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html">memory_map</a>&gt; <a class="el" href="classafio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html">afio_v2_xxx::algorithm::shared_fs_mutex::memory_map</a>&lt; Hasher, HashIndexSize, SpinlockType &gt;::fs_mutex_map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classafio__v2__xxx_1_1path__handle.html">path_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classafio__v2__xxx_1_1path__view.html">path_view</a>&#160;</td>
          <td class="paramname"><em>lockfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classafio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html">shared_fs_mutex</a> *&#160;</td>
          <td class="paramname"><em>fallbacklock</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialises a shared filing system mutex using the file at <em>lockfile</em> and an optional fallback lock. </p>
<dl class="section user"><dt>Errors returnable</dt><dd>Awaiting the clang result&lt;&gt; AST parser which auto generates all the error codes which could occur, but a particularly important one is <code>EBUSY</code> which will be returned if the memory map lock is already in a degraded state (i.e. just use the fallback lock directly). </dd></dl>
<div class="fragment"><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;      {</div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;        AFIO_LOG_FUNCTION_CALL(0);</div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;        <span class="keywordflow">try</span></div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;        {</div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;          OUTCOME_TRY(ret, <a class="code" href="classafio__v2__xxx_1_1file__handle.html#a6f4e7c6e9768c0e853105b1d63bd9dfb">file_handle::file</a>(base, lockfile, <a class="code" href="classafio__v2__xxx_1_1handle.html#a0489b6c1e25cd2bad2ba1ec86e1aaf18aefb2a684e4afb7d55e6147fbe5a332ee">file_handle::mode::write</a>, file_handle::creation::if_needed, <a class="code" href="classafio__v2__xxx_1_1handle.html#a6f7e37c73271968271c2342023f58c9ea0fb9cf5f04f61bb6f1151da57ceb1ca1">file_handle::caching::reads</a>));</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;          file_handle temph;</div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;          <span class="comment">// Am I the first person to this file? Lock the inuse exclusively</span></div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;          <span class="keyword">auto</span> lockinuse = ret.try_lock(_lockinuseoffset, 1, <span class="keyword">true</span>);</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;          file_handle::extent_guard mapinuse;</div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;          <span class="keywordflow">if</span>(lockinuse.has_error())</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;          {</div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;            <span class="keywordflow">if</span>(lockinuse.error() != std::errc::timed_out)</div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;              <span class="keywordflow">return</span> lockinuse.error();</div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;            <span class="comment">// Somebody else is also using this file, so try to read the hash index file I ought to use</span></div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;            lockinuse = ret.lock(_lockinuseoffset, 1, <span class="keyword">false</span>);  <span class="comment">// last byte shared access</span></div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;            <span class="keywordtype">char</span> buffer[65536];</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;            memset(buffer, 0, <span class="keyword">sizeof</span>(buffer));</div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;            {</div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;              OUTCOME_TRY(_, ret.read(0, buffer, 65535));</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;              (void) _;</div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;            }</div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;            path_view temphpath((filesystem::path::value_type *) buffer);</div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;            result&lt;file_handle&gt; _temph(in_place_type&lt;file_handle&gt;);</div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;            <span class="comment">// If path is zeroed, fall back onto backup lock</span></div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;            <span class="keywordflow">if</span>(!buffer[0])</div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;              <span class="keywordflow">goto</span> use_fall_back_lock;</div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;            <span class="keywordflow">else</span></div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;              _temph = <a class="code" href="classafio__v2__xxx_1_1file__handle.html#a6f4e7c6e9768c0e853105b1d63bd9dfb">file_handle::file</a>({}, temphpath, <a class="code" href="classafio__v2__xxx_1_1handle.html#a0489b6c1e25cd2bad2ba1ec86e1aaf18aefb2a684e4afb7d55e6147fbe5a332ee">file_handle::mode::write</a>, file_handle::creation::open_existing, <a class="code" href="classafio__v2__xxx_1_1handle.html#a6f7e37c73271968271c2342023f58c9ead5197d93c063a2b1e22d1630a39b7aef">file_handle::caching::temporary</a>);</div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;            <span class="comment">// If temp file doesn&#39;t exist, I am on a different machine</span></div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;            <span class="keywordflow">if</span>(!_temph)</div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;            {</div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;              <span class="comment">// Zop the path so any new entrants into this lock will go to the fallback lock</span></div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;              memset(buffer, 0, 4096);</div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;              (void) ret.write(0, buffer, 4096);</div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;            use_fall_back_lock:</div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;              <span class="comment">// I am guaranteed that all mmap users have locked the second last byte</span></div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;              <span class="comment">// and will unlock it once everyone has stopped using the mmap, so make</span></div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;              <span class="comment">// absolutely sure the mmap is not in use by anyone by taking an exclusive</span></div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;              <span class="comment">// lock on the second final byte</span></div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;              OUTCOME_TRYV(ret.lock(_mapinuseoffset, 1, <span class="keyword">true</span>));</div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;              <span class="comment">// Release the exclusive lock and tell caller to just use the fallback lock directly</span></div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;              <span class="keywordflow">return</span> std::errc::device_or_resource_busy;</div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;            }</div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;            <span class="keywordflow">else</span></div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;            {</div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;              <span class="comment">// Mark the map as being in use by me too</span></div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;              OUTCOME_TRY(mapinuse2, ret.lock(_mapinuseoffset, 1, <span class="keyword">false</span>));</div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;              mapinuse = std::move(mapinuse2);</div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;              temph = std::move(_temph.value());</div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;            }</div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;            <span class="comment">// Map the files into memory, being very careful that the lock file is only ever mapped read only</span></div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;            <span class="comment">// as some OSs can get confused if you use non-mmaped writes on a region mapped for writing.</span></div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;            OUTCOME_TRY(hsection, <a class="code" href="classafio__v2__xxx_1_1section__handle.html#a34cf4f9a6ec20c2a456d6b6313f0e595">section_handle::section</a>(ret, 0, section_handle::flag::read));</div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;            OUTCOME_TRY(temphsection, <a class="code" href="classafio__v2__xxx_1_1section__handle.html#a34cf4f9a6ec20c2a456d6b6313f0e595">section_handle::section</a>(temph, HashIndexSize));</div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;            OUTCOME_TRY(hmap, <a class="code" href="classafio__v2__xxx_1_1map__handle.html#af5f18eca79c68d7db2923c2817d1c6fb">map_handle::map</a>(hsection, 0, 0, section_handle::flag::read));</div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;            OUTCOME_TRY(temphmap, <a class="code" href="classafio__v2__xxx_1_1map__handle.html#af5f18eca79c68d7db2923c2817d1c6fb">map_handle::map</a>(temphsection, HashIndexSize));</div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;            <span class="keywordflow">return</span> memory_map(std::move(ret), std::move(temph), std::move(lockinuse.value()), std::move(mapinuse), std::move(hmap), std::move(temphmap), fallbacklock);</div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;          }</div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;          <span class="keywordflow">else</span></div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;          {</div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;            <span class="comment">// I am the first person to be using this (stale?) file, so create a new hash index file and write its path</span></div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;            OUTCOME_TRYV(ret.truncate(0));</div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;            OUTCOME_TRY(tempdirh, <a class="code" href="classafio__v2__xxx_1_1path__handle.html#a5cbd1d67ffe72d6cce0d093f861a4af7">path_handle::path</a>(<a class="code" href="namespaceafio__v2__xxx.html#a4968bb2d647535f4b91427c66ff8b9e4">temporary_files_directory</a>()));</div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;            OUTCOME_TRY(_temph, <a class="code" href="classafio__v2__xxx_1_1file__handle.html#a7fdd164a8af6542c5fb80c514283c585">file_handle::random_file</a>(tempdirh));</div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;            temph = std::move(_temph);</div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;            OUTCOME_TRY(temppath, temph.current_path());</div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;            OUTCOME_TRYV(temph.truncate(HashIndexSize));</div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;            <span class="comment">/* Linux appears to have a race where:</span></div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;<span class="comment">                 1. This process creates a new file and fallocate&#39;s its maximum extent.</span></div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;<span class="comment">                 2. Another process opens this file and mmaps it.</span></div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;<span class="comment">                 3. The other process tries to read from the mmap, and gets a SIGBUS for its efforts.</span></div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;<span class="comment"></span></div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;<span class="comment">               I tried writing zeros using write after the fallocate, but it appears not to help, so</span></div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;<span class="comment">               for Linux compatibility we will have to mmap before publishing the path of the hash index.</span></div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;<span class="comment">            */</span></div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;            <span class="comment">// Map the files into memory, being very careful that the lock file is only ever mapped read only</span></div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;            <span class="comment">// as some OSs can get confused if you use non-mmaped writes on a region mapped for writing.</span></div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;            OUTCOME_TRY(temphsection, <a class="code" href="classafio__v2__xxx_1_1section__handle.html#a34cf4f9a6ec20c2a456d6b6313f0e595">section_handle::section</a>(temph, HashIndexSize));</div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;            OUTCOME_TRY(temphmap, <a class="code" href="classafio__v2__xxx_1_1map__handle.html#af5f18eca79c68d7db2923c2817d1c6fb">map_handle::map</a>(temphsection, HashIndexSize));</div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;            <span class="comment">// Force page allocation now</span></div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;            memset(temphmap.address(), 0, HashIndexSize);</div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;            <span class="comment">// Write the path of my new hash index file and convert my lock to a shared one</span></div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;            OUTCOME_TRYV(ret.write(0, (<span class="keyword">const</span> <span class="keywordtype">char</span> *) temppath.c_str(), temppath.native().size() * <span class="keyword">sizeof</span>(*temppath.c_str())));</div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;            OUTCOME_TRY(hsection, <a class="code" href="classafio__v2__xxx_1_1section__handle.html#a34cf4f9a6ec20c2a456d6b6313f0e595">section_handle::section</a>(ret, 0, section_handle::flag::read));</div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;            OUTCOME_TRY(hmap, <a class="code" href="classafio__v2__xxx_1_1map__handle.html#af5f18eca79c68d7db2923c2817d1c6fb">map_handle::map</a>(hsection, 0, 0, section_handle::flag::read));</div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;            <span class="comment">// Convert exclusive whole file lock into lock in use</span></div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;            OUTCOME_TRY(mapinuse2, ret.lock(_mapinuseoffset, 1, <span class="keyword">false</span>));</div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;            OUTCOME_TRY(lockinuse2, ret.lock(_lockinuseoffset, 1, <span class="keyword">false</span>));</div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;            mapinuse = std::move(mapinuse2);</div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;            lockinuse = std::move(lockinuse2);</div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;            <span class="keywordflow">return</span> memory_map(std::move(ret), std::move(temph), std::move(lockinuse.value()), std::move(mapinuse), std::move(hmap), std::move(temphmap), fallbacklock);</div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;          }</div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;        }</div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;        <span class="keywordflow">catch</span>(...)</div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;        {</div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;          <span class="keywordflow">return</span> error_from_exception();</div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;        }</div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;      }</div>
<div class="ttc" id="classafio__v2__xxx_1_1handle_html_a6f7e37c73271968271c2342023f58c9ea0fb9cf5f04f61bb6f1151da57ceb1ca1"><div class="ttname"><a href="classafio__v2__xxx_1_1handle.html#a6f7e37c73271968271c2342023f58c9ea0fb9cf5f04f61bb6f1151da57ceb1ca1">afio_v2_xxx::handle::caching::reads</a></div><div class="ttdoc">Cache reads only. Writes of data and metadata do not complete until reaching storage (O_SYNC)...</div></div>
<div class="ttc" id="classafio__v2__xxx_1_1map__handle_html_af5f18eca79c68d7db2923c2817d1c6fb"><div class="ttname"><a href="classafio__v2__xxx_1_1map__handle.html#af5f18eca79c68d7db2923c2817d1c6fb">afio_v2_xxx::map_handle::map</a></div><div class="ttdeci">static result&lt; map_handle &gt; map(size_type bytes, section_handle::flag _flag=section_handle::flag::read|section_handle::flag::write) noexcept</div></div>
<div class="ttc" id="namespaceafio__v2__xxx_html_a4968bb2d647535f4b91427c66ff8b9e4"><div class="ttname"><a href="namespaceafio__v2__xxx.html#a4968bb2d647535f4b91427c66ff8b9e4">afio_v2_xxx::temporary_files_directory</a></div><div class="ttdeci">path_view temporary_files_directory() noexcept</div><div class="ttdoc">Returns a path to a directory reported by the operating system to be suitable for storing temporary f...</div></div>
<div class="ttc" id="classafio__v2__xxx_1_1handle_html_a0489b6c1e25cd2bad2ba1ec86e1aaf18aefb2a684e4afb7d55e6147fbe5a332ee"><div class="ttname"><a href="classafio__v2__xxx_1_1handle.html#a0489b6c1e25cd2bad2ba1ec86e1aaf18aefb2a684e4afb7d55e6147fbe5a332ee">afio_v2_xxx::handle::mode::write</a></div><div class="ttdoc">Ability to read and write (READ_CONTROL|FILE_READ_DATA|FILE_READ_ATTRIBUTES|FILE_READ_EA|FILE_WRITE_D...</div></div>
<div class="ttc" id="classafio__v2__xxx_1_1section__handle_html_a34cf4f9a6ec20c2a456d6b6313f0e595"><div class="ttname"><a href="classafio__v2__xxx_1_1section__handle.html#a34cf4f9a6ec20c2a456d6b6313f0e595">afio_v2_xxx::section_handle::section</a></div><div class="ttdeci">static result&lt; section_handle &gt; section(file_handle &amp;backing, extent_type maximum_size=0, flag _flag=flag::read|flag::write) noexcept</div><div class="ttdoc">Create a memory section. </div></div>
<div class="ttc" id="classafio__v2__xxx_1_1path__handle_html_a5cbd1d67ffe72d6cce0d093f861a4af7"><div class="ttname"><a href="classafio__v2__xxx_1_1path__handle.html#a5cbd1d67ffe72d6cce0d093f861a4af7">afio_v2_xxx::path_handle::path</a></div><div class="ttdeci">static result&lt; path_handle &gt; path(const path_handle &amp;base, path_view_type _path) noexcept</div></div>
<div class="ttc" id="classafio__v2__xxx_1_1file__handle_html_a7fdd164a8af6542c5fb80c514283c585"><div class="ttname"><a href="classafio__v2__xxx_1_1file__handle.html#a7fdd164a8af6542c5fb80c514283c585">afio_v2_xxx::file_handle::random_file</a></div><div class="ttdeci">static result&lt; file_handle &gt; random_file(const path_handle &amp;dirpath, mode _mode=mode::write, caching _caching=caching::temporary, flag flags=flag::none) noexcept</div><div class="ttdef"><b>Definition:</b> file_handle.hpp:159</div></div>
<div class="ttc" id="classafio__v2__xxx_1_1file__handle_html_a6f4e7c6e9768c0e853105b1d63bd9dfb"><div class="ttname"><a href="classafio__v2__xxx_1_1file__handle.html#a6f4e7c6e9768c0e853105b1d63bd9dfb">afio_v2_xxx::file_handle::file</a></div><div class="ttdeci">static result&lt; file_handle &gt; file(const path_handle &amp;base, path_view_type _path, mode _mode=mode::read, creation _creation=creation::open_existing, caching _caching=caching::all, flag flags=flag::none) noexcept</div></div>
<div class="ttc" id="classafio__v2__xxx_1_1handle_html_a6f7e37c73271968271c2342023f58c9ead5197d93c063a2b1e22d1630a39b7aef"><div class="ttname"><a href="classafio__v2__xxx_1_1handle.html#a6f7e37c73271968271c2342023f58c9ead5197d93c063a2b1e22d1630a39b7aef">afio_v2_xxx::handle::caching::temporary</a></div><div class="ttdoc">Cache reads and writes of data and metadata so they complete immediately, only sending any updates to...</div></div>
</div><!-- fragment -->
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/afio/v2.0/algorithm/shared_fs_mutex/<a class="el" href="memory__map_8hpp.html">memory_map.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceafio__v2__xxx.html">afio_v2_xxx</a></li><li class="navelem"><a class="el" href="namespaceafio__v2__xxx_1_1algorithm.html">algorithm</a></li><li class="navelem"><a class="el" href="namespaceafio__v2__xxx_1_1algorithm_1_1shared__fs__mutex.html">shared_fs_mutex</a></li><li class="navelem"><a class="el" href="classafio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html">memory_map</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
