[/============================================================================
  Boost.AFIO

  Use, modification and distribution is subject to the Boost Software License,
  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt)
=============================================================================/]


[/ Generated by doxygen_xml2qbk 1.1.1, don't change, will be overwritten automatically]
[/ Generated from doxy/doxygen_output/xml\classboost_1_1afio_1_1directory__entry.xml]
[section:directory_entry directory_entry]

'''<indexterm><primary>directory_entry</primary></indexterm>'''
The abstract base class for an entry in a directory with lazily filled metadata. 

[heading Description]
Note that [^`directory_entry_hash`] will hash one of these for you, and a [^`std::hash<``directory_entry``>`] specialisation is defined for you so you ought to be able to use directory\u005fentry directly in an [^`unordered_map<>`]. 

[heading Synopsis]
``class directory_entry
{
  // ...
};
``

[heading Constructor(s)]
[table
[[Function] [Description] [Parameters] ]
[[``directory_entry()``

] [Default constructor. ] [


]]
[[``directory_entry(std::filesystem::path _leafname, stat_t __stat, metadata_flags _have_metadata)``

] [Default constructor. ] [[* std::filesystem::path]: ['_leafname]:  

[* stat_t]: ['__stat]:  

[* metadata_flags]: ['_have_metadata]:  




]]
[[``directory_entry(const directory_entry & )``

] [] [[* const directory_entry &]: [']:  




]]
[[``directory_entry(directory_entry && o)``

] [] [[* directory_entry &&]: ['o]:  




]]
]

[heading Member Function(s)]
[table
[[Function] [Description] [Parameters]  [Returns]]
[[``directory_entry & operator=(const directory_entry & )``

] [] [[* const directory_entry &]: [']:  




]]
[[``directory_entry & operator=(directory_entry && o)``

] [] [[* directory_entry &&]: ['o]:  




]]
[[``bool operator==(const directory_entry & rhs)``

] [] [[* const directory_entry &]: ['rhs]:  




]]
[[``bool operator!=(const directory_entry & rhs)``

] [] [[* const directory_entry &]: ['rhs]:  




]]
[[``bool operator<(const directory_entry & rhs)``

] [] [[* const directory_entry &]: ['rhs]:  




]]
[[``bool operator<=(const directory_entry & rhs)``

] [] [[* const directory_entry &]: ['rhs]:  




]]
[[``bool operator>(const directory_entry & rhs)``

] [] [[* const directory_entry &]: ['rhs]:  




]]
[[``bool operator>=(const directory_entry & rhs)``

] [] [[* const directory_entry &]: ['rhs]:  




]]
[[``std::filesystem::path name()``

] [] [

][
The name of the directory entry 


]]
[[``metadata_flags metadata_ready()``

] [] [

][
A bitfield of what metadata is ready right now 


]]
[[``metadata_flags fetch_metadata(std::shared_ptr< async_io_handle > dirh, metadata_flags wanted)``

] [Fetches the specified metadata, returning that newly available. This is a blocking call if wanted metadata is not yet ready. ] [[* std::shared_ptr< async_io_handle >]: ['dirh]:  An open handle to the entry's containing directory. You can get this from an op ref using dirop.h->get(). 

[* metadata_flags]: ['wanted]:  A bitfield of the metadata to fetch. This does not replace existing metadata. 



][
The metadata now available in this directory entry. 


]]
[[``stat_t fetch_lstat(std::shared_ptr< async_io_handle > dirh, metadata_flags wanted = directory_entry::metadata_fastpath())``

] [Returns a copy of the internal [^`stat_t`] structure. This is a blocking call if wanted metadata is not yet ready. ] [[* std::shared_ptr< async_io_handle >]: ['dirh]:  An open handle to the entry's containing directory. You can get this from an op ref using dirop.h->get(). 

[* metadata_flags]: ['wanted]:  A bitfield of the metadata to fetch. This does not replace existing metadata. 



][
A copy of the internal [^`stat_t`] structure. 


]]
[[``decltype(stat_t().st_dev) st_dev(std::shared_ptr< async_io_handle > dirh = std::shared_ptr< async_io_handle >())``

] [Returns st_dev. ] [[* std::shared_ptr< async_io_handle >]: ['dirh]:  An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.h->get(). 




]]
[[``decltype(stat_t().st_ino) st_ino(std::shared_ptr< async_io_handle > dirh = std::shared_ptr< async_io_handle >())``

] [Returns st_ino. ] [[* std::shared_ptr< async_io_handle >]: ['dirh]:  An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.h->get(). 




]]
[[``decltype(stat_t().st_type) st_type(std::shared_ptr< async_io_handle > dirh = std::shared_ptr< async_io_handle >())``

] [Returns st_type. ] [[* std::shared_ptr< async_io_handle >]: ['dirh]:  An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.h->get(). 




]]
[[``decltype(stat_t().st_perms) st_perms(std::shared_ptr< async_io_handle > dirh = std::shared_ptr< async_io_handle >())``

] [Returns st_perms. ] [[* std::shared_ptr< async_io_handle >]: ['dirh]:  An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.h->get(). 




]]
[[``decltype(stat_t().st_nlink) st_nlink(std::shared_ptr< async_io_handle > dirh = std::shared_ptr< async_io_handle >())``

] [Returns st_nlink. ] [[* std::shared_ptr< async_io_handle >]: ['dirh]:  An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.h->get(). 




]]
[[``decltype(stat_t().st_uid) st_uid(std::shared_ptr< async_io_handle > dirh = std::shared_ptr< async_io_handle >())``

] [Returns st_uid. ] [[* std::shared_ptr< async_io_handle >]: ['dirh]:  An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.h->get(). 




]]
[[``decltype(stat_t().st_gid) st_gid(std::shared_ptr< async_io_handle > dirh = std::shared_ptr< async_io_handle >())``

] [Returns st_gid. ] [[* std::shared_ptr< async_io_handle >]: ['dirh]:  An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.h->get(). 




]]
[[``decltype(stat_t().st_rdev) st_rdev(std::shared_ptr< async_io_handle > dirh = std::shared_ptr< async_io_handle >())``

] [Returns st_rdev. ] [[* std::shared_ptr< async_io_handle >]: ['dirh]:  An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.h->get(). 




]]
[[``decltype(stat_t().st_atim) st_atim(std::shared_ptr< async_io_handle > dirh = std::shared_ptr< async_io_handle >())``

] [Returns st_atim. ] [[* std::shared_ptr< async_io_handle >]: ['dirh]:  An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.h->get(). 




]]
[[``decltype(stat_t().st_mtim) st_mtim(std::shared_ptr< async_io_handle > dirh = std::shared_ptr< async_io_handle >())``

] [Returns st_mtim. ] [[* std::shared_ptr< async_io_handle >]: ['dirh]:  An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.h->get(). 




]]
[[``decltype(stat_t().st_ctim) st_ctim(std::shared_ptr< async_io_handle > dirh = std::shared_ptr< async_io_handle >())``

] [Returns st_ctim. ] [[* std::shared_ptr< async_io_handle >]: ['dirh]:  An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.h->get(). 




]]
[[``decltype(stat_t().st_size) st_size(std::shared_ptr< async_io_handle > dirh = std::shared_ptr< async_io_handle >())``

] [Returns st_size. ] [[* std::shared_ptr< async_io_handle >]: ['dirh]:  An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.h->get(). 




]]
[[``decltype(stat_t().st_allocated) st_allocated(std::shared_ptr< async_io_handle > dirh = std::shared_ptr< async_io_handle >())``

] [Returns st_allocated. ] [[* std::shared_ptr< async_io_handle >]: ['dirh]:  An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.h->get(). 




]]
[[``decltype(stat_t().st_blocks) st_blocks(std::shared_ptr< async_io_handle > dirh = std::shared_ptr< async_io_handle >())``

] [Returns st_blocks. ] [[* std::shared_ptr< async_io_handle >]: ['dirh]:  An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.h->get(). 




]]
[[``decltype(stat_t().st_blksize) st_blksize(std::shared_ptr< async_io_handle > dirh = std::shared_ptr< async_io_handle >())``

] [Returns st_blksize. ] [[* std::shared_ptr< async_io_handle >]: ['dirh]:  An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.h->get(). 




]]
[[``decltype(stat_t().st_flags) st_flags(std::shared_ptr< async_io_handle > dirh = std::shared_ptr< async_io_handle >())``

] [Returns st_flags. ] [[* std::shared_ptr< async_io_handle >]: ['dirh]:  An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.h->get(). 




]]
[[``decltype(stat_t().st_gen) st_gen(std::shared_ptr< async_io_handle > dirh = std::shared_ptr< async_io_handle >())``

] [Returns st_gen. ] [[* std::shared_ptr< async_io_handle >]: ['dirh]:  An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.h->get(). 




]]
[[``decltype(stat_t().st_birthtim) st_birthtim(std::shared_ptr< async_io_handle > dirh = std::shared_ptr< async_io_handle >())``

] [Returns st_birthtim. ] [[* std::shared_ptr< async_io_handle >]: ['dirh]:  An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.h->get(). 




]]
[[``metadata_flags metadata_supported()``

] [A bitfield of what metadata is available on this platform. This doesn't mean all is available for every filing system. ] [


]]
[[``metadata_flags metadata_fastpath()``

] [A bitfield of what metadata is fast on this platform. This doesn't mean all is available for every filing system. ] [


]]
[[``size_t compatibility_maximum()``

] [The maximum number of entries which is "usual" to fetch at once i.e. what your libc does. ] [


]]
]

[heading Header]
`#include <boost/afio/afio.hpp>`

[endsect]

