[/============================================================================
  Boost.AFIO

  Use, modification and distribution is subject to the Boost Software License,
  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt)
=============================================================================/]


[/ Generated by doxygen_xml2qbk 1.1.0, don't change, will be overwritten automatically]
[/ Generated from doxy/doxygen_output/xml\classboost_1_1afio_1_1async__file__io__dispatcher__base.xml]
[section:async_file_io_dispatcher_base async_file_io_dispatcher_base]

'''<indexterm><primary>async_file_io_dispatcher_base</primary></indexterm>'''
Abstract base class for dispatching file i/o asynchronously. 

[heading Description]
This is a reference counted instance with platform-specific implementation optionally hidden in object code. Construct an instance using the [^`boost::afio::async_file_io_dispatcher()`] function.

[heading Synopsis]
``class async_file_io_dispatcher_base
      : public std::enable_shared_from_this< async_file_io_dispatcher_base >
{
  // ...
};
``

[heading Constructor(s)]
[table
[[Function] [Description] [Parameters] ]
[[``~async_file_io_dispatcher_base()``

] [Destroys the dispatcher, blocking inefficiently if any ops are still in flight. ] [


]]
]

[heading Member Function(s)]
[table
[[Function] [Description] [Parameters]  [Returns]]
[[``std::weak_ptr< thread_source > threadsource()``

] [Returns the thread source used by this dispatcher. ] [


]]
[[``file_flags fileflags(file_flags flags)``

] [Returns file flags as would be used after forcing and masking bits passed during construction. ] [[* file_flags]: ['flags]:  




]]
[[``size_t wait_queue_depth()``

] [Returns the current wait queue depth of this dispatcher. ] [


]]
[[``size_t count()``

] [Returns the number of open items in this dispatcher. ] [


]]
[[``async_io_op op_from_scheduled_id(size_t id)``

] [Returns an op ref for a given [*currently][*scheduled] op id, throwing a fatal exception if id not scheduled at the point of call. Can be used to retrieve exception state from some op id, or one's own shared future. ] [[* size_t]: ['id]:  The unique integer id for the op. 



][
An async_io_op with the same shared future as all op refs with this id. 


]]
[[``std::vector< async_io_op > completion(const std::vector< async_io_op > & ops, const std::vector< std::pair< async_op_flags, std::function< async_file_io_dispatcher_base::completion_t >>> & callbacks)``

] [Schedule a batch of asynchronous invocations of the specified functions when their supplied operations complete. ] [[* const std::vector< async_io_op > &]: ['ops]:  A batch of precondition op handles. 

[* const std::vector< std::pair< async_op_flags, std::function< async_file_io_dispatcher_base::completion_t >>> &]: ['callbacks]:  A batch of pairs of op flags and bound completion handler functions of type [^`completion_t`]



][
A batch of op handles 


]]
[[``async_io_op completion(const async_io_op & req, const std::pair< async_op_flags, std::function< async_file_io_dispatcher_base::completion_t >> & callback)``

] [Schedule the asynchronous invocation of the specified single function when the supplied single operation completes. ] [[* const async_io_op &]: ['req]:  A precondition op handle 

[* const std::pair< async_op_flags, std::function< async_file_io_dispatcher_base::completion_t >> &]: ['callback]:  A pair of op flag and bound completion handler function of type [^`completion_t`]



][
An op handle 


]]
[[``template<class R>
std::pair< std::vector< future< R > >, std::vector< async_io_op > > call(const std::vector< async_io_op > & ops, const std::vector< std::function< R()>> & callables)``

] [Schedule a batch of asynchronous invocations of the specified bound functions when their supplied preconditions complete. ] [[* const std::vector< async_io_op > &]: ['ops]:  A batch of precondition op handles. If default constructed, a precondition is null. 

[* const std::vector< std::function< R()>> &]: ['callables]:  A batch of bound functions to call, returning R.



][
A pair with a batch of futures returning the result of each of the callables and a batch of op handles. 


]]
[[``template<class R>
std::pair< std::vector< future< R > >, std::vector< async_io_op > > call(const std::vector< std::function< R()>> & callables)``

] [Schedule a batch of asynchronous invocations of the specified bound functions when their supplied preconditions complete. ] [[* const std::vector< std::function< R()>> &]: ['callables]:  A batch of bound functions to call, returning R.



][
A pair with a batch of futures returning the result of each of the callables and a batch of op handles. 


]]
[[``template<class R>
std::pair< future< R >, async_io_op > call(const async_io_op & req, std::function< R()> callback)``

] [Schedule an asynchronous invocation of the specified bound function when its supplied precondition completes. ] [[* const async_io_op &]: ['req]:  A precondition op handle. If default constructed, the precondition is null. 

[* std::function< R()>]: ['callback]:  A bound functions to call, returning R.



][
A pair with a future returning the result of the callable and an op handle. 


]]
[[``template<class C, class... Args>
std::pair< future< typename detail::vs2013_variadic_overload_resolution_workaround< C, Args...>::type >, async_io_op > call(const async_io_op & req, C callback, Args... args)``

] [Schedule an asynchronous invocation of the specified unbound callable when its supplied precondition completes. Note that this function essentially calls [^`std::bind()`] on the callable and the args and passes it to the other call() overload taking a [^`std::function<>`]. You should therefore use [^`std::ref()`] etc. as appropriate. ] [[* const async_io_op &]: ['req]:  A precondition op handle. If default constructed, the precondition is null. 

[* C]: ['callback]:  An unbound callable to call. 

[* Args...]: ['args]:  An arbitrary sequence of arguments to bind to the callable.



][
A pair with a future returning the result of the callable and an op handle. 


]]
[[``std::vector< async_io_op > adopt(const std::vector< std::shared_ptr< async_io_handle >> & hs)``

] [Schedule a batch of third party handle adoptions. ] [[* const std::vector< std::shared_ptr< async_io_handle >> &]: ['hs]:  A batch of handles to adopt.



][
A batch of op handles. 


]]
[[``async_io_op adopt(std::shared_ptr< async_io_handle > h)``

] [Schedule an adoption of a third party handle. ] [[* std::shared_ptr< async_io_handle >]: ['h]:  A handle to adopt.



][
An op handle. 


]]
[[``std::vector< async_io_op > dir(const std::vector< async_path_op_req > & reqs)``

] [Schedule a batch of asynchronous directory creations and opens after optional preconditions. ] [[* const std::vector< async_path_op_req > &]: ['reqs]:  A batch of [^`async_path_op_req`] structures.



][
A batch of op handles. 


]]
[[``async_io_op dir(const async_path_op_req & req)``

] [Schedule an asynchronous directory creation and open after an optional precondition. ] [[* const async_path_op_req &]: ['req]:  An [^`async_path_op_req`] structure.



][
An op handle. 


]]
[[``std::vector< async_io_op > rmdir(const std::vector< async_path_op_req > & reqs)``

] [Schedule a batch of asynchronous directory deletions after optional preconditions. ] [[* const std::vector< async_path_op_req > &]: ['reqs]:  A batch of [^`async_path_op_req`] structures.



][
A batch of op handles. 


]]
[[``async_io_op rmdir(const async_path_op_req & req)``

] [Schedule an asynchronous directory deletion after an optional precondition. ] [[* const async_path_op_req &]: ['req]:  An [^`async_path_op_req`] structure.



][
An op handle. 


]]
[[``std::vector< async_io_op > file(const std::vector< async_path_op_req > & reqs)``

] [Schedule a batch of asynchronous file creations and opens after optional preconditions. ] [[* const std::vector< async_path_op_req > &]: ['reqs]:  A batch of [^`async_path_op_req`] structures.



][
A batch of op handles. 


]]
[[``async_io_op file(const async_path_op_req & req)``

] [Schedule an asynchronous file creation and open after an optional precondition. ] [[* const async_path_op_req &]: ['req]:  An [^`async_path_op_req`] structure.



][
An op handle. 


]]
[[``std::vector< async_io_op > rmfile(const std::vector< async_path_op_req > & reqs)``

] [Schedule a batch of asynchronous file deletions after optional preconditions. ] [[* const std::vector< async_path_op_req > &]: ['reqs]:  A batch of [^`async_path_op_req`] structures.



][
A batch of op handles. 


]]
[[``async_io_op rmfile(const async_path_op_req & req)``

] [Schedule an asynchronous file deletion after an optional precondition. ] [[* const async_path_op_req &]: ['req]:  An [^`async_path_op_req`] structure.



][
An op handle. 


]]
[[``std::vector< async_io_op > symlink(const std::vector< async_path_op_req > & reqs)``

] [Schedule a batch of asynchronous symlink creations and opens after a precondition. ] [[* const std::vector< async_path_op_req > &]: ['reqs]:  A batch of [^`async_path_op_req`] structures.



][
A batch of op handles. 


]]
[[``async_io_op symlink(const async_path_op_req & req)``

] [Schedule an asynchronous symlink creation and open after a precondition. ] [[* const async_path_op_req &]: ['req]:  An [^`async_path_op_req`] structure.



][
An op handle. 


]]
[[``std::vector< async_io_op > rmsymlink(const std::vector< async_path_op_req > & reqs)``

] [Schedule a batch of asynchronous symlink deletions after optional preconditions. ] [[* const std::vector< async_path_op_req > &]: ['reqs]:  A batch of [^`async_path_op_req`] structures.



][
A batch of op handles. 


]]
[[``async_io_op rmsymlink(const async_path_op_req & req)``

] [Schedule an asynchronous symlink deletion after an optional precondition. ] [[* const async_path_op_req &]: ['req]:  An [^`async_path_op_req`] structure.



][
An op handle. 


]]
[[``std::vector< async_io_op > sync(const std::vector< async_io_op > & ops)``

] [Schedule a batch of asynchronous content synchronisations with physical storage after preceding operations. ] [[* const std::vector< async_io_op > &]: ['ops]:  A batch of op handles.



][
A batch of op handles. 


]]
[[``async_io_op sync(const async_io_op & req)``

] [Schedule an asynchronous content synchronisation with physical storage after a preceding operation. ] [[* const async_io_op &]: ['req]:  An op handle.



][
An op handle. 


]]
[[``std::vector< async_io_op > close(const std::vector< async_io_op > & ops)``

] [Schedule a batch of asynchronous file or directory handle closes after preceding operations. ] [[* const std::vector< async_io_op > &]: ['ops]:  A batch of op handles.



][
A batch of op handles. 


]]
[[``async_io_op close(const async_io_op & req)``

] [Schedule an asynchronous file or directory handle close after a preceding operation. ] [[* const async_io_op &]: ['req]:  An op handle.



][
An op handle. 


]]
[[``template<class T>
std::vector< async_io_op > read(const std::vector< async_data_op_req< T >> & ops)``

] [Schedule a batch of asynchronous data reads after preceding operations. ] [[* const std::vector< async_data_op_req< T >> &]: ['ops]:  A batch of async_data_op_req<T> structures.



][
A batch of op handles. 


]]
[[``template<class T>
async_io_op read(const async_data_op_req< T > & req)``

] [Schedule an asynchronous data read after a preceding operation. ] [[* const async_data_op_req< T > &]: ['req]:  An async_data_op_req<T> structure.



][
An op handle. 


]]
[[``template<class T>
std::vector< async_io_op > write(const std::vector< async_data_op_req< const T >> & ops)``

] [Schedule a batch of asynchronous data writes after preceding operations. ] [[* const std::vector< async_data_op_req< const T >> &]: ['ops]:  A batch of async_data_op_req<const T> structures.



][
A batch of op handles. 


]]
[[``template<class T>
async_io_op write(const async_data_op_req< const T > & req)``

] [Schedule an asynchronous data write after a preceding operation. ] [[* const async_data_op_req< const T > &]: ['req]:  An async_data_op_req<const T> structure.



][
An op handle. 


]]
[[``std::vector< async_io_op > truncate(const std::vector< async_io_op > & ops, const std::vector< off_t > & sizes)``

] [Schedule a batch of asynchronous file length truncations after preceding operations. ] [[* const std::vector< async_io_op > &]: ['ops]:  A batch of op handles. 

[* const std::vector< off_t > &]: ['sizes]:  A batch of new lengths.



][
A batch of op handles. 


]]
[[``async_io_op truncate(const async_io_op & op, off_t newsize)``

] [Schedule an asynchronous file length truncation after a preceding operation. ] [[* const async_io_op &]: ['op]:  An op handle. 

[* off_t]: ['newsize]:  The new size for the file.



][
An op handle. 


]]
[[``std::pair< std::vector< future< std::pair< std::vector< directory_entry >, bool > > >, std::vector< async_io_op > > enumerate(const std::vector< async_enumerate_op_req > & reqs)``

] [Schedule a batch of asynchronous directory enumerations after a preceding operations. ] [[* const std::vector< async_enumerate_op_req > &]: ['reqs]:  A batch of enumeration requests.



][
A batch of future vectors of directory entries with boolean returning false if done. 


]]
[[``std::pair< future< std::pair< std::vector< directory_entry >, bool > >, async_io_op > enumerate(const async_enumerate_op_req & req)``

] [Schedule an asynchronous directory enumeration after a preceding operation. ] [[* const async_enumerate_op_req &]: ['req]:  An enumeration request.



][
A future vector of directory entries with a boolean returning false if done. 


]]
[[``std::vector< async_io_op > barrier(const std::vector< async_io_op > & ops)``

] [Schedule an asynchronous synchronisation of preceding operations. ] [[* const std::vector< async_io_op > &]: ['ops]:  A batch of op handles.



][
A batch of op handles. 


]]
[[``size_t page_size()``

] [Returns the page size of this architecture which is useful for calculating direct i/o multiples. ] [

][
The page size of this architecture.


]]
[[``void complete_async_op(size_t id, std::shared_ptr< async_io_handle > h, exception_ptr e = exception_ptr())``

] [] [[* size_t]: ['id]:  

[* std::shared_ptr< async_io_handle >]: ['h]:  

[* exception_ptr]: ['e]:  




]]
[[``template<class T>
std::vector< async_io_op > read(const std::vector< async_data_op_req< T >> & ops)``

] [] [[* const std::vector< async_data_op_req< T >> &]: ['ops]:  




]]
[[``template<class T>
std::vector< async_io_op > write(const std::vector< async_data_op_req< T >> & ops)``

] [] [[* const std::vector< async_data_op_req< T >> &]: ['ops]:  




]]
]

[heading Header]
`#include <boost/afio/afio.hpp>`

[/ link afio.reference.functions.async_file_io_dispatcher `async_file_io_dispatcher()`]
[include generated/group_async_file_io_dispatcher_base__completion.qbk]
[include generated/group_async_file_io_dispatcher_base__call.qbk]
[include generated/group_async_file_io_dispatcher_base__filedirops.qbk]
[include generated/group_async_file_io_dispatcher_base__barrier.qbk]
[include generated/group_async_file_io_dispatcher_base__enumerate.qbk]
[include generated/group_async_file_io_dispatcher_base__misc.qbk]

[endsect]

