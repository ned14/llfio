<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LLFIO: llfio_v2_xxx Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LLFIO
   &#160;<span id="projectnumber">v2.00</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacellfio__v2__xxx.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">llfio_v2_xxx Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The LLFIO namespace.  
<a href="namespacellfio__v2__xxx.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacellfio__v2__xxx_1_1algorithm"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx_1_1algorithm.html">algorithm</a></td></tr>
<tr class="memdesc:namespacellfio__v2__xxx_1_1algorithm"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collection of file system based algorithms. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacellfio__v2__xxx_1_1ip"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx_1_1ip.html">ip</a></td></tr>
<tr class="memdesc:namespacellfio__v2__xxx_1_1ip"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inspired by ASIO's <code>ip</code> namespace. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacellfio__v2__xxx_1_1path__discovery"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx_1_1path__discovery.html">path_discovery</a></td></tr>
<tr class="memdesc:namespacellfio__v2__xxx_1_1path__discovery"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains functions used to discover suitable paths for things. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacellfio__v2__xxx_1_1storage__profile"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx_1_1storage__profile.html">storage_profile</a></td></tr>
<tr class="memdesc:namespacellfio__v2__xxx_1_1storage__profile"><td class="mdescLeft">&#160;</td><td class="mdescRight">YAML databaseable empirical testing of a storage's behaviour. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacellfio__v2__xxx_1_1this__thread"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx_1_1this__thread.html">this_thread</a></td></tr>
<tr class="memdesc:namespacellfio__v2__xxx_1_1this__thread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread local settings. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacellfio__v2__xxx_1_1utils"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx_1_1utils.html">utils</a></td></tr>
<tr class="memdesc:namespacellfio__v2__xxx_1_1utils"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility routines often useful when using LLFIO. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1byte__io__handle.html">byte_io_handle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle to something capable of scatter-gather byte i/o.  <a href="classllfio__v2__xxx_1_1byte__io__handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1pollable__handle.html">pollable_handle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle type which can be supplied to <code>poll()</code>.  <a href="classllfio__v2__xxx_1_1pollable__handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1byte__io__multiplexer.html">byte_io_multiplexer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multiplexer of byte-orientated i/o.  <a href="classllfio__v2__xxx_1_1byte__io__multiplexer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1byte__socket__handle.html">byte_socket_handle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle to a byte-orientated socket-like entity.  <a href="classllfio__v2__xxx_1_1byte__socket__handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllfio__v2__xxx_1_1construct_3_01byte__socket__handle_01_4.html">construct&lt; byte_socket_handle &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for <code>byte_socket_handle</code>  <a href="structllfio__v2__xxx_1_1construct_3_01byte__socket__handle_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllfio__v2__xxx_1_1listening__socket__handle__buffer__types__injector.html">listening_socket_handle_buffer_types_injector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Injects buffer types for a particular kind of listening socket read.  <a href="structllfio__v2__xxx_1_1listening__socket__handle__buffer__types__injector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1listening__byte__socket__handle.html">listening_byte_socket_handle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllfio__v2__xxx_1_1construct_3_01listening__byte__socket__handle_01_4.html">construct&lt; listening_byte_socket_handle &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for <code>listening_byte_socket_handle</code>  <a href="structllfio__v2__xxx_1_1construct_3_01listening__byte__socket__handle_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllfio__v2__xxx_1_1path__hasher.html">path_hasher</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllfio__v2__xxx_1_1deadline.html">deadline</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A time deadline in either relative-to-now or absolute (system clock) terms.  <a href="structllfio__v2__xxx_1_1deadline.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllfio__v2__xxx_1_1directory__entry.html">directory_entry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1directory__handle.html">directory_handle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle to a directory which can be enumerated.  <a href="classllfio__v2__xxx_1_1directory__handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllfio__v2__xxx_1_1construct_3_01directory__handle_01_4.html">construct&lt; directory_handle &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for <code>directory_handle</code>  <a href="structllfio__v2__xxx_1_1construct_3_01directory__handle_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1dynamic__thread__pool__group.html">dynamic_thread_pool_group</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Work group within the global dynamic thread pool.  <a href="classllfio__v2__xxx_1_1dynamic__thread__pool__group.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1fast__random__file__handle.html">fast_random_file_handle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle to synthesised, non-cryptographic, pseudo-random data.  <a href="classllfio__v2__xxx_1_1fast__random__file__handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllfio__v2__xxx_1_1construct_3_01fast__random__file__handle_01_4.html">construct&lt; fast_random_file_handle &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for <code>fast_random_file_handle</code>  <a href="structllfio__v2__xxx_1_1construct_3_01fast__random__file__handle_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1file__handle.html">file_handle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle to a regular file or device.  <a href="classllfio__v2__xxx_1_1file__handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllfio__v2__xxx_1_1construct_3_01file__handle_01_4.html">construct&lt; file_handle &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for <code>file_handle</code>  <a href="structllfio__v2__xxx_1_1construct_3_01file__handle_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html">fs_handle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle to something with a device and inode number.  <a href="classllfio__v2__xxx_1_1fs__handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1handle.html">handle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A native_handle_type which is managed by the lifetime of this object instance.  <a href="classllfio__v2__xxx_1_1handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllfio__v2__xxx_1_1construct.html">construct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metaprogramming shim for constructing any <code>handle</code> subclass.  <a href="structllfio__v2__xxx_1_1construct.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1lockable__byte__io__handle.html">lockable_byte_io_handle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle to something capable of scatter-gather i/o and which can exclude other concurrent users. Models <code>SharedMutex</code>, though note that the locks are per-handle, not per-thread.  <a href="classllfio__v2__xxx_1_1lockable__byte__io__handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1unique__file__lock.html">unique_file_lock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RAII locker matching <code>std::unique_lock</code> for <code>lockable_byte_io_handle</code>, but untemplated.  <a href="classllfio__v2__xxx_1_1unique__file__lock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1log__level__guard.html">log_level_guard</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RAII class for temporarily adjusting the log level for the current thread.  <a href="classllfio__v2__xxx_1_1log__level__guard.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1section__handle.html">section_handle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle to a source of mapped memory.  <a href="classllfio__v2__xxx_1_1section__handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllfio__v2__xxx_1_1construct_3_01section__handle_01_4.html">construct&lt; section_handle &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for <code>section_handle</code>  <a href="structllfio__v2__xxx_1_1construct_3_01section__handle_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1map__handle.html">map_handle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle to a memory mapped region of memory, either backed by the system page file or by a section.  <a href="classllfio__v2__xxx_1_1map__handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllfio__v2__xxx_1_1construct_3_01map__handle_01_4.html">construct&lt; map_handle &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for <code>map_handle</code>  <a href="structllfio__v2__xxx_1_1construct_3_01map__handle_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1mapped.html">mapped</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides an owning, typed view of memory mapped from a <code>section_handle</code> or a <code>file_handle</code> suitable for feeding to STL algorithms or the Ranges TS.  <a href="classllfio__v2__xxx_1_1mapped.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1mapped__file__handle.html">mapped_file_handle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A memory mapped regular file or device.  <a href="classllfio__v2__xxx_1_1mapped__file__handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllfio__v2__xxx_1_1construct_3_01mapped__file__handle_01_4.html">construct&lt; mapped_file_handle &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for <code>mapped_file_handle</code>  <a href="structllfio__v2__xxx_1_1construct_3_01mapped__file__handle_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1read__receiver.html">read_receiver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A C++ Receiver of an i/o read for an i/o type of <code>IoHandleType</code>.  <a href="classllfio__v2__xxx_1_1read__receiver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1write__receiver.html">write_receiver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A C++ Receiver of an i/o write for an i/o type of <code>IoHandleType</code>.  <a href="classllfio__v2__xxx_1_1write__receiver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1executor.html">executor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some implementation of a C++ Executor.  <a href="classllfio__v2__xxx_1_1executor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1awaitable__handle.html">awaitable_handle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An awaitable handle which attempts to execute the i/o immediately. If the i/o can complete immediately, no coroutine suspension occurs. Only if the i/o would take a while is coroutine suspension performed.  <a href="classllfio__v2__xxx_1_1awaitable__handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllfio__v2__xxx_1_1native__handle__type.html">native_handle_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A native handle type used for wrapping file descriptors, process ids or HANDLEs. Unmanaged, wrap in a handle object to manage.  <a href="structllfio__v2__xxx_1_1native__handle__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1path__handle.html">path_handle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle to somewhere originally identified by a path on the filing system. Typically used as the lightest weight handle to some location on the filing system which may unpredictably relocate over time. This handle is thus an <em>anchor</em> to a subset island of the filing system, free of any race conditions introduced by third party changes to any part of the path leading to that island.  <a href="classllfio__v2__xxx_1_1path__handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllfio__v2__xxx_1_1construct_3_01path__handle_01_4.html">construct&lt; path_handle &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for <code>path_handle</code>  <a href="structllfio__v2__xxx_1_1construct_3_01path__handle_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1path__view__component.html">path_view_component</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterated part of a <code>path_view</code>.  <a href="classllfio__v2__xxx_1_1path__view__component.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1path__view.html">path_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A borrowed view of a path. A lightweight trivial-type alternative to <code>std::filesystem::path</code>.  <a href="classllfio__v2__xxx_1_1path__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1pipe__handle.html">pipe_handle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle to a named or anonymous pipe.  <a href="classllfio__v2__xxx_1_1pipe__handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllfio__v2__xxx_1_1construct_3_01pipe__handle_01_4.html">construct&lt; pipe_handle &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for <code>pipe_handle</code>  <a href="structllfio__v2__xxx_1_1construct_3_01pipe__handle_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1process__handle.html">process_handle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle to this, or another, process.  <a href="classllfio__v2__xxx_1_1process__handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllfio__v2__xxx_1_1construct_3_01process__handle_01_4.html">construct&lt; process_handle &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for <code>process_handle</code>  <a href="structllfio__v2__xxx_1_1construct_3_01process__handle_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllfio__v2__xxx_1_1stat__t.html">stat_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metadata about a directory entry.  <a href="structllfio__v2__xxx_1_1stat__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllfio__v2__xxx_1_1statfs__t.html">statfs_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metadata about a filing system. Unsupported entries are all bits set.  <a href="structllfio__v2__xxx_1_1statfs__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllfio__v2__xxx_1_1error__info.html">error_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The cause of the failure of an operation in LLFIO.  <a href="structllfio__v2__xxx_1_1error__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1error.html">error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The exception type synthesised and thrown when an <code>llfio::result</code> or <code>llfio::outcome</code> is no-value observed.  <a href="classllfio__v2__xxx_1_1error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1symlink__handle.html">symlink_handle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle to an inode which redirects to a different path.  <a href="classllfio__v2__xxx_1_1symlink__handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllfio__v2__xxx_1_1construct_3_01symlink__handle_01_4.html">construct&lt; symlink_handle &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for <code>symlink_handle</code>  <a href="structllfio__v2__xxx_1_1construct_3_01symlink__handle_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1tls__socket__handle.html">tls_socket_handle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle to a TLS secure socket-like entity.  <a href="classllfio__v2__xxx_1_1tls__socket__handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1listening__tls__socket__handle.html">listening_tls_socket_handle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle to a TLS socket-like entity able to receive incoming connections.  <a href="classllfio__v2__xxx_1_1listening__tls__socket__handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1tls__socket__source.html">tls_socket_source</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A source of <code>tls_socket_handle</code> and <code>listening_tls_socket_handle</code> and possibly a <code>byte_io_multiplexer</code> to multiplex i/o on multiple socket instances at the same time.  <a href="classllfio__v2__xxx_1_1tls__socket__source.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllfio__v2__xxx_1_1tls__socket__source__implementation__information.html">tls_socket_source_implementation_information</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The implementation information returned.  <a href="structllfio__v2__xxx_1_1tls__socket__source__implementation__information.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1tls__socket__source__registry.html">tls_socket_source_registry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A process-wide registry of <code>tls_socket_source</code>.  <a href="classllfio__v2__xxx_1_1tls__socket__source__registry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllfio__v2__xxx_1_1construct_3_01algorithm_1_1cached__parent__handle__adapter_3_01_t_01_4_01_4.html">construct&lt; algorithm::cached_parent_handle_adapter&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for <code>algorithm::::cached_parent_handle_adapter&lt;T&gt;</code>  <a href="structllfio__v2__xxx_1_1construct_3_01algorithm_1_1cached__parent__handle__adapter_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a12c7d894767fdd2e0ebda26d9e6d8be0"><td class="memItemLeft" align="right" valign="top"><a id="a12c7d894767fdd2e0ebda26d9e6d8be0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#a12c7d894767fdd2e0ebda26d9e6d8be0">byte_io_multiplexer_ptr</a> = std::unique_ptr&lt; <a class="el" href="classllfio__v2__xxx_1_1byte__io__multiplexer.html">byte_io_multiplexer</a> &gt;</td></tr>
<tr class="memdesc:a12c7d894767fdd2e0ebda26d9e6d8be0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A unique ptr to an i/o multiplexer implementation. <br /></td></tr>
<tr class="separator:a12c7d894767fdd2e0ebda26d9e6d8be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23358ae319d76dd1149a26b04b17796a"><td class="memTemplParams" colspan="2"><a id="a23358ae319d76dd1149a26b04b17796a"></a>
template&lt;class F , size_t callable_storage_bytes = 32 - sizeof(uintptr_t)&gt; </td></tr>
<tr class="memitem:a23358ae319d76dd1149a26b04b17796a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>function_ptr</b> = QUICKCPPLIB_NAMESPACE::function_ptr::function_ptr&lt; F, callable_storage_bytes &gt;</td></tr>
<tr class="separator:a23358ae319d76dd1149a26b04b17796a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a138a48536b1700db01f10e8a371d0a4f"><td class="memItemLeft" align="right" valign="top"><a id="a138a48536b1700db01f10e8a371d0a4f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>spinlock</b> = QUICKCPPLIB_NAMESPACE::configurable_spinlock::spinlock&lt; uintptr_t &gt;</td></tr>
<tr class="separator:a138a48536b1700db01f10e8a371d0a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cebefd1c4caade9a0abbd9d7a5f89a3"><td class="memItemLeft" align="right" valign="top"><a id="a1cebefd1c4caade9a0abbd9d7a5f89a3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#a1cebefd1c4caade9a0abbd9d7a5f89a3">dynamic_thread_pool_group_ptr</a> = std::unique_ptr&lt; <a class="el" href="classllfio__v2__xxx_1_1dynamic__thread__pool__group.html">dynamic_thread_pool_group</a> &gt;</td></tr>
<tr class="memdesc:a1cebefd1c4caade9a0abbd9d7a5f89a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A unique ptr to a work group within the global dynamic thread pool. <br /></td></tr>
<tr class="separator:a1cebefd1c4caade9a0abbd9d7a5f89a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b7cb2a8ae49464e9a5b708f1d6b4783"><td class="memItemLeft" align="right" valign="top"><a id="a8b7cb2a8ae49464e9a5b708f1d6b4783"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#a8b7cb2a8ae49464e9a5b708f1d6b4783">log_level</a> = QUICKCPPLIB_NAMESPACE::ringbuffer_log::level</td></tr>
<tr class="memdesc:a8b7cb2a8ae49464e9a5b708f1d6b4783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum for the log level. <br /></td></tr>
<tr class="separator:a8b7cb2a8ae49464e9a5b708f1d6b4783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca929614e4fad8cb074325503044845a"><td class="memItemLeft" align="right" valign="top"><a id="aca929614e4fad8cb074325503044845a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#aca929614e4fad8cb074325503044845a">log_implementation_type</a> = QUICKCPPLIB_NAMESPACE::ringbuffer_log::simple_ringbuffer_log&lt; <a class="el" href="group__config.html#ga2e45ede29ed7b2aa06eb19aff2485541">LLFIO_LOGGING_MEMORY</a>, detail::thread_local_log_level_filter &gt;</td></tr>
<tr class="memdesc:aca929614e4fad8cb074325503044845a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the logger. <br /></td></tr>
<tr class="separator:aca929614e4fad8cb074325503044845a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d37600965dbac07498cc811c93bae5"><td class="memTemplParams" colspan="2"><a id="ae5d37600965dbac07498cc811c93bae5"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ae5d37600965dbac07498cc811c93bae5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>result</b> = OUTCOME_V2_NAMESPACE::result&lt; T, <a class="el" href="structllfio__v2__xxx_1_1error__info.html">error_info</a> &gt;</td></tr>
<tr class="separator:ae5d37600965dbac07498cc811c93bae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ddb7c2bee277fc16207b7e8cb05693f"><td class="memTemplParams" colspan="2"><a id="a6ddb7c2bee277fc16207b7e8cb05693f"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a6ddb7c2bee277fc16207b7e8cb05693f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>outcome</b> = OUTCOME_V2_NAMESPACE::outcome&lt; T, <a class="el" href="structllfio__v2__xxx_1_1error__info.html">error_info</a> &gt;</td></tr>
<tr class="separator:a6ddb7c2bee277fc16207b7e8cb05693f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81cc4b6e44e81823d88c0433efd82292"><td class="memItemLeft" align="right" valign="top"><a id="a81cc4b6e44e81823d88c0433efd82292"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#a81cc4b6e44e81823d88c0433efd82292">tls_socket_handle_ptr</a> = std::unique_ptr&lt; <a class="el" href="classllfio__v2__xxx_1_1tls__socket__handle.html">tls_socket_handle</a>, detail::tls_socket_handle_deleter &gt;</td></tr>
<tr class="memdesc:a81cc4b6e44e81823d88c0433efd82292"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to a TLS socket handle returned by a TLS socket source. <br /></td></tr>
<tr class="separator:a81cc4b6e44e81823d88c0433efd82292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b0d8b81e15b9d2aec5dc7194c0e6d22"><td class="memItemLeft" align="right" valign="top"><a id="a1b0d8b81e15b9d2aec5dc7194c0e6d22"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#a1b0d8b81e15b9d2aec5dc7194c0e6d22">listening_tls_socket_handle_ptr</a> = std::unique_ptr&lt; <a class="el" href="classllfio__v2__xxx_1_1listening__tls__socket__handle.html">listening_tls_socket_handle</a>, detail::listening_tls_socket_handle_deleter &gt;</td></tr>
<tr class="memdesc:a1b0d8b81e15b9d2aec5dc7194c0e6d22"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to a listening TLS socket handle returned by a TLS socket source. <br /></td></tr>
<tr class="separator:a1b0d8b81e15b9d2aec5dc7194c0e6d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a51dd6cc5299a316fdcd05c4c7db2dc"><td class="memItemLeft" align="right" valign="top"><a id="a1a51dd6cc5299a316fdcd05c4c7db2dc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#a1a51dd6cc5299a316fdcd05c4c7db2dc">tls_socket_source_ptr</a> = std::unique_ptr&lt; <a class="el" href="classllfio__v2__xxx_1_1tls__socket__source.html">tls_socket_source</a>, detail::tls_socket_source_deleter &gt;</td></tr>
<tr class="memdesc:a1a51dd6cc5299a316fdcd05c4c7db2dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to a TLS socket source. <br /></td></tr>
<tr class="separator:a1a51dd6cc5299a316fdcd05c4c7db2dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a8884e1fc12d34aeaa428539bf6298745"><td class="memItemLeft" align="right" valign="top"><a id="a8884e1fc12d34aeaa428539bf6298745"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#a8884e1fc12d34aeaa428539bf6298745">io_operation_state_type</a> { <br />
&#160;&#160;<b>unknown</b>
, <b>read_initialised</b>
, <b>read_initiated</b>
, <b>read_completed</b>
, <br />
&#160;&#160;<b>read_finished</b>
, <b>write_initialised</b>
, <b>write_initiated</b>
, <b>barrier_initialised</b>
, <br />
&#160;&#160;<b>barrier_initiated</b>
, <b>write_or_barrier_completed</b>
, <b>write_or_barrier_finished</b>
<br />
 }</td></tr>
<tr class="memdesc:a8884e1fc12d34aeaa428539bf6298745"><td class="mdescLeft">&#160;</td><td class="mdescRight">The possible states of the i/o operation. <br /></td></tr>
<tr class="separator:a8884e1fc12d34aeaa428539bf6298745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb445e5dfcc0eb04ce49ac8af0bc89a"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#abcb445e5dfcc0eb04ce49ac8af0bc89a">win32_path_namespace</a> { <a class="el" href="namespacellfio__v2__xxx.html#abcb445e5dfcc0eb04ce49ac8af0bc89aa100b8cad7cf2a56f6df78f171f97a1ec">any</a>
, <a class="el" href="namespacellfio__v2__xxx.html#abcb445e5dfcc0eb04ce49ac8af0bc89aa913f9c49dcb544e2087cee284f4a00b7">device</a>
, <a class="el" href="namespacellfio__v2__xxx.html#abcb445e5dfcc0eb04ce49ac8af0bc89aa0196f6c4f97df3f48d570c23e46501ae">dos</a>
, <a class="el" href="namespacellfio__v2__xxx.html#abcb445e5dfcc0eb04ce49ac8af0bc89aac9d7bcde106cf090f174db82fd3dcba0">guid_volume</a>
 }</td></tr>
<tr class="memdesc:abcb445e5dfcc0eb04ce49ac8af0bc89a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The kinds of win32 path namespace possible.  <a href="namespacellfio__v2__xxx.html#abcb445e5dfcc0eb04ce49ac8af0bc89a">More...</a><br /></td></tr>
<tr class="separator:abcb445e5dfcc0eb04ce49ac8af0bc89a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae79486289ff1386b26d1ce60bb797d33"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#ae79486289ff1386b26d1ce60bb797d33">lock_kind</a> { <a class="el" href="namespacellfio__v2__xxx.html#ae79486289ff1386b26d1ce60bb797d33ad821dbe5ef2db3d805cd0f7eea0ec33f">unlocked</a>
, <a class="el" href="namespacellfio__v2__xxx.html#ae79486289ff1386b26d1ce60bb797d33a9e81e7b963c71363e2fb3eefcfecfc0e">shared</a>
, <a class="el" href="namespacellfio__v2__xxx.html#ae79486289ff1386b26d1ce60bb797d33aa4293995cfbfa9ce60ce71ade2ff75f7">exclusive</a>
 }</td></tr>
<tr class="memdesc:ae79486289ff1386b26d1ce60bb797d33"><td class="mdescLeft">&#160;</td><td class="mdescRight">The kinds of concurrent user exclusion which can be performed.  <a href="namespacellfio__v2__xxx.html#ae79486289ff1386b26d1ce60bb797d33">More...</a><br /></td></tr>
<tr class="separator:ae79486289ff1386b26d1ce60bb797d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6269702375c265b9985fe47df4447c7b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#a6269702375c265b9985fe47df4447c7b">bitfield__tls_algorithm</a> : unsigned { <a class="el" href="namespacellfio__v2__xxx.html#a6269702375c265b9985fe47df4447c7ba334aa63ec1fb6d0ef2267e1ff3c10fd1">default_</a> = (0U)
, <a class="el" href="namespacellfio__v2__xxx.html#a6269702375c265b9985fe47df4447c7baf7da33fdf71e962b32ddd8345e293911">FIPS_140_2</a> = (1U &lt;&lt; 0U)
 }</td></tr>
<tr class="memdesc:a6269702375c265b9985fe47df4447c7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">TLS algorithm categories.  <a href="namespacellfio__v2__xxx.html#a6269702375c265b9985fe47df4447c7b">More...</a><br /></td></tr>
<tr class="separator:a6269702375c265b9985fe47df4447c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a26baf26ed8a75301a92134497cc3ac8a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#a26baf26ed8a75301a92134497cc3ac8a">QUICKCPPLIB_BITFIELD_BEGIN_T</a> (poll_what, uint8_t)</td></tr>
<tr class="memdesc:a26baf26ed8a75301a92134497cc3ac8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">What to poll.  <a href="namespacellfio__v2__xxx.html#a26baf26ed8a75301a92134497cc3ac8a">More...</a><br /></td></tr>
<tr class="separator:a26baf26ed8a75301a92134497cc3ac8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a727d8ebc7f42ff3124d1734a1a1f0563"><td class="memItemLeft" align="right" valign="top">result&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#a727d8ebc7f42ff3124d1734a1a1f0563">poll</a> (span&lt; poll_what &gt; out, span&lt; <a class="el" href="classllfio__v2__xxx_1_1pollable__handle.html">pollable_handle</a> * &gt; handles, span&lt; const poll_what &gt; query, <a class="el" href="structllfio__v2__xxx_1_1deadline.html">deadline</a> d={}) noexcept</td></tr>
<tr class="memdesc:a727d8ebc7f42ff3124d1734a1a1f0563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polls a list of pollable handles awaiting a change in state.  <a href="namespacellfio__v2__xxx.html#a727d8ebc7f42ff3124d1734a1a1f0563">More...</a><br /></td></tr>
<tr class="separator:a727d8ebc7f42ff3124d1734a1a1f0563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbd9eb25fed94bb0bc8fa888b3c26bdf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structllfio__v2__xxx_1_1byte__io__multiplexer_1_1io__result.html">byte_io_handle::io_result</a>&lt; byte_io_handle::buffers_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#acbd9eb25fed94bb0bc8fa888b3c26bdf">read</a> (<a class="el" href="classllfio__v2__xxx_1_1byte__io__handle.html">byte_io_handle</a> &amp;self, <a class="el" href="structllfio__v2__xxx_1_1byte__io__multiplexer_1_1io__request.html">byte_io_handle::io_request</a>&lt; byte_io_handle::buffers_type &gt; reqs, <a class="el" href="structllfio__v2__xxx_1_1deadline.html">deadline</a> d=<a class="el" href="structllfio__v2__xxx_1_1deadline.html">deadline</a>()) noexcept</td></tr>
<tr class="memdesc:acbd9eb25fed94bb0bc8fa888b3c26bdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from the open handle.  <a href="namespacellfio__v2__xxx.html#acbd9eb25fed94bb0bc8fa888b3c26bdf">More...</a><br /></td></tr>
<tr class="separator:acbd9eb25fed94bb0bc8fa888b3c26bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a3e33e0a5f68b867049fd640059b4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structllfio__v2__xxx_1_1byte__io__multiplexer_1_1io__result.html">byte_io_handle::io_result</a>&lt; byte_io_handle::const_buffers_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#a59a3e33e0a5f68b867049fd640059b4d">write</a> (<a class="el" href="classllfio__v2__xxx_1_1byte__io__handle.html">byte_io_handle</a> &amp;self, <a class="el" href="structllfio__v2__xxx_1_1byte__io__multiplexer_1_1io__request.html">byte_io_handle::io_request</a>&lt; byte_io_handle::const_buffers_type &gt; reqs, <a class="el" href="structllfio__v2__xxx_1_1deadline.html">deadline</a> d=<a class="el" href="structllfio__v2__xxx_1_1deadline.html">deadline</a>()) noexcept</td></tr>
<tr class="memdesc:a59a3e33e0a5f68b867049fd640059b4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to the open handle.  <a href="namespacellfio__v2__xxx.html#a59a3e33e0a5f68b867049fd640059b4d">More...</a><br /></td></tr>
<tr class="separator:a59a3e33e0a5f68b867049fd640059b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b4a9d45c9739fbcba139c2cecfb80b"><td class="memItemLeft" align="right" valign="top"><a id="a04b4a9d45c9739fbcba139c2cecfb80b"></a>
<a class="el" href="structllfio__v2__xxx_1_1byte__io__multiplexer_1_1io__result.html">byte_io_handle::io_result</a>&lt; byte_io_handle::size_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#a04b4a9d45c9739fbcba139c2cecfb80b">write</a> (<a class="el" href="classllfio__v2__xxx_1_1byte__io__handle.html">byte_io_handle</a> &amp;self, byte_io_handle::extent_type offset, std::initializer_list&lt; <a class="el" href="structllfio__v2__xxx_1_1byte__io__multiplexer_1_1const__buffer__type.html">byte_io_handle::const_buffer_type</a> &gt; lst, <a class="el" href="structllfio__v2__xxx_1_1deadline.html">deadline</a> d=<a class="el" href="structllfio__v2__xxx_1_1deadline.html">deadline</a>()) noexcept</td></tr>
<tr class="memdesc:a04b4a9d45c9739fbcba139c2cecfb80b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a04b4a9d45c9739fbcba139c2cecfb80b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ec2a3fb2ff559325b89eb7003503d51"><td class="memItemLeft" align="right" valign="top"><a id="a6ec2a3fb2ff559325b89eb7003503d51"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#a6ec2a3fb2ff559325b89eb7003503d51">is_initialised</a> (<a class="el" href="namespacellfio__v2__xxx.html#a8884e1fc12d34aeaa428539bf6298745">io_operation_state_type</a> s) noexcept</td></tr>
<tr class="memdesc:a6ec2a3fb2ff559325b89eb7003503d51"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if the i/o operation state is initialised. <br /></td></tr>
<tr class="separator:a6ec2a3fb2ff559325b89eb7003503d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23a7dfe3b18d247bb4202a638bea1f26"><td class="memItemLeft" align="right" valign="top"><a id="a23a7dfe3b18d247bb4202a638bea1f26"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#a23a7dfe3b18d247bb4202a638bea1f26">is_initiated</a> (<a class="el" href="namespacellfio__v2__xxx.html#a8884e1fc12d34aeaa428539bf6298745">io_operation_state_type</a> s) noexcept</td></tr>
<tr class="memdesc:a23a7dfe3b18d247bb4202a638bea1f26"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if the i/o operation state is initiated. <br /></td></tr>
<tr class="separator:a23a7dfe3b18d247bb4202a638bea1f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d6ac826fcd88e00c7ac63556cef6c70"><td class="memItemLeft" align="right" valign="top"><a id="a7d6ac826fcd88e00c7ac63556cef6c70"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#a7d6ac826fcd88e00c7ac63556cef6c70">is_completed</a> (<a class="el" href="namespacellfio__v2__xxx.html#a8884e1fc12d34aeaa428539bf6298745">io_operation_state_type</a> s) noexcept</td></tr>
<tr class="memdesc:a7d6ac826fcd88e00c7ac63556cef6c70"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if the i/o operation state is completed. <br /></td></tr>
<tr class="separator:a7d6ac826fcd88e00c7ac63556cef6c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f32245d09ba18756513c19b053fd057"><td class="memItemLeft" align="right" valign="top"><a id="a7f32245d09ba18756513c19b053fd057"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#a7f32245d09ba18756513c19b053fd057">is_finished</a> (<a class="el" href="namespacellfio__v2__xxx.html#a8884e1fc12d34aeaa428539bf6298745">io_operation_state_type</a> s) noexcept</td></tr>
<tr class="memdesc:a7f32245d09ba18756513c19b053fd057"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if the i/o operation state is finished. <br /></td></tr>
<tr class="separator:a7f32245d09ba18756513c19b053fd057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a026590e0aff0af0331ec8f8308e56724"><td class="memItemLeft" align="right" valign="top"><a id="a026590e0aff0af0331ec8f8308e56724"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;s, const <a class="el" href="classllfio__v2__xxx_1_1directory__handle.html#ab609ccd931eb25e1699df0444dd87b42">directory_handle::filter</a> &amp;v)</td></tr>
<tr class="separator:a026590e0aff0af0331ec8f8308e56724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5dd820167e77b7caf7ec921f0c6e8c9"><td class="memItemLeft" align="right" valign="top"><a id="ae5dd820167e77b7caf7ec921f0c6e8c9"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;s, const <a class="el" href="structllfio__v2__xxx_1_1directory__handle_1_1buffers__type.html">directory_handle::buffers_type</a> &amp;)</td></tr>
<tr class="separator:ae5dd820167e77b7caf7ec921f0c6e8c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fd0d67b7d28699d16f6a3666a62a5bf"><td class="memItemLeft" align="right" valign="top"><a id="a2fd0d67b7d28699d16f6a3666a62a5bf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#a2fd0d67b7d28699d16f6a3666a62a5bf">swap</a> (<a class="el" href="classllfio__v2__xxx_1_1directory__handle.html">directory_handle</a> &amp;self, <a class="el" href="classllfio__v2__xxx_1_1directory__handle.html">directory_handle</a> &amp;o) noexcept</td></tr>
<tr class="memdesc:a2fd0d67b7d28699d16f6a3666a62a5bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap with another instance. <br /></td></tr>
<tr class="separator:a2fd0d67b7d28699d16f6a3666a62a5bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d112d170c1d485e1120de06eef02375"><td class="memItemLeft" align="right" valign="top">result&lt; <a class="el" href="classllfio__v2__xxx_1_1directory__handle.html">directory_handle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#a3d112d170c1d485e1120de06eef02375">directory</a> (const <a class="el" href="classllfio__v2__xxx_1_1path__handle.html">path_handle</a> &amp;base, <a class="el" href="classllfio__v2__xxx_1_1path__view.html">directory_handle::path_view_type</a> <a class="el" href="namespacellfio__v2__xxx.html#a49f7bb77eb38fbe1280019225b66b78b">path</a>, <a class="el" href="classllfio__v2__xxx_1_1handle.html#aa3930273a2d4cabbac309e0b75701dca">directory_handle::mode</a> _mode=<a class="el" href="classllfio__v2__xxx_1_1handle.html#aa3930273a2d4cabbac309e0b75701dcaaecae13117d6f0584c25a9da6c8f8415e">directory_handle::mode::read</a>, <a class="el" href="classllfio__v2__xxx_1_1handle.html#af0b352d0f273ba6fa70c178b2c2fee42">directory_handle::creation</a> _creation=<a class="el" href="classllfio__v2__xxx_1_1handle.html#af0b352d0f273ba6fa70c178b2c2fee42aa200dcd6176417e93be2405188ae7cc9">directory_handle::creation::open_existing</a>, <a class="el" href="classllfio__v2__xxx_1_1handle.html#aecd3a7db6cee3aec07d32fe6f99e6852">directory_handle::caching</a> _caching=<a class="el" href="classllfio__v2__xxx_1_1handle.html#aecd3a7db6cee3aec07d32fe6f99e6852aa181a603769c1f98ad927e7367c7aa51">directory_handle::caching::all</a>, directory_handle::flag flags=directory_handle::flag::none) noexcept</td></tr>
<tr class="separator:a3d112d170c1d485e1120de06eef02375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba506997f2999cabbe0a7bd2a1d3b6e0"><td class="memItemLeft" align="right" valign="top">result&lt; <a class="el" href="classllfio__v2__xxx_1_1directory__handle.html">directory_handle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#aba506997f2999cabbe0a7bd2a1d3b6e0">uniquely_named_directory</a> (const <a class="el" href="classllfio__v2__xxx_1_1path__handle.html">path_handle</a> &amp;dirpath, <a class="el" href="classllfio__v2__xxx_1_1handle.html#aa3930273a2d4cabbac309e0b75701dca">directory_handle::mode</a> _mode=<a class="el" href="classllfio__v2__xxx_1_1handle.html#aa3930273a2d4cabbac309e0b75701dcaaefb2a684e4afb7d55e6147fbe5a332ee">directory_handle::mode::write</a>, <a class="el" href="classllfio__v2__xxx_1_1handle.html#aecd3a7db6cee3aec07d32fe6f99e6852">directory_handle::caching</a> _caching=<a class="el" href="classllfio__v2__xxx_1_1handle.html#aecd3a7db6cee3aec07d32fe6f99e6852ad5197d93c063a2b1e22d1630a39b7aef">directory_handle::caching::temporary</a>, directory_handle::flag flags=directory_handle::flag::none) noexcept</td></tr>
<tr class="separator:aba506997f2999cabbe0a7bd2a1d3b6e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addbdc12d4993a8ee40c105a02a105a61"><td class="memItemLeft" align="right" valign="top">result&lt; <a class="el" href="classllfio__v2__xxx_1_1directory__handle.html">directory_handle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#addbdc12d4993a8ee40c105a02a105a61">temp_directory</a> (<a class="el" href="classllfio__v2__xxx_1_1path__view.html">directory_handle::path_view_type</a> name=<a class="el" href="classllfio__v2__xxx_1_1path__view.html">directory_handle::path_view_type</a>(), <a class="el" href="classllfio__v2__xxx_1_1handle.html#aa3930273a2d4cabbac309e0b75701dca">directory_handle::mode</a> _mode=<a class="el" href="classllfio__v2__xxx_1_1handle.html#aa3930273a2d4cabbac309e0b75701dcaaefb2a684e4afb7d55e6147fbe5a332ee">directory_handle::mode::write</a>, <a class="el" href="classllfio__v2__xxx_1_1handle.html#af0b352d0f273ba6fa70c178b2c2fee42">directory_handle::creation</a> _creation=<a class="el" href="classllfio__v2__xxx_1_1handle.html#af0b352d0f273ba6fa70c178b2c2fee42a8f0339e854eb5321306a443ce9199e1d">directory_handle::creation::if_needed</a>, <a class="el" href="classllfio__v2__xxx_1_1handle.html#aecd3a7db6cee3aec07d32fe6f99e6852">directory_handle::caching</a> _caching=<a class="el" href="classllfio__v2__xxx_1_1handle.html#aecd3a7db6cee3aec07d32fe6f99e6852aa181a603769c1f98ad927e7367c7aa51">directory_handle::caching::all</a>, directory_handle::flag flags=directory_handle::flag::none) noexcept</td></tr>
<tr class="separator:addbdc12d4993a8ee40c105a02a105a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53c9bba00e56a8e7c7c03e5b1f479ae5"><td class="memItemLeft" align="right" valign="top"><a id="a53c9bba00e56a8e7c7c03e5b1f479ae5"></a>
result&lt; <a class="el" href="namespacellfio__v2__xxx.html#a1cebefd1c4caade9a0abbd9d7a5f89a3">dynamic_thread_pool_group_ptr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#a53c9bba00e56a8e7c7c03e5b1f479ae5">make_dynamic_thread_pool_group</a> () noexcept</td></tr>
<tr class="memdesc:a53c9bba00e56a8e7c7c03e5b1f479ae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new work group within the global dynamic thread pool. <br /></td></tr>
<tr class="separator:a53c9bba00e56a8e7c7c03e5b1f479ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2542466a055a0c024dee2704e9e32519"><td class="memItemLeft" align="right" valign="top"><a id="a2542466a055a0c024dee2704e9e32519"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#a2542466a055a0c024dee2704e9e32519">swap</a> (<a class="el" href="classllfio__v2__xxx_1_1file__handle.html">file_handle</a> &amp;self, <a class="el" href="classllfio__v2__xxx_1_1file__handle.html">file_handle</a> &amp;o) noexcept</td></tr>
<tr class="memdesc:a2542466a055a0c024dee2704e9e32519"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap with another instance. <br /></td></tr>
<tr class="separator:a2542466a055a0c024dee2704e9e32519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af31a062639499a79ef5cc8aed16ba65d"><td class="memItemLeft" align="right" valign="top">result&lt; <a class="el" href="classllfio__v2__xxx_1_1file__handle.html">file_handle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#af31a062639499a79ef5cc8aed16ba65d">file</a> (const <a class="el" href="classllfio__v2__xxx_1_1path__handle.html">path_handle</a> &amp;base, <a class="el" href="classllfio__v2__xxx_1_1path__view.html">file_handle::path_view_type</a> <a class="el" href="namespacellfio__v2__xxx.html#a49f7bb77eb38fbe1280019225b66b78b">path</a>, <a class="el" href="classllfio__v2__xxx_1_1handle.html#aa3930273a2d4cabbac309e0b75701dca">file_handle::mode</a> _mode=<a class="el" href="classllfio__v2__xxx_1_1handle.html#aa3930273a2d4cabbac309e0b75701dcaaecae13117d6f0584c25a9da6c8f8415e">file_handle::mode::read</a>, <a class="el" href="classllfio__v2__xxx_1_1handle.html#af0b352d0f273ba6fa70c178b2c2fee42">file_handle::creation</a> _creation=<a class="el" href="classllfio__v2__xxx_1_1handle.html#af0b352d0f273ba6fa70c178b2c2fee42aa200dcd6176417e93be2405188ae7cc9">file_handle::creation::open_existing</a>, <a class="el" href="classllfio__v2__xxx_1_1handle.html#aecd3a7db6cee3aec07d32fe6f99e6852">file_handle::caching</a> _caching=<a class="el" href="classllfio__v2__xxx_1_1handle.html#aecd3a7db6cee3aec07d32fe6f99e6852aa181a603769c1f98ad927e7367c7aa51">file_handle::caching::all</a>, file_handle::flag flags=file_handle::flag::none) noexcept</td></tr>
<tr class="separator:af31a062639499a79ef5cc8aed16ba65d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d9582bf6887848cd9fc363a282a1c21"><td class="memItemLeft" align="right" valign="top">result&lt; <a class="el" href="classllfio__v2__xxx_1_1file__handle.html">file_handle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#a5d9582bf6887848cd9fc363a282a1c21">uniquely_named_file</a> (const <a class="el" href="classllfio__v2__xxx_1_1path__handle.html">path_handle</a> &amp;dirpath, <a class="el" href="classllfio__v2__xxx_1_1handle.html#aa3930273a2d4cabbac309e0b75701dca">file_handle::mode</a> _mode=<a class="el" href="classllfio__v2__xxx_1_1handle.html#aa3930273a2d4cabbac309e0b75701dcaaefb2a684e4afb7d55e6147fbe5a332ee">file_handle::mode::write</a>, <a class="el" href="classllfio__v2__xxx_1_1handle.html#aecd3a7db6cee3aec07d32fe6f99e6852">file_handle::caching</a> _caching=<a class="el" href="classllfio__v2__xxx_1_1handle.html#aecd3a7db6cee3aec07d32fe6f99e6852ad5197d93c063a2b1e22d1630a39b7aef">file_handle::caching::temporary</a>, file_handle::flag flags=file_handle::flag::none) noexcept</td></tr>
<tr class="separator:a5d9582bf6887848cd9fc363a282a1c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70d9ef3b988a880d171015b754bb7b27"><td class="memItemLeft" align="right" valign="top">result&lt; <a class="el" href="classllfio__v2__xxx_1_1file__handle.html">file_handle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#a70d9ef3b988a880d171015b754bb7b27">temp_file</a> (<a class="el" href="classllfio__v2__xxx_1_1path__view.html">file_handle::path_view_type</a> name=<a class="el" href="classllfio__v2__xxx_1_1path__view.html">file_handle::path_view_type</a>(), <a class="el" href="classllfio__v2__xxx_1_1handle.html#aa3930273a2d4cabbac309e0b75701dca">file_handle::mode</a> _mode=<a class="el" href="classllfio__v2__xxx_1_1handle.html#aa3930273a2d4cabbac309e0b75701dcaaefb2a684e4afb7d55e6147fbe5a332ee">file_handle::mode::write</a>, <a class="el" href="classllfio__v2__xxx_1_1handle.html#af0b352d0f273ba6fa70c178b2c2fee42">file_handle::creation</a> _creation=<a class="el" href="classllfio__v2__xxx_1_1handle.html#af0b352d0f273ba6fa70c178b2c2fee42a8f0339e854eb5321306a443ce9199e1d">file_handle::creation::if_needed</a>, <a class="el" href="classllfio__v2__xxx_1_1handle.html#aecd3a7db6cee3aec07d32fe6f99e6852">file_handle::caching</a> _caching=<a class="el" href="classllfio__v2__xxx_1_1handle.html#aecd3a7db6cee3aec07d32fe6f99e6852ad5197d93c063a2b1e22d1630a39b7aef">file_handle::caching::temporary</a>, file_handle::flag flags=file_handle::flag::unlink_on_first_close) noexcept</td></tr>
<tr class="separator:a70d9ef3b988a880d171015b754bb7b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48668d0e1d2bfebef7c31abf285d9631"><td class="memItemLeft" align="right" valign="top">result&lt; <a class="el" href="classllfio__v2__xxx_1_1file__handle.html">file_handle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#a48668d0e1d2bfebef7c31abf285d9631">temp_inode</a> (const <a class="el" href="classllfio__v2__xxx_1_1path__handle.html">path_handle</a> &amp;dirh=<a class="el" href="namespacellfio__v2__xxx_1_1path__discovery.html#a2dd74ea752f3f511d58ccccdcac7f4fd">path_discovery::storage_backed_temporary_files_directory</a>(), <a class="el" href="classllfio__v2__xxx_1_1handle.html#aa3930273a2d4cabbac309e0b75701dca">file_handle::mode</a> _mode=<a class="el" href="classllfio__v2__xxx_1_1handle.html#aa3930273a2d4cabbac309e0b75701dcaaefb2a684e4afb7d55e6147fbe5a332ee">file_handle::mode::write</a>, <a class="el" href="classllfio__v2__xxx_1_1handle.html#aecd3a7db6cee3aec07d32fe6f99e6852">file_handle::caching</a> _caching=<a class="el" href="classllfio__v2__xxx_1_1handle.html#aecd3a7db6cee3aec07d32fe6f99e6852ad5197d93c063a2b1e22d1630a39b7aef">file_handle::caching::temporary</a>, file_handle::flag flags=file_handle::flag::none) noexcept</td></tr>
<tr class="separator:a48668d0e1d2bfebef7c31abf285d9631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af678f58d20e1f0962ff0744150342683"><td class="memItemLeft" align="right" valign="top"><a id="af678f58d20e1f0962ff0744150342683"></a>
<a class="el" href="structllfio__v2__xxx_1_1byte__io__multiplexer_1_1io__result.html">file_handle::io_result</a>&lt; file_handle::size_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#af678f58d20e1f0962ff0744150342683">read</a> (<a class="el" href="classllfio__v2__xxx_1_1file__handle.html">file_handle</a> &amp;self, file_handle::extent_type offset, std::initializer_list&lt; <a class="el" href="structllfio__v2__xxx_1_1byte__io__multiplexer_1_1buffer__type.html">file_handle::buffer_type</a> &gt; lst, <a class="el" href="structllfio__v2__xxx_1_1deadline.html">deadline</a> d=<a class="el" href="structllfio__v2__xxx_1_1deadline.html">deadline</a>()) noexcept</td></tr>
<tr class="memdesc:af678f58d20e1f0962ff0744150342683"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:af678f58d20e1f0962ff0744150342683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1759f4cee184d433f4446a39ff8bfa02"><td class="memItemLeft" align="right" valign="top">result&lt; file_handle::extent_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#a1759f4cee184d433f4446a39ff8bfa02">maximum_extent</a> (const <a class="el" href="classllfio__v2__xxx_1_1file__handle.html">file_handle</a> &amp;self) noexcept</td></tr>
<tr class="separator:a1759f4cee184d433f4446a39ff8bfa02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ee1bea5a5791ecde266420e00fba81"><td class="memItemLeft" align="right" valign="top">result&lt; file_handle::extent_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#a16ee1bea5a5791ecde266420e00fba81">truncate</a> (<a class="el" href="classllfio__v2__xxx_1_1file__handle.html">file_handle</a> &amp;self, file_handle::extent_type newsize) noexcept</td></tr>
<tr class="separator:a16ee1bea5a5791ecde266420e00fba81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4f1cfcc3469ace25264a09770b0cdef"><td class="memItemLeft" align="right" valign="top"><a id="ad4f1cfcc3469ace25264a09770b0cdef"></a>
result&lt; std::vector&lt; <a class="el" href="structllfio__v2__xxx_1_1file__handle_1_1extent__pair.html">file_handle::extent_pair</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#ad4f1cfcc3469ace25264a09770b0cdef">extents</a> (const <a class="el" href="classllfio__v2__xxx_1_1file__handle.html">file_handle</a> &amp;self) noexcept</td></tr>
<tr class="memdesc:ad4f1cfcc3469ace25264a09770b0cdef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of currently valid extents for this open file. WARNING: racy! <br /></td></tr>
<tr class="separator:ad4f1cfcc3469ace25264a09770b0cdef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0fb15649a46da0d75b5797bfda8dc2e"><td class="memItemLeft" align="right" valign="top">result&lt; file_handle::extent_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#ad0fb15649a46da0d75b5797bfda8dc2e">zero</a> (<a class="el" href="classllfio__v2__xxx_1_1file__handle.html">file_handle</a> &amp;self, file_handle::extent_type offset, file_handle::extent_type bytes, <a class="el" href="structllfio__v2__xxx_1_1deadline.html">deadline</a> d=<a class="el" href="structllfio__v2__xxx_1_1deadline.html">deadline</a>()) noexcept</td></tr>
<tr class="memdesc:ad0fb15649a46da0d75b5797bfda8dc2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Efficiently zero, and possibly deallocate, data on storage.  <a href="namespacellfio__v2__xxx.html#ad0fb15649a46da0d75b5797bfda8dc2e">More...</a><br /></td></tr>
<tr class="separator:ad0fb15649a46da0d75b5797bfda8dc2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab561e45415bf19b8cc6064b6b313d94d"><td class="memItemLeft" align="right" valign="top">result&lt; filesystem::path &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#ab561e45415bf19b8cc6064b6b313d94d">to_win32_path</a> (const <a class="el" href="classllfio__v2__xxx_1_1fs__handle.html">fs_handle</a> &amp;h, <a class="el" href="namespacellfio__v2__xxx.html#abcb445e5dfcc0eb04ce49ac8af0bc89a">win32_path_namespace</a> mapping=<a class="el" href="namespacellfio__v2__xxx.html#abcb445e5dfcc0eb04ce49ac8af0bc89aa100b8cad7cf2a56f6df78f171f97a1ec">win32_path_namespace::any</a>) noexcept</td></tr>
<tr class="memdesc:ab561e45415bf19b8cc6064b6b313d94d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps the current path of <code>h</code> into a form suitable for Win32 APIs. Passes through unmodified on POSIX, so you can use this in portable code.  <a href="namespacellfio__v2__xxx.html#ab561e45415bf19b8cc6064b6b313d94d">More...</a><br /></td></tr>
<tr class="separator:ab561e45415bf19b8cc6064b6b313d94d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64524788da1440c29cae134ae2a53c70"><td class="memTemplParams" colspan="2"><a id="a64524788da1440c29cae134ae2a53c70"></a>
template&lt;class T , typename std::enable_if&lt;(!std::is_base_of&lt; fs_handle, T &gt;::value &amp;&amp;std::is_base_of&lt; handle, T &gt;::value), bool &gt;::type  = true&gt; </td></tr>
<tr class="memitem:a64524788da1440c29cae134ae2a53c70"><td class="memTemplItemLeft" align="right" valign="top">result&lt; filesystem::path &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>to_win32_path</b> (const T &amp;h, <a class="el" href="namespacellfio__v2__xxx.html#abcb445e5dfcc0eb04ce49ac8af0bc89a">win32_path_namespace</a> mapping=<a class="el" href="namespacellfio__v2__xxx.html#abcb445e5dfcc0eb04ce49ac8af0bc89aa100b8cad7cf2a56f6df78f171f97a1ec">win32_path_namespace::any</a>) noexcept</td></tr>
<tr class="separator:a64524788da1440c29cae134ae2a53c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60fa5c64c83ce05c8287c5379d082e49"><td class="memItemLeft" align="right" valign="top">result&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#a60fa5c64c83ce05c8287c5379d082e49">relink</a> (<a class="el" href="classllfio__v2__xxx_1_1fs__handle.html">fs_handle</a> &amp;self, const <a class="el" href="classllfio__v2__xxx_1_1path__handle.html">path_handle</a> &amp;base, <a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#abcd8c8171f4e561620864295e8d5879b">fs_handle::path_view_type</a> <a class="el" href="namespacellfio__v2__xxx.html#a49f7bb77eb38fbe1280019225b66b78b">path</a>, bool atomic_replace=true, <a class="el" href="structllfio__v2__xxx_1_1deadline.html">deadline</a> d=std::chrono::seconds(30)) noexcept</td></tr>
<tr class="separator:a60fa5c64c83ce05c8287c5379d082e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c20b46beeb225aa63ade3dc42e73362"><td class="memItemLeft" align="right" valign="top">result&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#a3c20b46beeb225aa63ade3dc42e73362">unlink</a> (<a class="el" href="classllfio__v2__xxx_1_1fs__handle.html">fs_handle</a> &amp;self, <a class="el" href="structllfio__v2__xxx_1_1deadline.html">deadline</a> d=std::chrono::seconds(30)) noexcept</td></tr>
<tr class="separator:a3c20b46beeb225aa63ade3dc42e73362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33af5701ff0ec4573bd72c7e71a04cf"><td class="memItemLeft" align="right" valign="top"><a id="ae33af5701ff0ec4573bd72c7e71a04cf"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;s, const <a class="el" href="classllfio__v2__xxx_1_1handle.html">handle</a> &amp;v)</td></tr>
<tr class="separator:ae33af5701ff0ec4573bd72c7e71a04cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a869dd7b04685be755d854dea281f84c6"><td class="memItemLeft" align="right" valign="top"><a id="a869dd7b04685be755d854dea281f84c6"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;s, const <a class="el" href="classllfio__v2__xxx_1_1handle.html#aa3930273a2d4cabbac309e0b75701dca">handle::mode</a> &amp;v)</td></tr>
<tr class="separator:a869dd7b04685be755d854dea281f84c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac28600985804a8c72434b65533c1b84d"><td class="memItemLeft" align="right" valign="top"><a id="ac28600985804a8c72434b65533c1b84d"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;s, const <a class="el" href="classllfio__v2__xxx_1_1handle.html#af0b352d0f273ba6fa70c178b2c2fee42">handle::creation</a> &amp;v)</td></tr>
<tr class="separator:ac28600985804a8c72434b65533c1b84d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4888fb3be6e332367f3ee046f869a8f8"><td class="memItemLeft" align="right" valign="top"><a id="a4888fb3be6e332367f3ee046f869a8f8"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;s, const <a class="el" href="classllfio__v2__xxx_1_1handle.html#aecd3a7db6cee3aec07d32fe6f99e6852">handle::caching</a> &amp;v)</td></tr>
<tr class="separator:a4888fb3be6e332367f3ee046f869a8f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56405b7c7f5ca46e6564ce295a87fc87"><td class="memItemLeft" align="right" valign="top"><a id="a56405b7c7f5ca46e6564ce295a87fc87"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;s, const handle::flag &amp;v)</td></tr>
<tr class="separator:a56405b7c7f5ca46e6564ce295a87fc87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2eeaa1b9280d05b18b7e6d505c289fb"><td class="memItemLeft" align="right" valign="top"><a id="aa2eeaa1b9280d05b18b7e6d505c289fb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#aa2eeaa1b9280d05b18b7e6d505c289fb">swap</a> (<a class="el" href="classllfio__v2__xxx_1_1handle.html">handle</a> &amp;self, <a class="el" href="classllfio__v2__xxx_1_1handle.html">handle</a> &amp;o) noexcept</td></tr>
<tr class="memdesc:aa2eeaa1b9280d05b18b7e6d505c289fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap with another instance. <br /></td></tr>
<tr class="separator:aa2eeaa1b9280d05b18b7e6d505c289fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6109ac3bc59d2b15edcded08060d1b0"><td class="memItemLeft" align="right" valign="top"><a id="af6109ac3bc59d2b15edcded08060d1b0"></a>
result&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#af6109ac3bc59d2b15edcded08060d1b0">close</a> (<a class="el" href="classllfio__v2__xxx_1_1handle.html">handle</a> &amp;self) noexcept</td></tr>
<tr class="memdesc:af6109ac3bc59d2b15edcded08060d1b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Immediately close the native handle type managed by this handle. <br /></td></tr>
<tr class="separator:af6109ac3bc59d2b15edcded08060d1b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af54eb9dc436578bd4f28ba955293986d"><td class="memItemLeft" align="right" valign="top"><a id="af54eb9dc436578bd4f28ba955293986d"></a>
<a class="el" href="namespacellfio__v2__xxx.html#aca929614e4fad8cb074325503044845a">log_implementation_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#af54eb9dc436578bd4f28ba955293986d">log</a> () noexcept</td></tr>
<tr class="memdesc:af54eb9dc436578bd4f28ba955293986d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log used by LLFIO. <br /></td></tr>
<tr class="separator:af54eb9dc436578bd4f28ba955293986d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf60dc6739dc2bd7d890630b1a50d15a"><td class="memItemLeft" align="right" valign="top"><a id="aaf60dc6739dc2bd7d890630b1a50d15a"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;s, const section_handle::flag &amp;v)</td></tr>
<tr class="separator:aaf60dc6739dc2bd7d890630b1a50d15a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a992163d3f408a79ede51325ecfac0d25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structllfio__v2__xxx_1_1byte__io__multiplexer_1_1const__buffer__type.html">byte_io_handle::const_buffer_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#a992163d3f408a79ede51325ecfac0d25">nvram_barrier</a> (<a class="el" href="structllfio__v2__xxx_1_1byte__io__multiplexer_1_1const__buffer__type.html">byte_io_handle::const_buffer_type</a> req, bool evict=false) noexcept</td></tr>
<tr class="separator:a992163d3f408a79ede51325ecfac0d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96135062edc7cb1fa33460ff521498f5"><td class="memTemplParams" colspan="2"><a id="a96135062edc7cb1fa33460ff521498f5"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a96135062edc7cb1fa33460ff521498f5"><td class="memTemplItemLeft" align="right" valign="top">constexpr span&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#a96135062edc7cb1fa33460ff521498f5">in_place_attach</a> (<a class="el" href="classllfio__v2__xxx_1_1map__handle.html">map_handle</a> &amp;mh) noexcept</td></tr>
<tr class="memdesc:a96135062edc7cb1fa33460ff521498f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare <code>map_handle</code> as a suitable source for P1631 <code>attached&lt;T&gt;</code>. <br /></td></tr>
<tr class="separator:a96135062edc7cb1fa33460ff521498f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe725f4e0abd521a7aa319a6d567e44"><td class="memItemLeft" align="right" valign="top"><a id="abfe725f4e0abd521a7aa319a6d567e44"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#abfe725f4e0abd521a7aa319a6d567e44">swap</a> (<a class="el" href="classllfio__v2__xxx_1_1section__handle.html">section_handle</a> &amp;self, <a class="el" href="classllfio__v2__xxx_1_1section__handle.html">section_handle</a> &amp;o) noexcept</td></tr>
<tr class="memdesc:abfe725f4e0abd521a7aa319a6d567e44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap with another instance. <br /></td></tr>
<tr class="separator:abfe725f4e0abd521a7aa319a6d567e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9be77116e7a2d8c029dd066dfa363fb"><td class="memItemLeft" align="right" valign="top">result&lt; <a class="el" href="classllfio__v2__xxx_1_1section__handle.html">section_handle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#ac9be77116e7a2d8c029dd066dfa363fb">section</a> (<a class="el" href="classllfio__v2__xxx_1_1file__handle.html">file_handle</a> &amp;backing, section_handle::extent_type maximum_size, section_handle::flag _flag) noexcept</td></tr>
<tr class="memdesc:ac9be77116e7a2d8c029dd066dfa363fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a memory section backed by a file.  <a href="namespacellfio__v2__xxx.html#ac9be77116e7a2d8c029dd066dfa363fb">More...</a><br /></td></tr>
<tr class="separator:ac9be77116e7a2d8c029dd066dfa363fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d55c0a3b567c7ed05053a94750bb133"><td class="memItemLeft" align="right" valign="top">result&lt; <a class="el" href="classllfio__v2__xxx_1_1section__handle.html">section_handle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#a3d55c0a3b567c7ed05053a94750bb133">section</a> (<a class="el" href="classllfio__v2__xxx_1_1file__handle.html">file_handle</a> &amp;backing, section_handle::extent_type bytes=0) noexcept</td></tr>
<tr class="memdesc:a3d55c0a3b567c7ed05053a94750bb133"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a memory section backed by a file.  <a href="namespacellfio__v2__xxx.html#a3d55c0a3b567c7ed05053a94750bb133">More...</a><br /></td></tr>
<tr class="separator:a3d55c0a3b567c7ed05053a94750bb133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5323ac4d73623d99f92109a5c184e5dd"><td class="memItemLeft" align="right" valign="top">result&lt; <a class="el" href="classllfio__v2__xxx_1_1section__handle.html">section_handle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#a5323ac4d73623d99f92109a5c184e5dd">section</a> (section_handle::extent_type bytes, const <a class="el" href="classllfio__v2__xxx_1_1path__handle.html">path_handle</a> &amp;dirh=<a class="el" href="namespacellfio__v2__xxx_1_1path__discovery.html#a2dd74ea752f3f511d58ccccdcac7f4fd">path_discovery::storage_backed_temporary_files_directory</a>(), section_handle::flag _flag=section_handle::flag::read|section_handle::flag::write) noexcept</td></tr>
<tr class="memdesc:a5323ac4d73623d99f92109a5c184e5dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a memory section backed by an anonymous, managed file.  <a href="namespacellfio__v2__xxx.html#a5323ac4d73623d99f92109a5c184e5dd">More...</a><br /></td></tr>
<tr class="separator:a5323ac4d73623d99f92109a5c184e5dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3676f0dd69f4b54cf7e14e3f86d32b9"><td class="memItemLeft" align="right" valign="top"><a id="aa3676f0dd69f4b54cf7e14e3f86d32b9"></a>
result&lt; section_handle::extent_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#aa3676f0dd69f4b54cf7e14e3f86d32b9">length</a> (const <a class="el" href="classllfio__v2__xxx_1_1section__handle.html">section_handle</a> &amp;self) noexcept</td></tr>
<tr class="memdesc:aa3676f0dd69f4b54cf7e14e3f86d32b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current maximum permitted extent of the memory section. <br /></td></tr>
<tr class="separator:aa3676f0dd69f4b54cf7e14e3f86d32b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6b0c71dfe04ceae64818d4c91d05537"><td class="memItemLeft" align="right" valign="top">result&lt; section_handle::extent_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#aa6b0c71dfe04ceae64818d4c91d05537">truncate</a> (<a class="el" href="classllfio__v2__xxx_1_1section__handle.html">section_handle</a> &amp;self, section_handle::extent_type newsize=0) noexcept</td></tr>
<tr class="separator:aa6b0c71dfe04ceae64818d4c91d05537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28060698d23344a5ece73336a9cf49c2"><td class="memItemLeft" align="right" valign="top"><a id="a28060698d23344a5ece73336a9cf49c2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#a28060698d23344a5ece73336a9cf49c2">swap</a> (<a class="el" href="classllfio__v2__xxx_1_1map__handle.html">map_handle</a> &amp;self, <a class="el" href="classllfio__v2__xxx_1_1map__handle.html">map_handle</a> &amp;o) noexcept</td></tr>
<tr class="memdesc:a28060698d23344a5ece73336a9cf49c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap with another instance. <br /></td></tr>
<tr class="separator:a28060698d23344a5ece73336a9cf49c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30183de3590a31b5ef3b2952f700b110"><td class="memItemLeft" align="right" valign="top"><a id="a30183de3590a31b5ef3b2952f700b110"></a>
result&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#a30183de3590a31b5ef3b2952f700b110">close</a> (<a class="el" href="classllfio__v2__xxx_1_1map__handle.html">map_handle</a> &amp;self) noexcept</td></tr>
<tr class="memdesc:a30183de3590a31b5ef3b2952f700b110"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmap the mapped view. <br /></td></tr>
<tr class="separator:a30183de3590a31b5ef3b2952f700b110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab50d07405d17a8fff4e360fd2612bc6f"><td class="memItemLeft" align="right" valign="top">result&lt; <a class="el" href="classllfio__v2__xxx_1_1map__handle.html">map_handle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#ab50d07405d17a8fff4e360fd2612bc6f">map</a> (map_handle::size_type bytes, bool zeroed=false, section_handle::flag _flag=section_handle::flag::readwrite) noexcept</td></tr>
<tr class="separator:ab50d07405d17a8fff4e360fd2612bc6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9dbbe2fe79758ef87fe2dd1f61d824c"><td class="memItemLeft" align="right" valign="top">result&lt; <a class="el" href="classllfio__v2__xxx_1_1map__handle.html">map_handle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#ab9dbbe2fe79758ef87fe2dd1f61d824c">map</a> (<a class="el" href="classllfio__v2__xxx_1_1section__handle.html">section_handle</a> &amp;<a class="el" href="namespacellfio__v2__xxx.html#ac9be77116e7a2d8c029dd066dfa363fb">section</a>, map_handle::size_type bytes=0, map_handle::extent_type offset=0, section_handle::flag _flag=section_handle::flag::readwrite) noexcept</td></tr>
<tr class="separator:ab9dbbe2fe79758ef87fe2dd1f61d824c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70e68bcf05636966ffefe001b903487e"><td class="memItemLeft" align="right" valign="top"><a id="a70e68bcf05636966ffefe001b903487e"></a>
map_handle::size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#a70e68bcf05636966ffefe001b903487e">length</a> (const <a class="el" href="classllfio__v2__xxx_1_1map__handle.html">map_handle</a> &amp;self) noexcept</td></tr>
<tr class="memdesc:a70e68bcf05636966ffefe001b903487e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the memory map. This is the accessible size, NOT the reservation size. <br /></td></tr>
<tr class="separator:a70e68bcf05636966ffefe001b903487e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8231f6ba00d0d5840b47981ecc148e51"><td class="memItemLeft" align="right" valign="top">result&lt; map_handle::size_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#a8231f6ba00d0d5840b47981ecc148e51">truncate</a> (<a class="el" href="classllfio__v2__xxx_1_1map__handle.html">map_handle</a> &amp;self, map_handle::size_type newsize, bool permit_relocation=false) noexcept</td></tr>
<tr class="separator:a8231f6ba00d0d5840b47981ecc148e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab993693c98cdb52e2d611f8f9e24e4e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structllfio__v2__xxx_1_1byte__io__multiplexer_1_1io__result.html">map_handle::io_result</a>&lt; map_handle::buffers_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#ab993693c98cdb52e2d611f8f9e24e4e2">read</a> (<a class="el" href="classllfio__v2__xxx_1_1map__handle.html">map_handle</a> &amp;self, <a class="el" href="structllfio__v2__xxx_1_1byte__io__multiplexer_1_1io__request.html">map_handle::io_request</a>&lt; map_handle::buffers_type &gt; reqs, <a class="el" href="structllfio__v2__xxx_1_1deadline.html">deadline</a> d=<a class="el" href="structllfio__v2__xxx_1_1deadline.html">deadline</a>()) noexcept</td></tr>
<tr class="memdesc:ab993693c98cdb52e2d611f8f9e24e4e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from the mapped view.  <a href="namespacellfio__v2__xxx.html#ab993693c98cdb52e2d611f8f9e24e4e2">More...</a><br /></td></tr>
<tr class="separator:ab993693c98cdb52e2d611f8f9e24e4e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a681ed7e98ac17e6bb336b9287365141b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structllfio__v2__xxx_1_1byte__io__multiplexer_1_1io__result.html">map_handle::io_result</a>&lt; map_handle::const_buffers_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#a681ed7e98ac17e6bb336b9287365141b">write</a> (<a class="el" href="classllfio__v2__xxx_1_1map__handle.html">map_handle</a> &amp;self, <a class="el" href="structllfio__v2__xxx_1_1byte__io__multiplexer_1_1io__request.html">map_handle::io_request</a>&lt; map_handle::const_buffers_type &gt; reqs, <a class="el" href="structllfio__v2__xxx_1_1deadline.html">deadline</a> d=<a class="el" href="structllfio__v2__xxx_1_1deadline.html">deadline</a>()) noexcept</td></tr>
<tr class="memdesc:a681ed7e98ac17e6bb336b9287365141b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to the mapped view.  <a href="namespacellfio__v2__xxx.html#a681ed7e98ac17e6bb336b9287365141b">More...</a><br /></td></tr>
<tr class="separator:a681ed7e98ac17e6bb336b9287365141b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a933649fdb097431a1b84360b9a5ed5c4"><td class="memTemplParams" colspan="2"><a id="a933649fdb097431a1b84360b9a5ed5c4"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a933649fdb097431a1b84360b9a5ed5c4"><td class="memTemplItemLeft" align="right" valign="top">constexpr span&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#a933649fdb097431a1b84360b9a5ed5c4">in_place_attach</a> (<a class="el" href="classllfio__v2__xxx_1_1mapped__file__handle.html">mapped_file_handle</a> &amp;mfh) noexcept</td></tr>
<tr class="memdesc:a933649fdb097431a1b84360b9a5ed5c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare <code>mapped_file_handle</code> as a suitable source for P1631 <code>attached&lt;T&gt;</code>. <br /></td></tr>
<tr class="separator:a933649fdb097431a1b84360b9a5ed5c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda211a674e09531226be56691136f7c"><td class="memItemLeft" align="right" valign="top"><a id="acda211a674e09531226be56691136f7c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#acda211a674e09531226be56691136f7c">swap</a> (<a class="el" href="classllfio__v2__xxx_1_1mapped__file__handle.html">mapped_file_handle</a> &amp;self, <a class="el" href="classllfio__v2__xxx_1_1mapped__file__handle.html">mapped_file_handle</a> &amp;o) noexcept</td></tr>
<tr class="memdesc:acda211a674e09531226be56691136f7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap with another instance. <br /></td></tr>
<tr class="separator:acda211a674e09531226be56691136f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abddc6cd762be581f04b00837a8a91730"><td class="memItemLeft" align="right" valign="top">result&lt; <a class="el" href="classllfio__v2__xxx_1_1mapped__file__handle.html">mapped_file_handle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#abddc6cd762be581f04b00837a8a91730">mapped_file</a> (mapped_file_handle::size_type reservation, const <a class="el" href="classllfio__v2__xxx_1_1path__handle.html">path_handle</a> &amp;base, <a class="el" href="classllfio__v2__xxx_1_1path__view.html">mapped_file_handle::path_view_type</a> _path, <a class="el" href="classllfio__v2__xxx_1_1handle.html#aa3930273a2d4cabbac309e0b75701dca">mapped_file_handle::mode</a> _mode=<a class="el" href="classllfio__v2__xxx_1_1handle.html#aa3930273a2d4cabbac309e0b75701dcaaecae13117d6f0584c25a9da6c8f8415e">mapped_file_handle::mode::read</a>, <a class="el" href="classllfio__v2__xxx_1_1handle.html#af0b352d0f273ba6fa70c178b2c2fee42">mapped_file_handle::creation</a> _creation=<a class="el" href="classllfio__v2__xxx_1_1handle.html#af0b352d0f273ba6fa70c178b2c2fee42aa200dcd6176417e93be2405188ae7cc9">mapped_file_handle::creation::open_existing</a>, <a class="el" href="classllfio__v2__xxx_1_1handle.html#aecd3a7db6cee3aec07d32fe6f99e6852">mapped_file_handle::caching</a> _caching=<a class="el" href="classllfio__v2__xxx_1_1handle.html#aecd3a7db6cee3aec07d32fe6f99e6852aa181a603769c1f98ad927e7367c7aa51">mapped_file_handle::caching::all</a>, mapped_file_handle::flag flags=mapped_file_handle::flag::none) noexcept</td></tr>
<tr class="separator:abddc6cd762be581f04b00837a8a91730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f0ccde00add2f09579151fd71b8f06d"><td class="memItemLeft" align="right" valign="top"><a id="a1f0ccde00add2f09579151fd71b8f06d"></a>
result&lt; <a class="el" href="classllfio__v2__xxx_1_1mapped__file__handle.html">mapped_file_handle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#a1f0ccde00add2f09579151fd71b8f06d">mapped_file</a> (const <a class="el" href="classllfio__v2__xxx_1_1path__handle.html">path_handle</a> &amp;base, <a class="el" href="classllfio__v2__xxx_1_1path__view.html">mapped_file_handle::path_view_type</a> _path, <a class="el" href="classllfio__v2__xxx_1_1handle.html#aa3930273a2d4cabbac309e0b75701dca">mapped_file_handle::mode</a> _mode=<a class="el" href="classllfio__v2__xxx_1_1handle.html#aa3930273a2d4cabbac309e0b75701dcaaecae13117d6f0584c25a9da6c8f8415e">mapped_file_handle::mode::read</a>, <a class="el" href="classllfio__v2__xxx_1_1handle.html#af0b352d0f273ba6fa70c178b2c2fee42">mapped_file_handle::creation</a> _creation=<a class="el" href="classllfio__v2__xxx_1_1handle.html#af0b352d0f273ba6fa70c178b2c2fee42aa200dcd6176417e93be2405188ae7cc9">mapped_file_handle::creation::open_existing</a>, <a class="el" href="classllfio__v2__xxx_1_1handle.html#aecd3a7db6cee3aec07d32fe6f99e6852">mapped_file_handle::caching</a> _caching=<a class="el" href="classllfio__v2__xxx_1_1handle.html#aecd3a7db6cee3aec07d32fe6f99e6852aa181a603769c1f98ad927e7367c7aa51">mapped_file_handle::caching::all</a>, mapped_file_handle::flag flags=mapped_file_handle::flag::none) noexcept</td></tr>
<tr class="memdesc:a1f0ccde00add2f09579151fd71b8f06d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a1f0ccde00add2f09579151fd71b8f06d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a092f75c4e639c85797120488d486fa38"><td class="memItemLeft" align="right" valign="top">result&lt; <a class="el" href="classllfio__v2__xxx_1_1mapped__file__handle.html">mapped_file_handle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#a092f75c4e639c85797120488d486fa38">mapped_uniquely_named_file</a> (mapped_file_handle::size_type reservation, const <a class="el" href="classllfio__v2__xxx_1_1path__handle.html">path_handle</a> &amp;dirpath, <a class="el" href="classllfio__v2__xxx_1_1handle.html#aa3930273a2d4cabbac309e0b75701dca">mapped_file_handle::mode</a> _mode=<a class="el" href="classllfio__v2__xxx_1_1handle.html#aa3930273a2d4cabbac309e0b75701dcaaefb2a684e4afb7d55e6147fbe5a332ee">mapped_file_handle::mode::write</a>, <a class="el" href="classllfio__v2__xxx_1_1handle.html#aecd3a7db6cee3aec07d32fe6f99e6852">mapped_file_handle::caching</a> _caching=<a class="el" href="classllfio__v2__xxx_1_1handle.html#aecd3a7db6cee3aec07d32fe6f99e6852ad5197d93c063a2b1e22d1630a39b7aef">mapped_file_handle::caching::temporary</a>, mapped_file_handle::flag flags=mapped_file_handle::flag::none) noexcept</td></tr>
<tr class="separator:a092f75c4e639c85797120488d486fa38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb3e8ef0ddff1270b3d78d4178335c7"><td class="memItemLeft" align="right" valign="top">result&lt; <a class="el" href="classllfio__v2__xxx_1_1mapped__file__handle.html">mapped_file_handle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#a3eb3e8ef0ddff1270b3d78d4178335c7">mapped_temp_file</a> (mapped_file_handle::size_type reservation, <a class="el" href="classllfio__v2__xxx_1_1path__view.html">mapped_file_handle::path_view_type</a> name=<a class="el" href="classllfio__v2__xxx_1_1path__view.html">mapped_file_handle::path_view_type</a>(), <a class="el" href="classllfio__v2__xxx_1_1handle.html#aa3930273a2d4cabbac309e0b75701dca">mapped_file_handle::mode</a> _mode=<a class="el" href="classllfio__v2__xxx_1_1handle.html#aa3930273a2d4cabbac309e0b75701dcaaefb2a684e4afb7d55e6147fbe5a332ee">mapped_file_handle::mode::write</a>, <a class="el" href="classllfio__v2__xxx_1_1handle.html#af0b352d0f273ba6fa70c178b2c2fee42">mapped_file_handle::creation</a> _creation=<a class="el" href="classllfio__v2__xxx_1_1handle.html#af0b352d0f273ba6fa70c178b2c2fee42a8f0339e854eb5321306a443ce9199e1d">mapped_file_handle::creation::if_needed</a>, <a class="el" href="classllfio__v2__xxx_1_1handle.html#aecd3a7db6cee3aec07d32fe6f99e6852">mapped_file_handle::caching</a> _caching=<a class="el" href="classllfio__v2__xxx_1_1handle.html#aecd3a7db6cee3aec07d32fe6f99e6852ad5197d93c063a2b1e22d1630a39b7aef">mapped_file_handle::caching::temporary</a>, mapped_file_handle::flag flags=mapped_file_handle::flag::unlink_on_first_close) noexcept</td></tr>
<tr class="separator:a3eb3e8ef0ddff1270b3d78d4178335c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b775591c19686ab10aa812fa3c82917"><td class="memItemLeft" align="right" valign="top">result&lt; <a class="el" href="classllfio__v2__xxx_1_1mapped__file__handle.html">mapped_file_handle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#a3b775591c19686ab10aa812fa3c82917">mapped_temp_inode</a> (mapped_file_handle::size_type reservation=0, const <a class="el" href="classllfio__v2__xxx_1_1path__handle.html">path_handle</a> &amp;dir=<a class="el" href="namespacellfio__v2__xxx_1_1path__discovery.html#a2dd74ea752f3f511d58ccccdcac7f4fd">path_discovery::storage_backed_temporary_files_directory</a>(), <a class="el" href="classllfio__v2__xxx_1_1handle.html#aa3930273a2d4cabbac309e0b75701dca">mapped_file_handle::mode</a> _mode=<a class="el" href="classllfio__v2__xxx_1_1handle.html#aa3930273a2d4cabbac309e0b75701dcaaefb2a684e4afb7d55e6147fbe5a332ee">mapped_file_handle::mode::write</a>, <a class="el" href="classllfio__v2__xxx_1_1handle.html#aecd3a7db6cee3aec07d32fe6f99e6852">mapped_file_handle::caching</a> _caching=<a class="el" href="classllfio__v2__xxx_1_1handle.html#aecd3a7db6cee3aec07d32fe6f99e6852ad5197d93c063a2b1e22d1630a39b7aef">mapped_file_handle::caching::temporary</a>, mapped_file_handle::flag flags=mapped_file_handle::flag::none) noexcept</td></tr>
<tr class="separator:a3b775591c19686ab10aa812fa3c82917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f7bb77eb38fbe1280019225b66b78b"><td class="memItemLeft" align="right" valign="top">result&lt; <a class="el" href="classllfio__v2__xxx_1_1path__handle.html">path_handle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#a49f7bb77eb38fbe1280019225b66b78b">path</a> (const <a class="el" href="classllfio__v2__xxx_1_1path__handle.html">path_handle</a> &amp;base, <a class="el" href="classllfio__v2__xxx_1_1path__handle.html#a6f2c51636f17ae97255106d37ef4187c">path_handle::path_view_type</a> path) noexcept</td></tr>
<tr class="separator:a49f7bb77eb38fbe1280019225b66b78b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b12afdd4c80d69d2530bd40f92427c"><td class="memItemLeft" align="right" valign="top"><a id="ad8b12afdd4c80d69d2530bd40f92427c"></a>
result&lt; <a class="el" href="classllfio__v2__xxx_1_1path__handle.html">path_handle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#ad8b12afdd4c80d69d2530bd40f92427c">path</a> (<a class="el" href="classllfio__v2__xxx_1_1path__handle.html#a6f2c51636f17ae97255106d37ef4187c">path_handle::path_view_type</a> _path) noexcept</td></tr>
<tr class="memdesc:ad8b12afdd4c80d69d2530bd40f92427c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ad8b12afdd4c80d69d2530bd40f92427c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b272f994e955b1219e61920df8ec136"><td class="memItemLeft" align="right" valign="top"><a id="a8b272f994e955b1219e61920df8ec136"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#a8b272f994e955b1219e61920df8ec136">operator==</a> (<a class="el" href="classllfio__v2__xxx_1_1path__view__component.html">path_view_component</a> x, <a class="el" href="classllfio__v2__xxx_1_1path__view__component.html">path_view_component</a> y) noexcept</td></tr>
<tr class="memdesc:a8b272f994e955b1219e61920df8ec136"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares <b>identity</b> equality not equivalence i.e. backing storage type must be identical, and backing bytes must be identical. Use <code>compare()</code> if you want something stronger. <br /></td></tr>
<tr class="separator:a8b272f994e955b1219e61920df8ec136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96d00f83eb1996bcbbb9d3aa62424a51"><td class="memItemLeft" align="right" valign="top"><a id="a96d00f83eb1996bcbbb9d3aa62424a51"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#a96d00f83eb1996bcbbb9d3aa62424a51">operator==</a> (<a class="el" href="classllfio__v2__xxx_1_1path__view.html">path_view</a> x, <a class="el" href="classllfio__v2__xxx_1_1path__view.html">path_view</a> y) noexcept</td></tr>
<tr class="memdesc:a96d00f83eb1996bcbbb9d3aa62424a51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares individual path view components for <b>identity</b> not equivalence. Use <code>compare()</code> if you want something stronger. <br /></td></tr>
<tr class="separator:a96d00f83eb1996bcbbb9d3aa62424a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84c787ed5c98dc08c46bf520746bdbea"><td class="memItemLeft" align="right" valign="top"><a id="a84c787ed5c98dc08c46bf520746bdbea"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#a84c787ed5c98dc08c46bf520746bdbea">operator!=</a> (<a class="el" href="classllfio__v2__xxx_1_1path__view__component.html">path_view_component</a> x, <a class="el" href="classllfio__v2__xxx_1_1path__view__component.html">path_view_component</a> y) noexcept</td></tr>
<tr class="memdesc:a84c787ed5c98dc08c46bf520746bdbea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares <b>identity</b> inequality not disequivalence i.e. backing storage type must be different, or backing bytes must be different. Use <code>compare()</code> if you want something stronger. <br /></td></tr>
<tr class="separator:a84c787ed5c98dc08c46bf520746bdbea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5be5d46e7385e95b82f145b950121f19"><td class="memItemLeft" align="right" valign="top"><a id="a5be5d46e7385e95b82f145b950121f19"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#a5be5d46e7385e95b82f145b950121f19">operator&lt;</a> (<a class="el" href="classllfio__v2__xxx_1_1path__view__component.html">path_view_component</a> x, <a class="el" href="classllfio__v2__xxx_1_1path__view__component.html">path_view_component</a> y) noexcept</td></tr>
<tr class="memdesc:a5be5d46e7385e95b82f145b950121f19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares <b>identity</b> for ordering i.e. backing storage type must be different, or backing bytes must be different. Use <code>compare()</code> if you want something stronger. <br /></td></tr>
<tr class="separator:a5be5d46e7385e95b82f145b950121f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af909fbaabae06c5831b45bc7f506d2dd"><td class="memItemLeft" align="right" valign="top"><a id="af909fbaabae06c5831b45bc7f506d2dd"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#af909fbaabae06c5831b45bc7f506d2dd">operator!=</a> (<a class="el" href="classllfio__v2__xxx_1_1path__view.html">path_view</a> x, <a class="el" href="classllfio__v2__xxx_1_1path__view.html">path_view</a> y) noexcept</td></tr>
<tr class="memdesc:af909fbaabae06c5831b45bc7f506d2dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares individual path view components for non-**identity** not disequivalence. Use <code>compare()</code> if you want something stronger. <br /></td></tr>
<tr class="separator:af909fbaabae06c5831b45bc7f506d2dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416eaa79dca4eeb278223d6da67c7a62"><td class="memItemLeft" align="right" valign="top"><a id="a416eaa79dca4eeb278223d6da67c7a62"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#a416eaa79dca4eeb278223d6da67c7a62">operator&lt;</a> (<a class="el" href="classllfio__v2__xxx_1_1path__view.html">path_view</a> x, <a class="el" href="classllfio__v2__xxx_1_1path__view.html">path_view</a> y) noexcept</td></tr>
<tr class="memdesc:a416eaa79dca4eeb278223d6da67c7a62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares individual path view components for ordering. Use <code>compare()</code> if you want something stronger. <br /></td></tr>
<tr class="separator:a416eaa79dca4eeb278223d6da67c7a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c5682776d23abc150dba405629614ac"><td class="memItemLeft" align="right" valign="top"><a id="a4c5682776d23abc150dba405629614ac"></a>
constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#a4c5682776d23abc150dba405629614ac">hash_value</a> (<a class="el" href="classllfio__v2__xxx_1_1path__view__component.html">path_view_component</a> view) noexcept</td></tr>
<tr class="memdesc:a4c5682776d23abc150dba405629614ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashes a <code>path_view_component</code>. <br /></td></tr>
<tr class="separator:a4c5682776d23abc150dba405629614ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a692613da87074e2ffa2a54e24e0cb083"><td class="memTemplParams" colspan="2"><a id="a692613da87074e2ffa2a54e24e0cb083"></a>
template&lt;class F &gt; </td></tr>
<tr class="memitem:a692613da87074e2ffa2a54e24e0cb083"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#a692613da87074e2ffa2a54e24e0cb083">visit</a> (<a class="el" href="classllfio__v2__xxx_1_1path__view__component.html">path_view_component</a> view, F &amp;&amp;f)</td></tr>
<tr class="memdesc:a692613da87074e2ffa2a54e24e0cb083"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visit the underlying source for a <code>path_view_component</code> (LLFIO backwards compatible overload) <br /></td></tr>
<tr class="separator:a692613da87074e2ffa2a54e24e0cb083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa5367ac3e2a2b27aa547a357fe7e35"><td class="memTemplParams" colspan="2"><a id="acfa5367ac3e2a2b27aa547a357fe7e35"></a>
template&lt;class F &gt; </td></tr>
<tr class="memitem:acfa5367ac3e2a2b27aa547a357fe7e35"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#acfa5367ac3e2a2b27aa547a357fe7e35">visit</a> (F &amp;&amp;f, <a class="el" href="classllfio__v2__xxx_1_1path__view__component.html">path_view_component</a> view)</td></tr>
<tr class="memdesc:acfa5367ac3e2a2b27aa547a357fe7e35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visit the underlying source for a <code>path_view_component</code> (std compatible overload) <br /></td></tr>
<tr class="separator:acfa5367ac3e2a2b27aa547a357fe7e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada4abf0a0e41c43e53dad057607cebbc"><td class="memItemLeft" align="right" valign="top"><a id="ada4abf0a0e41c43e53dad057607cebbc"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;s, const <a class="el" href="classllfio__v2__xxx_1_1path__view__component.html">path_view_component</a> &amp;v)</td></tr>
<tr class="separator:ada4abf0a0e41c43e53dad057607cebbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f5dd1b9b336fb59155347ad29694446"><td class="memItemLeft" align="right" valign="top"><a id="a0f5dd1b9b336fb59155347ad29694446"></a>
constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#a0f5dd1b9b336fb59155347ad29694446">hash_value</a> (<a class="el" href="classllfio__v2__xxx_1_1path__view.html">path_view</a> x) noexcept</td></tr>
<tr class="memdesc:a0f5dd1b9b336fb59155347ad29694446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the combined hash of individual path components. <br /></td></tr>
<tr class="separator:a0f5dd1b9b336fb59155347ad29694446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc0e510433972d78eaa1e7675f5de69a"><td class="memTemplParams" colspan="2"><a id="abc0e510433972d78eaa1e7675f5de69a"></a>
template&lt;class CharT , typename std::enable_if&lt;(path_view_component::is_source_acceptable&lt; CharT &gt;), bool &gt;::type  = true&gt; </td></tr>
<tr class="memitem:abc0e510433972d78eaa1e7675f5de69a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (<a class="el" href="classllfio__v2__xxx_1_1path__view__component.html">path_view_component</a>, const CharT *) noexcept</td></tr>
<tr class="separator:abc0e510433972d78eaa1e7675f5de69a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2400ec2c3145121d06c56e5de29bce0f"><td class="memTemplParams" colspan="2"><a id="a2400ec2c3145121d06c56e5de29bce0f"></a>
template&lt;class CharT , typename std::enable_if&lt;(path_view_component::is_source_acceptable&lt; CharT &gt;), bool &gt;::type  = true&gt; </td></tr>
<tr class="memitem:a2400ec2c3145121d06c56e5de29bce0f"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const CharT *, <a class="el" href="classllfio__v2__xxx_1_1path__view__component.html">path_view_component</a>) noexcept</td></tr>
<tr class="separator:a2400ec2c3145121d06c56e5de29bce0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab3fd6befa4b5ac67053e455abdfb883"><td class="memTemplParams" colspan="2"><a id="aab3fd6befa4b5ac67053e455abdfb883"></a>
template&lt;class CharT , typename std::enable_if&lt;(path_view_component::is_source_acceptable&lt; CharT &gt;), bool &gt;::type  = true&gt; </td></tr>
<tr class="memitem:aab3fd6befa4b5ac67053e455abdfb883"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (<a class="el" href="classllfio__v2__xxx_1_1path__view__component.html">path_view_component</a>, const CharT *) noexcept</td></tr>
<tr class="separator:aab3fd6befa4b5ac67053e455abdfb883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a146e0365707204d85e7ad00c6117dcd2"><td class="memTemplParams" colspan="2"><a id="a146e0365707204d85e7ad00c6117dcd2"></a>
template&lt;class CharT , typename std::enable_if&lt;(path_view_component::is_source_acceptable&lt; CharT &gt;), bool &gt;::type  = true&gt; </td></tr>
<tr class="memitem:a146e0365707204d85e7ad00c6117dcd2"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const CharT *, <a class="el" href="classllfio__v2__xxx_1_1path__view__component.html">path_view_component</a>) noexcept</td></tr>
<tr class="separator:a146e0365707204d85e7ad00c6117dcd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb6098c1b55cd27750bf84277d88146"><td class="memTemplParams" colspan="2"><a id="a5fb6098c1b55cd27750bf84277d88146"></a>
template&lt;class CharT , typename std::enable_if&lt;(path_view_component::is_source_acceptable&lt; CharT &gt;), bool &gt;::type  = true&gt; </td></tr>
<tr class="memitem:a5fb6098c1b55cd27750bf84277d88146"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (<a class="el" href="classllfio__v2__xxx_1_1path__view__component.html">path_view_component</a>, const CharT *) noexcept</td></tr>
<tr class="separator:a5fb6098c1b55cd27750bf84277d88146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2b38bc49e40a0c244467d584965e9b"><td class="memTemplParams" colspan="2"><a id="ace2b38bc49e40a0c244467d584965e9b"></a>
template&lt;class CharT , typename std::enable_if&lt;(path_view_component::is_source_acceptable&lt; CharT &gt;), bool &gt;::type  = true&gt; </td></tr>
<tr class="memitem:ace2b38bc49e40a0c244467d584965e9b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const CharT *, <a class="el" href="classllfio__v2__xxx_1_1path__view__component.html">path_view_component</a>) noexcept</td></tr>
<tr class="separator:ace2b38bc49e40a0c244467d584965e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b193201754cfb194be6fbf4e757f8f"><td class="memTemplParams" colspan="2"><a id="ad1b193201754cfb194be6fbf4e757f8f"></a>
template&lt;class CharT , typename std::enable_if&lt;(path_view::is_source_acceptable&lt; CharT &gt;), bool &gt;::type  = true&gt; </td></tr>
<tr class="memitem:ad1b193201754cfb194be6fbf4e757f8f"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (<a class="el" href="classllfio__v2__xxx_1_1path__view.html">path_view</a>, const CharT *) noexcept</td></tr>
<tr class="separator:ad1b193201754cfb194be6fbf4e757f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c16272e2e608d68033d13998ee65f3"><td class="memTemplParams" colspan="2"><a id="ad0c16272e2e608d68033d13998ee65f3"></a>
template&lt;class CharT , typename std::enable_if&lt;(path_view::is_source_acceptable&lt; CharT &gt;), bool &gt;::type  = true&gt; </td></tr>
<tr class="memitem:ad0c16272e2e608d68033d13998ee65f3"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const CharT *, <a class="el" href="classllfio__v2__xxx_1_1path__view.html">path_view</a>) noexcept</td></tr>
<tr class="separator:ad0c16272e2e608d68033d13998ee65f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e8da411f92d3d1dda738a510f71d3c0"><td class="memTemplParams" colspan="2"><a id="a2e8da411f92d3d1dda738a510f71d3c0"></a>
template&lt;class CharT , typename std::enable_if&lt;(path_view::is_source_acceptable&lt; CharT &gt;), bool &gt;::type  = true&gt; </td></tr>
<tr class="memitem:a2e8da411f92d3d1dda738a510f71d3c0"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (<a class="el" href="classllfio__v2__xxx_1_1path__view.html">path_view</a>, const CharT *) noexcept</td></tr>
<tr class="separator:a2e8da411f92d3d1dda738a510f71d3c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68e303e2cce3d5ac6271129c781b106e"><td class="memTemplParams" colspan="2"><a id="a68e303e2cce3d5ac6271129c781b106e"></a>
template&lt;class CharT , typename std::enable_if&lt;(path_view::is_source_acceptable&lt; CharT &gt;), bool &gt;::type  = true&gt; </td></tr>
<tr class="memitem:a68e303e2cce3d5ac6271129c781b106e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const CharT *, <a class="el" href="classllfio__v2__xxx_1_1path__view.html">path_view</a>) noexcept</td></tr>
<tr class="separator:a68e303e2cce3d5ac6271129c781b106e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a627ae32e5bc74e6fa2097a80d9aeab16"><td class="memItemLeft" align="right" valign="top"><a id="a627ae32e5bc74e6fa2097a80d9aeab16"></a>
filesystem::path &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#a627ae32e5bc74e6fa2097a80d9aeab16">operator+=</a> (filesystem::path &amp;a, <a class="el" href="classllfio__v2__xxx_1_1path__view__component.html">path_view_component</a> b)</td></tr>
<tr class="memdesc:a627ae32e5bc74e6fa2097a80d9aeab16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a path view component to a path. <br /></td></tr>
<tr class="separator:a627ae32e5bc74e6fa2097a80d9aeab16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa689b48f1fe2893f13e689a346a5dd5c"><td class="memItemLeft" align="right" valign="top"><a id="aa689b48f1fe2893f13e689a346a5dd5c"></a>
filesystem::path &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#aa689b48f1fe2893f13e689a346a5dd5c">operator/=</a> (filesystem::path &amp;a, <a class="el" href="classllfio__v2__xxx_1_1path__view__component.html">path_view_component</a> b)</td></tr>
<tr class="memdesc:aa689b48f1fe2893f13e689a346a5dd5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a path view component to a path. <br /></td></tr>
<tr class="separator:aa689b48f1fe2893f13e689a346a5dd5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177b07f74b322e7843ec46f13ffcf032"><td class="memItemLeft" align="right" valign="top"><a id="a177b07f74b322e7843ec46f13ffcf032"></a>
filesystem::path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#a177b07f74b322e7843ec46f13ffcf032">operator/</a> (const filesystem::path &amp;a, <a class="el" href="classllfio__v2__xxx_1_1path__view__component.html">path_view_component</a> b)</td></tr>
<tr class="memdesc:a177b07f74b322e7843ec46f13ffcf032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a path view component to a path. <br /></td></tr>
<tr class="separator:a177b07f74b322e7843ec46f13ffcf032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56f82dddf1ccbd54e467ef1e35adcb54"><td class="memItemLeft" align="right" valign="top"><a id="a56f82dddf1ccbd54e467ef1e35adcb54"></a>
filesystem::path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#a56f82dddf1ccbd54e467ef1e35adcb54">operator/</a> (filesystem::path &amp;&amp;a, <a class="el" href="classllfio__v2__xxx_1_1path__view__component.html">path_view_component</a> b)</td></tr>
<tr class="memdesc:a56f82dddf1ccbd54e467ef1e35adcb54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a path view component to a path. <br /></td></tr>
<tr class="separator:a56f82dddf1ccbd54e467ef1e35adcb54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c9bfdea427fe47469fa7c9286a46049"><td class="memTemplParams" colspan="2"><a id="a1c9bfdea427fe47469fa7c9286a46049"></a>
template&lt;class T , typename std::enable_if&lt;(std::is_same&lt; T, path_view_component &gt;::value||std::is_same&lt; T, path_view &gt;::value), bool &gt;::type  = true&gt; </td></tr>
<tr class="memitem:a1c9bfdea427fe47469fa7c9286a46049"><td class="memTemplItemLeft" align="right" valign="top">filesystem::path&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#a1c9bfdea427fe47469fa7c9286a46049">operator/</a> (T a, <a class="el" href="classllfio__v2__xxx_1_1path__view__component.html">path_view_component</a> b)</td></tr>
<tr class="memdesc:a1c9bfdea427fe47469fa7c9286a46049"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a path view component to a path view component. <br /></td></tr>
<tr class="separator:a1c9bfdea427fe47469fa7c9286a46049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94167268e0b7e7573e4599fd7872ef0f"><td class="memItemLeft" align="right" valign="top"><a id="a94167268e0b7e7573e4599fd7872ef0f"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;s, const process_handle::flag &amp;v)</td></tr>
<tr class="separator:a94167268e0b7e7573e4599fd7872ef0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a209f670f6c6b08da7864aa85401ee124"><td class="memItemLeft" align="right" valign="top"><a id="a209f670f6c6b08da7864aa85401ee124"></a>
std::error_code&#160;</td><td class="memItemRight" valign="bottom"><b>make_error_code</b> (<a class="el" href="structllfio__v2__xxx_1_1error__info.html">error_info</a> ei)</td></tr>
<tr class="separator:a209f670f6c6b08da7864aa85401ee124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a881f9fc4445a910ec7a4ad8a0822a200"><td class="memItemLeft" align="right" valign="top"><a id="a881f9fc4445a910ec7a4ad8a0822a200"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="structllfio__v2__xxx_1_1error__info.html">error_info</a> &amp;a, const <a class="el" href="structllfio__v2__xxx_1_1error__info.html">error_info</a> &amp;b)</td></tr>
<tr class="separator:a881f9fc4445a910ec7a4ad8a0822a200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1585becd24a217998786944a73aeedfe"><td class="memItemLeft" align="right" valign="top"><a id="a1585becd24a217998786944a73aeedfe"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="structllfio__v2__xxx_1_1error__info.html">error_info</a> &amp;a, const <a class="el" href="structllfio__v2__xxx_1_1error__info.html">error_info</a> &amp;b)</td></tr>
<tr class="separator:a1585becd24a217998786944a73aeedfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa0522b6f7fdcc2fc3cc0cf0be743734"><td class="memItemLeft" align="right" valign="top"><a id="afa0522b6f7fdcc2fc3cc0cf0be743734"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OUTCOME_TEMPLATE</b> (class ErrorCondEnum) OUTCOME_TREQUIRES(OUTCOME_TPRED(std</td></tr>
<tr class="separator:afa0522b6f7fdcc2fc3cc0cf0be743734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6956acf495ec0d0ebd366410da875cf4"><td class="memItemLeft" align="right" valign="top"><a id="a6956acf495ec0d0ebd366410da875cf4"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;s, const <a class="el" href="structllfio__v2__xxx_1_1error__info.html">error_info</a> &amp;v)</td></tr>
<tr class="separator:a6956acf495ec0d0ebd366410da875cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81805d3ed72cffc9ac478ea84078c1bb"><td class="memItemLeft" align="right" valign="top"><a id="a81805d3ed72cffc9ac478ea84078c1bb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>outcome_throw_as_system_error_with_payload</b> (const <a class="el" href="structllfio__v2__xxx_1_1error__info.html">error_info</a> &amp;ei)</td></tr>
<tr class="separator:a81805d3ed72cffc9ac478ea84078c1bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a472ee6d1c07555469728846ebba2c9"><td class="memItemLeft" align="right" valign="top"><a id="a0a472ee6d1c07555469728846ebba2c9"></a>
<a class="el" href="structllfio__v2__xxx_1_1error__info.html">error_info</a>&#160;</td><td class="memItemRight" valign="bottom"><b>error_from_exception</b> (std::exception_ptr &amp;&amp;ep=std::current_exception(), std::error_code not_matched=std::make_error_code(std::errc::resource_unavailable_try_again)) noexcept</td></tr>
<tr class="separator:a0a472ee6d1c07555469728846ebba2c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0b071d59b67ebfa3f6a31197cfd61db"><td class="memItemLeft" align="right" valign="top"><a id="ad0b071d59b67ebfa3f6a31197cfd61db"></a>
<a class="el" href="structllfio__v2__xxx_1_1error__info.html">error_info</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#ad0b071d59b67ebfa3f6a31197cfd61db">generic_error</a> (errc c)</td></tr>
<tr class="memdesc:ad0b071d59b67ebfa3f6a31197cfd61db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for constructing an error info from an errc. <br /></td></tr>
<tr class="separator:ad0b071d59b67ebfa3f6a31197cfd61db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ab6481a21bf2c4cf8185919edf0a66"><td class="memItemLeft" align="right" valign="top"><a id="a20ab6481a21bf2c4cf8185919edf0a66"></a>
<a class="el" href="structllfio__v2__xxx_1_1error__info.html">error_info</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#a20ab6481a21bf2c4cf8185919edf0a66">posix_error</a> (int c=errno)</td></tr>
<tr class="memdesc:a20ab6481a21bf2c4cf8185919edf0a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for constructing an error info from a POSIX errno. <br /></td></tr>
<tr class="separator:a20ab6481a21bf2c4cf8185919edf0a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f0de9f074d32381006e42b02a3669e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx.html#a30f0de9f074d32381006e42b02a3669e">QUICKCPPLIB_BITFIELD_BEGIN_T</a> (tls_socket_source_implementation_features, uint32_t)</td></tr>
<tr class="memdesc:a30f0de9f074d32381006e42b02a3669e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Feature bits for TLS socket sources.  <a href="namespacellfio__v2__xxx.html#a30f0de9f074d32381006e42b02a3669e">More...</a><br /></td></tr>
<tr class="separator:a30f0de9f074d32381006e42b02a3669e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a235f3c82f22c7430a8e214c959da2a01"><td class="memItemLeft" align="right" valign="top"><a id="a235f3c82f22c7430a8e214c959da2a01"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;s, const <a class="el" href="structllfio__v2__xxx_1_1tls__socket__source__implementation__information.html">tls_socket_source_implementation_information</a> &amp;v)</td></tr>
<tr class="separator:a235f3c82f22c7430a8e214c959da2a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The LLFIO namespace. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>TODO FIXME Replace in-memory log with memory map file backed log. </dd></dl>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a6269702375c265b9985fe47df4447c7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6269702375c265b9985fe47df4447c7b">&#9670;&nbsp;</a></span>bitfield__tls_algorithm</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacellfio__v2__xxx.html#a6269702375c265b9985fe47df4447c7b">llfio_v2_xxx::bitfield__tls_algorithm</a> : unsigned</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TLS algorithm categories. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6269702375c265b9985fe47df4447c7ba334aa63ec1fb6d0ef2267e1ff3c10fd1"></a>default_&#160;</td><td class="fielddoc"><p>The default set of TLS algorithms offered during handshake is a short list of strong ciphers (typically 128 - 256 bits for the symmetric cipher) to suit embedded and low end devices, ordered by strength-cpuload e.g. ChaCha20 would be chosen preferentially to AES, <b>if</b> the CPUs do not have hardware accelerated AES, and longer key sizes would come before shorter key sizes. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6269702375c265b9985fe47df4447c7baf7da33fdf71e962b32ddd8345e293911"></a>FIPS_140_2&#160;</td><td class="fielddoc"><p>The set of TLS algorithms compliant with the FIPS 140-2 standard. Implementations may refuse to work if this is configured. </p>
</td></tr>
</table>
<div class="fragment"><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;{                                          <span class="comment">//</span><span class="comment"></span></div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;<span class="comment"> /*! The default set of TLS algorithms offered during handshake is a short list</span></div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;<span class="comment"> of strong ciphers (typically 128 - 256 bits for the symmetric cipher)</span></div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;<span class="comment"> to suit embedded and low end devices, ordered by strength-cpuload e.g. ChaCha20</span></div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;<span class="comment"> would be chosen preferentially to AES, **if** the CPUs do not have hardware</span></div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;<span class="comment"> accelerated AES, and longer key sizes would come before shorter key sizes.</span></div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;<span class="comment"> */</span></div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160; <a class="code" href="namespacellfio__v2__xxx.html#a6269702375c265b9985fe47df4447c7ba334aa63ec1fb6d0ef2267e1ff3c10fd1">default_</a> = (0U),<span class="comment"></span></div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;<span class="comment"> /*! The set of TLS algorithms compliant with the FIPS 140-2 standard.</span></div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;<span class="comment"> Implementations may refuse to work if this is configured.</span></div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;<span class="comment"> */</span></div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160; <a class="code" href="namespacellfio__v2__xxx.html#a6269702375c265b9985fe47df4447c7baf7da33fdf71e962b32ddd8345e293911">FIPS_140_2</a> = (1U &lt;&lt; 0U)</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160; </div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;} QUICKCPPLIB_BITFIELD_END(tls_algorithm)</div>
<div class="ttc" id="anamespacellfio__v2__xxx_html_a6269702375c265b9985fe47df4447c7ba334aa63ec1fb6d0ef2267e1ff3c10fd1"><div class="ttname"><a href="namespacellfio__v2__xxx.html#a6269702375c265b9985fe47df4447c7ba334aa63ec1fb6d0ef2267e1ff3c10fd1">llfio_v2_xxx::default_</a></div><div class="ttdeci">@ default_</div><div class="ttdef"><b>Definition:</b> tls_socket_handle.hpp:56</div></div>
<div class="ttc" id="anamespacellfio__v2__xxx_html_a6269702375c265b9985fe47df4447c7baf7da33fdf71e962b32ddd8345e293911"><div class="ttname"><a href="namespacellfio__v2__xxx.html#a6269702375c265b9985fe47df4447c7baf7da33fdf71e962b32ddd8345e293911">llfio_v2_xxx::FIPS_140_2</a></div><div class="ttdeci">@ FIPS_140_2</div><div class="ttdef"><b>Definition:</b> tls_socket_handle.hpp:60</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae79486289ff1386b26d1ce60bb797d33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae79486289ff1386b26d1ce60bb797d33">&#9670;&nbsp;</a></span>lock_kind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacellfio__v2__xxx.html#ae79486289ff1386b26d1ce60bb797d33">llfio_v2_xxx::lock_kind</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The kinds of concurrent user exclusion which can be performed. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae79486289ff1386b26d1ce60bb797d33ad821dbe5ef2db3d805cd0f7eea0ec33f"></a>unlocked&#160;</td><td class="fielddoc"><p>Exclude none. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae79486289ff1386b26d1ce60bb797d33a9e81e7b963c71363e2fb3eefcfecfc0e"></a>shared&#160;</td><td class="fielddoc"><p>Exclude only those requesting an exclusive lock on the same inode. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae79486289ff1386b26d1ce60bb797d33aa4293995cfbfa9ce60ce71ade2ff75f7"></a>exclusive&#160;</td><td class="fielddoc"><p>Exclude those requesting any kind of lock on the same inode. </p>
</td></tr>
</table>
<div class="fragment"><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;{</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;  <a class="code" href="namespacellfio__v2__xxx.html#ae79486289ff1386b26d1ce60bb797d33ad821dbe5ef2db3d805cd0f7eea0ec33f">unlocked</a>,  <span class="comment">//!&lt; Exclude none.</span></div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;  <a class="code" href="namespacellfio__v2__xxx.html#ae79486289ff1386b26d1ce60bb797d33a9e81e7b963c71363e2fb3eefcfecfc0e">shared</a>,    <span class="comment">//!&lt; Exclude only those requesting an exclusive lock on the same inode.</span></div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;  <a class="code" href="namespacellfio__v2__xxx.html#ae79486289ff1386b26d1ce60bb797d33aa4293995cfbfa9ce60ce71ade2ff75f7">exclusive</a>  <span class="comment">//!&lt; Exclude those requesting any kind of lock on the same inode.</span></div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;};</div>
<div class="ttc" id="anamespacellfio__v2__xxx_html_ae79486289ff1386b26d1ce60bb797d33a9e81e7b963c71363e2fb3eefcfecfc0e"><div class="ttname"><a href="namespacellfio__v2__xxx.html#ae79486289ff1386b26d1ce60bb797d33a9e81e7b963c71363e2fb3eefcfecfc0e">llfio_v2_xxx::lock_kind::shared</a></div><div class="ttdeci">@ shared</div><div class="ttdoc">Exclude only those requesting an exclusive lock on the same inode.</div></div>
<div class="ttc" id="anamespacellfio__v2__xxx_html_ae79486289ff1386b26d1ce60bb797d33aa4293995cfbfa9ce60ce71ade2ff75f7"><div class="ttname"><a href="namespacellfio__v2__xxx.html#ae79486289ff1386b26d1ce60bb797d33aa4293995cfbfa9ce60ce71ade2ff75f7">llfio_v2_xxx::lock_kind::exclusive</a></div><div class="ttdeci">@ exclusive</div><div class="ttdoc">Exclude those requesting any kind of lock on the same inode.</div></div>
<div class="ttc" id="anamespacellfio__v2__xxx_html_ae79486289ff1386b26d1ce60bb797d33ad821dbe5ef2db3d805cd0f7eea0ec33f"><div class="ttname"><a href="namespacellfio__v2__xxx.html#ae79486289ff1386b26d1ce60bb797d33ad821dbe5ef2db3d805cd0f7eea0ec33f">llfio_v2_xxx::lock_kind::unlocked</a></div><div class="ttdeci">@ unlocked</div><div class="ttdoc">Exclude none.</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="abcb445e5dfcc0eb04ce49ac8af0bc89a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcb445e5dfcc0eb04ce49ac8af0bc89a">&#9670;&nbsp;</a></span>win32_path_namespace</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacellfio__v2__xxx.html#abcb445e5dfcc0eb04ce49ac8af0bc89a">llfio_v2_xxx::win32_path_namespace</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The kinds of win32 path namespace possible. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="abcb445e5dfcc0eb04ce49ac8af0bc89aa100b8cad7cf2a56f6df78f171f97a1ec"></a>any&#160;</td><td class="fielddoc"><p>Map the input path to a valid win32 path as fast as possible for the input. This is currently <code>guid_volume</code> followed by <code>dos</code>, but may change in the future. </p>
</td></tr>
<tr><td class="fieldname"><a id="abcb445e5dfcc0eb04ce49ac8af0bc89aa913f9c49dcb544e2087cee284f4a00b7"></a>device&#160;</td><td class="fielddoc"><p>Map <code>\!!\Device\...</code> form input paths to <code>\\.\...</code> for which it is <em>usually</em> the case there is a mapping, which results in a valid Win32 path, but which legacy code bases may not accept. This efficiently covers the vast majority of what can be returned by <code>handle::current_path()</code> on Windows, but if the input path cannot be mapped, a failure is returned. </p>
</td></tr>
<tr><td class="fieldname"><a id="abcb445e5dfcc0eb04ce49ac8af0bc89aa0196f6c4f97df3f48d570c23e46501ae"></a>dos&#160;</td><td class="fielddoc"><p>Map the input path to a DOS drive letter prefix, possibly with <code>\\?\</code> prefix to opt out of strict DOS path parsing if the mapped DOS path is incompatible with traditional DOS (e.g. it contains one of the forbidden character sequences such as <code>CON</code>, or it exceeds 260 codepoints, and so on). Well written software will correctly handle <code>\\?\</code> prefixes, but if the code you are handing the path to is particularly legacy, you ought to ensure that the prefix is not present.</p>
<dl class="section warning"><dt>Warning</dt><dd>There is not a one-one mapping between NT kernel paths (which is what LLFIO returns from <code>handle::current_path()</code>) and DOS style paths, so what you get may be surprising. It is also possible that there is no mapping at all, in which case a failure is returned. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="abcb445e5dfcc0eb04ce49ac8af0bc89aac9d7bcde106cf090f174db82fd3dcba0"></a>guid_volume&#160;</td><td class="fielddoc"><p>Map the input path replacing the volume as a GUID, such that say an input path of <code>C:\foo\bar</code> might be mapped to <code>\\?\Volume{9f9bd10e-9003-4da5-b146-70584e30854a}\foo\bar</code>. This is a valid Win32 path, but legacy code bases may not accept it. This eliminates problems with drive letters vanishing or being ambiguous, and unlike with <code>dos</code>, there is a guaranteed one-one mapping between NT kernel paths and <code>guid_volume</code> paths. The mapped path is NOT checked for equivalence to the input file. </p>
</td></tr>
</table>
<div class="fragment"><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;{<span class="comment"></span></div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;<span class="comment">  /*! Map the input path to a valid win32 path as fast as possible for the input.</span></div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;<span class="comment">  This is currently `guid_volume` followed by `dos`, but may change in the future.</span></div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;<span class="comment">  */</span></div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;  <a class="code" href="namespacellfio__v2__xxx_1_1ip.html#aa209c529f55f8c8a242080d55c66a4a9a100b8cad7cf2a56f6df78f171f97a1ec">any</a>,<span class="comment"></span></div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;<span class="comment">  /*! Map `\!!\Device\...` form input paths to `\\.\...` for which it is _usually_</span></div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;<span class="comment">  the case there is a mapping, which results in a valid Win32 path, but which</span></div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;<span class="comment">  legacy code bases may not accept. This efficiently covers the vast majority of</span></div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;<span class="comment">  what can be returned by `handle::current_path()` on Windows, but if the input</span></div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;<span class="comment">  path cannot be mapped, a failure is returned.</span></div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;<span class="comment">  */</span></div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;  device,<span class="comment"></span></div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;<span class="comment">  /*! Map the input path to a DOS drive letter prefix, possibly with `\\?\` prefix</span></div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;<span class="comment">  to opt out of strict DOS path parsing if the mapped DOS path is incompatible with</span></div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;<span class="comment">  traditional DOS (e.g. it contains one of the forbidden character sequences such</span></div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;<span class="comment">  as `CON`, or it exceeds 260 codepoints, and so on). Well written software will</span></div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;<span class="comment">  correctly handle `\\?\` prefixes, but if the code you are handing the path to is</span></div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;<span class="comment">  particularly legacy, you ought to ensure that the prefix is not present.</span></div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;<span class="comment"></span> </div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;<span class="comment">  \warning There is not a one-one mapping between NT kernel paths (which is what</span></div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;<span class="comment">  LLFIO returns from `handle::current_path()`) and DOS style paths, so what you get</span></div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;<span class="comment">  may be surprising. It is also possible that there is no mapping at all, in which</span></div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;<span class="comment">  case a failure is returned.</span></div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;<span class="comment">  */</span></div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;  <a class="code" href="namespacellfio__v2__xxx.html#abcb445e5dfcc0eb04ce49ac8af0bc89aa0196f6c4f97df3f48d570c23e46501ae">dos</a>,<span class="comment"></span></div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;<span class="comment">  /*! Map the input path replacing the volume as a GUID, such that say an input path</span></div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;<span class="comment">  of `C:\foo\bar` might be mapped to `\\?\Volume{9f9bd10e-9003-4da5-b146-70584e30854a}\foo\bar`.</span></div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;<span class="comment">  This is a valid Win32 path, but legacy code bases may not accept it. This eliminates</span></div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;<span class="comment">  problems with drive letters vanishing or being ambiguous, and unlike with `dos`,</span></div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;<span class="comment">  there is a guaranteed one-one mapping between NT kernel paths and `guid_volume` paths.</span></div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;<span class="comment">  The mapped path is NOT checked for equivalence to the input file.</span></div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;<span class="comment">  */</span></div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;  <a class="code" href="namespacellfio__v2__xxx.html#abcb445e5dfcc0eb04ce49ac8af0bc89aac9d7bcde106cf090f174db82fd3dcba0">guid_volume</a></div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;<span class="preprocessor">#if 0</span><span class="comment"></span></div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;<span class="comment">  /*! Map the input path replacing the the whole path as a GUID, such that say an input</span></div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;<span class="comment">  path of `C:\foo\bar` might be mapped to `\\?\Volume{9f9bd10e-9003-4da5-b146-70584e30854a}\{5a13b46c-44b9-40f3-9303-23cf7d918708}`.</span></div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;<span class="comment">  This is a valid Win32 path, but legacy code bases may not accept it. This eliminates</span></div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;<span class="comment">  problems with long paths or if the file could be renamed concurrently. Note this may</span></div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;<span class="comment">  cause the creation of a GUID for the file on some filesystems (NTFS). The mapped path</span></div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;<span class="comment">  is NOT checked for equivalence to the input file.</span></div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;<span class="comment">  */</span></div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;  guid_all</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160; </div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;<span class="comment">/*</span></div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;<span class="comment">- `win32_path_namespace::guid_all` does the same as `guid_volume`, but additionally</span></div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;<span class="comment">asks Windows for the GUID for the file upon the volume, creating one if one</span></div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;<span class="comment">doesn&#39;t exist if necessary. The path returned consists of two GUIDs, and is a</span></div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;<span class="comment">perfectly valid Win32 path which most Win32 APIs will accept.</span></div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;<span class="comment">*/</span></div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;};</div>
<div class="ttc" id="anamespacellfio__v2__xxx_1_1ip_html_aa209c529f55f8c8a242080d55c66a4a9a100b8cad7cf2a56f6df78f171f97a1ec"><div class="ttname"><a href="namespacellfio__v2__xxx_1_1ip.html#aa209c529f55f8c8a242080d55c66a4a9a100b8cad7cf2a56f6df78f171f97a1ec">llfio_v2_xxx::ip::family::any</a></div><div class="ttdeci">@ any</div><div class="ttdoc">Either v4 or v6.</div></div>
<div class="ttc" id="anamespacellfio__v2__xxx_html_abcb445e5dfcc0eb04ce49ac8af0bc89aa0196f6c4f97df3f48d570c23e46501ae"><div class="ttname"><a href="namespacellfio__v2__xxx.html#abcb445e5dfcc0eb04ce49ac8af0bc89aa0196f6c4f97df3f48d570c23e46501ae">llfio_v2_xxx::win32_path_namespace::dos</a></div><div class="ttdeci">@ dos</div></div>
<div class="ttc" id="anamespacellfio__v2__xxx_html_abcb445e5dfcc0eb04ce49ac8af0bc89aac9d7bcde106cf090f174db82fd3dcba0"><div class="ttname"><a href="namespacellfio__v2__xxx.html#abcb445e5dfcc0eb04ce49ac8af0bc89aac9d7bcde106cf090f174db82fd3dcba0">llfio_v2_xxx::win32_path_namespace::guid_volume</a></div><div class="ttdeci">@ guid_volume</div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a3d112d170c1d485e1120de06eef02375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d112d170c1d485e1120de06eef02375">&#9670;&nbsp;</a></span>directory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result&lt;<a class="el" href="classllfio__v2__xxx_1_1directory__handle.html">directory_handle</a>&gt; llfio_v2_xxx::directory </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllfio__v2__xxx_1_1path__handle.html">path_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1path__view.html">directory_handle::path_view_type</a>&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1handle.html#aa3930273a2d4cabbac309e0b75701dca">directory_handle::mode</a>&#160;</td>
          <td class="paramname"><em>_mode</em> = <code><a class="el" href="classllfio__v2__xxx_1_1handle.html#aa3930273a2d4cabbac309e0b75701dcaaecae13117d6f0584c25a9da6c8f8415e">directory_handle::mode::read</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1handle.html#af0b352d0f273ba6fa70c178b2c2fee42">directory_handle::creation</a>&#160;</td>
          <td class="paramname"><em>_creation</em> = <code><a class="el" href="classllfio__v2__xxx_1_1handle.html#af0b352d0f273ba6fa70c178b2c2fee42aa200dcd6176417e93be2405188ae7cc9">directory_handle::creation::open_existing</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1handle.html#aecd3a7db6cee3aec07d32fe6f99e6852">directory_handle::caching</a>&#160;</td>
          <td class="paramname"><em>_caching</em> = <code><a class="el" href="classllfio__v2__xxx_1_1handle.html#aecd3a7db6cee3aec07d32fe6f99e6852aa181a603769c1f98ad927e7367c7aa51">directory_handle::caching::all</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">directory_handle::flag&#160;</td>
          <td class="paramname"><em>flags</em> = <code>directory_handle::flag::none</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a handle opening access to a directory on path.</p>
<dl class="section user"><dt>Errors returnable\n Any of the values POSIX open() or CreateFile() can return.</dt><dd></dd></dl>
<div class="fragment"><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;{</div>
<div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="namespacellfio__v2__xxx.html#a3d112d170c1d485e1120de06eef02375">directory_handle::directory</a>(std::forward&lt;decltype(base)&gt;(base), std::forward&lt;decltype(<a class="code" href="namespacellfio__v2__xxx.html#a49f7bb77eb38fbe1280019225b66b78b">path</a>)&gt;(<a class="code" href="namespacellfio__v2__xxx.html#a49f7bb77eb38fbe1280019225b66b78b">path</a>), std::forward&lt;decltype(_mode)&gt;(_mode),</div>
<div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;                                     std::forward&lt;decltype(_creation)&gt;(_creation), std::forward&lt;decltype(_caching)&gt;(_caching),</div>
<div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;                                     std::forward&lt;decltype(flags)&gt;(flags));</div>
<div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;}</div>
<div class="ttc" id="anamespacellfio__v2__xxx_html_a3d112d170c1d485e1120de06eef02375"><div class="ttname"><a href="namespacellfio__v2__xxx.html#a3d112d170c1d485e1120de06eef02375">llfio_v2_xxx::directory</a></div><div class="ttdeci">result&lt; directory_handle &gt; directory(const path_handle &amp;base, directory_handle::path_view_type path, directory_handle::mode _mode=directory_handle::mode::read, directory_handle::creation _creation=directory_handle::creation::open_existing, directory_handle::caching _caching=directory_handle::caching::all, directory_handle::flag flags=directory_handle::flag::none) noexcept</div><div class="ttdef"><b>Definition:</b> directory_handle.hpp:464</div></div>
<div class="ttc" id="anamespacellfio__v2__xxx_html_a49f7bb77eb38fbe1280019225b66b78b"><div class="ttname"><a href="namespacellfio__v2__xxx.html#a49f7bb77eb38fbe1280019225b66b78b">llfio_v2_xxx::path</a></div><div class="ttdeci">result&lt; path_handle &gt; path(const path_handle &amp;base, path_handle::path_view_type path) noexcept</div><div class="ttdef"><b>Definition:</b> path_handle.hpp:171</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="af31a062639499a79ef5cc8aed16ba65d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af31a062639499a79ef5cc8aed16ba65d">&#9670;&nbsp;</a></span>file()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result&lt;<a class="el" href="classllfio__v2__xxx_1_1file__handle.html">file_handle</a>&gt; llfio_v2_xxx::file </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllfio__v2__xxx_1_1path__handle.html">path_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1path__view.html">file_handle::path_view_type</a>&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1handle.html#aa3930273a2d4cabbac309e0b75701dca">file_handle::mode</a>&#160;</td>
          <td class="paramname"><em>_mode</em> = <code><a class="el" href="classllfio__v2__xxx_1_1handle.html#aa3930273a2d4cabbac309e0b75701dcaaecae13117d6f0584c25a9da6c8f8415e">file_handle::mode::read</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1handle.html#af0b352d0f273ba6fa70c178b2c2fee42">file_handle::creation</a>&#160;</td>
          <td class="paramname"><em>_creation</em> = <code><a class="el" href="classllfio__v2__xxx_1_1handle.html#af0b352d0f273ba6fa70c178b2c2fee42aa200dcd6176417e93be2405188ae7cc9">file_handle::creation::open_existing</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1handle.html#aecd3a7db6cee3aec07d32fe6f99e6852">file_handle::caching</a>&#160;</td>
          <td class="paramname"><em>_caching</em> = <code><a class="el" href="classllfio__v2__xxx_1_1handle.html#aecd3a7db6cee3aec07d32fe6f99e6852aa181a603769c1f98ad927e7367c7aa51">file_handle::caching::all</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">file_handle::flag&#160;</td>
          <td class="paramname"><em>flags</em> = <code>file_handle::flag::none</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a file handle opening access to a file on path </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Handle to a base location on the filing system. Pass <code>{}</code> to indicate that path will be absolute. </td></tr>
    <tr><td class="paramname">path</td><td>The path relative to base to open. </td></tr>
    <tr><td class="paramname">_mode</td><td>How to open the file. </td></tr>
    <tr><td class="paramname">_creation</td><td>How to create the file. </td></tr>
    <tr><td class="paramname">_caching</td><td>How to ask the kernel to cache the file. </td></tr>
    <tr><td class="paramname">flags</td><td>Any additional custom behaviours.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Errors returnable\n Any of the values POSIX open() or CreateFile() can return.</dt><dd></dd></dl>
<div class="fragment"><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;{</div>
<div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="namespacellfio__v2__xxx.html#af31a062639499a79ef5cc8aed16ba65d">file_handle::file</a>(std::forward&lt;decltype(base)&gt;(base), std::forward&lt;decltype(<a class="code" href="namespacellfio__v2__xxx.html#a49f7bb77eb38fbe1280019225b66b78b">path</a>)&gt;(<a class="code" href="namespacellfio__v2__xxx.html#a49f7bb77eb38fbe1280019225b66b78b">path</a>), std::forward&lt;decltype(_mode)&gt;(_mode),</div>
<div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;                           std::forward&lt;decltype(_creation)&gt;(_creation), std::forward&lt;decltype(_caching)&gt;(_caching), std::forward&lt;decltype(flags)&gt;(flags));</div>
<div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;}</div>
<div class="ttc" id="anamespacellfio__v2__xxx_html_af31a062639499a79ef5cc8aed16ba65d"><div class="ttname"><a href="namespacellfio__v2__xxx.html#af31a062639499a79ef5cc8aed16ba65d">llfio_v2_xxx::file</a></div><div class="ttdeci">result&lt; file_handle &gt; file(const path_handle &amp;base, file_handle::path_view_type path, file_handle::mode _mode=file_handle::mode::read, file_handle::creation _creation=file_handle::creation::open_existing, file_handle::caching _caching=file_handle::caching::all, file_handle::flag flags=file_handle::flag::none) noexcept</div><div class="ttdef"><b>Definition:</b> file_handle.hpp:434</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ab50d07405d17a8fff4e360fd2612bc6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab50d07405d17a8fff4e360fd2612bc6f">&#9670;&nbsp;</a></span>map() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result&lt;<a class="el" href="classllfio__v2__xxx_1_1map__handle.html">map_handle</a>&gt; llfio_v2_xxx::map </td>
          <td>(</td>
          <td class="paramtype">map_handle::size_type&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>zeroed</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">section_handle::flag&#160;</td>
          <td class="paramname"><em>_flag</em> = <code>section_handle::flag::readwrite</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create new memory and map it into view. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>How many bytes to create and map. Typically will be rounded up to a multiple of the page size (see <code>page_size()</code>) on POSIX, 64Kb on Windows. </td></tr>
    <tr><td class="paramname">zeroed</td><td>Set to true if only all bits zeroed memory is wanted. </td></tr>
    <tr><td class="paramname">_flag</td><td>The permissions with which to map the view. <code>flag::none</code> can be useful for reserving virtual address space without committing system resources, use commit() to later change availability of memory.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>On Microsoft Windows this constructor uses the faster VirtualAlloc() which creates less versatile page backed memory. If you want anonymous memory allocated from a paging file backed section instead, create a page file backed section and then a mapped view from that using the other constructor. This makes available all those very useful VM tricks Windows can do with section mapped memory which VirtualAlloc() memory cannot do.</dd></dl>
<dl class="section user"><dt>Errors returnable\n Any of the values POSIX mmap() or VirtualAlloc() can return.</dt><dd></dd></dl>
<div class="fragment"><div class="line"><a name="l01110"></a><span class="lineno"> 1110</span>&#160;{</div>
<div class="line"><a name="l01111"></a><span class="lineno"> 1111</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="namespacellfio__v2__xxx.html#ab9dbbe2fe79758ef87fe2dd1f61d824c">map_handle::map</a>(std::forward&lt;decltype(bytes)&gt;(bytes), zeroed, std::forward&lt;decltype(_flag)&gt;(_flag));</div>
<div class="line"><a name="l01112"></a><span class="lineno"> 1112</span>&#160;}</div>
<div class="ttc" id="anamespacellfio__v2__xxx_html_ab9dbbe2fe79758ef87fe2dd1f61d824c"><div class="ttname"><a href="namespacellfio__v2__xxx.html#ab9dbbe2fe79758ef87fe2dd1f61d824c">llfio_v2_xxx::map</a></div><div class="ttdeci">result&lt; map_handle &gt; map(section_handle &amp;section, map_handle::size_type bytes=0, map_handle::extent_type offset=0, section_handle::flag _flag=section_handle::flag::readwrite) noexcept</div><div class="ttdef"><b>Definition:</b> map_handle.hpp:1123</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ab9dbbe2fe79758ef87fe2dd1f61d824c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9dbbe2fe79758ef87fe2dd1f61d824c">&#9670;&nbsp;</a></span>map() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result&lt;<a class="el" href="classllfio__v2__xxx_1_1map__handle.html">map_handle</a>&gt; llfio_v2_xxx::map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1section__handle.html">section_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">map_handle::size_type&#160;</td>
          <td class="paramname"><em>bytes</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">map_handle::extent_type&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">section_handle::flag&#160;</td>
          <td class="paramname"><em>_flag</em> = <code>section_handle::flag::readwrite</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a memory mapped view of a backing storage, optionally reserving additional address space for later growth. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">section</td><td>A memory section handle specifying the backing storage to use. </td></tr>
    <tr><td class="paramname">bytes</td><td>How many bytes to reserve (0 = the size of the section). Rounded up to nearest 64Kb on Windows. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset into the backing storage to map from </td></tr>
    <tr><td class="paramname">_flag</td><td>The permissions with which to map the view which are constrained by the permissions of the memory section. <code>flag::none</code> can be useful for reserving virtual address space without committing system resources, use commit() to later change availability of memory.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Errors returnable\n Any of the values POSIX mmap() or NtMapViewOfSection() can return.</dt><dd></dd></dl>
<div class="fragment"><div class="line"><a name="l01125"></a><span class="lineno"> 1125</span>&#160;{</div>
<div class="line"><a name="l01126"></a><span class="lineno"> 1126</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="namespacellfio__v2__xxx.html#ab9dbbe2fe79758ef87fe2dd1f61d824c">map_handle::map</a>(std::forward&lt;decltype(<a class="code" href="namespacellfio__v2__xxx.html#a5323ac4d73623d99f92109a5c184e5dd">section</a>)&gt;(<a class="code" href="namespacellfio__v2__xxx.html#a5323ac4d73623d99f92109a5c184e5dd">section</a>), std::forward&lt;decltype(bytes)&gt;(bytes), std::forward&lt;decltype(offset)&gt;(offset),</div>
<div class="line"><a name="l01127"></a><span class="lineno"> 1127</span>&#160;                         std::forward&lt;decltype(_flag)&gt;(_flag));</div>
<div class="line"><a name="l01128"></a><span class="lineno"> 1128</span>&#160;}</div>
<div class="ttc" id="anamespacellfio__v2__xxx_html_a5323ac4d73623d99f92109a5c184e5dd"><div class="ttname"><a href="namespacellfio__v2__xxx.html#a5323ac4d73623d99f92109a5c184e5dd">llfio_v2_xxx::section</a></div><div class="ttdeci">result&lt; section_handle &gt; section(section_handle::extent_type bytes, const path_handle &amp;dirh=path_discovery::storage_backed_temporary_files_directory(), section_handle::flag _flag=section_handle::flag::read|section_handle::flag::write) noexcept</div><div class="ttdoc">Create a memory section backed by an anonymous, managed file.</div><div class="ttdef"><b>Definition:</b> map_handle.hpp:1065</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="abddc6cd762be581f04b00837a8a91730"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abddc6cd762be581f04b00837a8a91730">&#9670;&nbsp;</a></span>mapped_file()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result&lt;<a class="el" href="classllfio__v2__xxx_1_1mapped__file__handle.html">mapped_file_handle</a>&gt; llfio_v2_xxx::mapped_file </td>
          <td>(</td>
          <td class="paramtype">mapped_file_handle::size_type&#160;</td>
          <td class="paramname"><em>reservation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllfio__v2__xxx_1_1path__handle.html">path_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1path__view.html">mapped_file_handle::path_view_type</a>&#160;</td>
          <td class="paramname"><em>_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1handle.html#aa3930273a2d4cabbac309e0b75701dca">mapped_file_handle::mode</a>&#160;</td>
          <td class="paramname"><em>_mode</em> = <code><a class="el" href="classllfio__v2__xxx_1_1handle.html#aa3930273a2d4cabbac309e0b75701dcaaecae13117d6f0584c25a9da6c8f8415e">mapped_file_handle::mode::read</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1handle.html#af0b352d0f273ba6fa70c178b2c2fee42">mapped_file_handle::creation</a>&#160;</td>
          <td class="paramname"><em>_creation</em> = <code><a class="el" href="classllfio__v2__xxx_1_1handle.html#af0b352d0f273ba6fa70c178b2c2fee42aa200dcd6176417e93be2405188ae7cc9">mapped_file_handle::creation::open_existing</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1handle.html#aecd3a7db6cee3aec07d32fe6f99e6852">mapped_file_handle::caching</a>&#160;</td>
          <td class="paramname"><em>_caching</em> = <code><a class="el" href="classllfio__v2__xxx_1_1handle.html#aecd3a7db6cee3aec07d32fe6f99e6852aa181a603769c1f98ad927e7367c7aa51">mapped_file_handle::caching::all</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mapped_file_handle::flag&#160;</td>
          <td class="paramname"><em>flags</em> = <code>mapped_file_handle::flag::none</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a memory mapped file handle opening access to a file on path. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reservation</td><td>The number of bytes to reserve for later expansion when mapping. Zero means reserve only the current file length. </td></tr>
    <tr><td class="paramname">base</td><td>Handle to a base location on the filing system. Pass <code>{}</code> to indicate that path will be absolute. </td></tr>
    <tr><td class="paramname">_path</td><td>The path relative to base to open. </td></tr>
    <tr><td class="paramname">_mode</td><td>How to open the file. </td></tr>
    <tr><td class="paramname">_creation</td><td>How to create the file. </td></tr>
    <tr><td class="paramname">_caching</td><td>How to ask the kernel to cache the file. </td></tr>
    <tr><td class="paramname">flags</td><td>Any additional custom behaviours.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that if the file is currently zero sized, no mapping occurs now, but later when <code>truncate()</code> or <code>update_map()</code> is called.</p>
<dl class="section user"><dt>Errors returnable\n Any of the values which the constructors for file_handle, section_handle and map_handle can return.</dt><dd></dd></dl>
<div class="fragment"><div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;{</div>
<div class="line"><a name="l00823"></a><span class="lineno">  823</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="namespacellfio__v2__xxx.html#a1f0ccde00add2f09579151fd71b8f06d">mapped_file_handle::mapped_file</a>(std::forward&lt;decltype(reservation)&gt;(reservation), std::forward&lt;decltype(base)&gt;(base),</div>
<div class="line"><a name="l00824"></a><span class="lineno">  824</span>&#160;                                         std::forward&lt;decltype(_path)&gt;(_path), std::forward&lt;decltype(_mode)&gt;(_mode),</div>
<div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160;                                         std::forward&lt;decltype(_creation)&gt;(_creation), std::forward&lt;decltype(_caching)&gt;(_caching),</div>
<div class="line"><a name="l00826"></a><span class="lineno">  826</span>&#160;                                         std::forward&lt;decltype(flags)&gt;(flags));</div>
<div class="line"><a name="l00827"></a><span class="lineno">  827</span>&#160;}</div>
<div class="ttc" id="anamespacellfio__v2__xxx_html_a1f0ccde00add2f09579151fd71b8f06d"><div class="ttname"><a href="namespacellfio__v2__xxx.html#a1f0ccde00add2f09579151fd71b8f06d">llfio_v2_xxx::mapped_file</a></div><div class="ttdeci">result&lt; mapped_file_handle &gt; mapped_file(const path_handle &amp;base, mapped_file_handle::path_view_type _path, mapped_file_handle::mode _mode=mapped_file_handle::mode::read, mapped_file_handle::creation _creation=mapped_file_handle::creation::open_existing, mapped_file_handle::caching _caching=mapped_file_handle::caching::all, mapped_file_handle::flag flags=mapped_file_handle::flag::none) noexcept</div><div class="ttdoc">This is an overloaded member function, provided for convenience. It differs from the above function o...</div><div class="ttdef"><b>Definition:</b> mapped_file_handle.hpp:829</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a3eb3e8ef0ddff1270b3d78d4178335c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eb3e8ef0ddff1270b3d78d4178335c7">&#9670;&nbsp;</a></span>mapped_temp_file()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result&lt;<a class="el" href="classllfio__v2__xxx_1_1mapped__file__handle.html">mapped_file_handle</a>&gt; llfio_v2_xxx::mapped_temp_file </td>
          <td>(</td>
          <td class="paramtype">mapped_file_handle::size_type&#160;</td>
          <td class="paramname"><em>reservation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1path__view.html">mapped_file_handle::path_view_type</a>&#160;</td>
          <td class="paramname"><em>name</em> = <code><a class="el" href="classllfio__v2__xxx_1_1path__view.html">mapped_file_handle::path_view_type</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1handle.html#aa3930273a2d4cabbac309e0b75701dca">mapped_file_handle::mode</a>&#160;</td>
          <td class="paramname"><em>_mode</em> = <code><a class="el" href="classllfio__v2__xxx_1_1handle.html#aa3930273a2d4cabbac309e0b75701dcaaefb2a684e4afb7d55e6147fbe5a332ee">mapped_file_handle::mode::write</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1handle.html#af0b352d0f273ba6fa70c178b2c2fee42">mapped_file_handle::creation</a>&#160;</td>
          <td class="paramname"><em>_creation</em> = <code><a class="el" href="classllfio__v2__xxx_1_1handle.html#af0b352d0f273ba6fa70c178b2c2fee42a8f0339e854eb5321306a443ce9199e1d">mapped_file_handle::creation::if_needed</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1handle.html#aecd3a7db6cee3aec07d32fe6f99e6852">mapped_file_handle::caching</a>&#160;</td>
          <td class="paramname"><em>_caching</em> = <code><a class="el" href="classllfio__v2__xxx_1_1handle.html#aecd3a7db6cee3aec07d32fe6f99e6852ad5197d93c063a2b1e22d1630a39b7aef">mapped_file_handle::caching::temporary</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mapped_file_handle::flag&#160;</td>
          <td class="paramname"><em>flags</em> = <code>mapped_file_handle::flag::unlink_on_first_close</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a mapped file handle creating the named file on some path which the OS declares to be suitable for temporary files. Most OSs are very lazy about flushing changes made to these temporary files. Note the default flags are to have the newly created file deleted on first handle close. Note also that an empty name is equivalent to calling <code>mapped_uniquely_named_file(path_discovery::storage_backed_temporary_files_directory())</code> and the creation parameter is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>If the temporary file you are creating is not going to have its path sent to another process for usage, this is the WRONG function to use. Use <code>temp_inode()</code> instead, it is far more secure.</dd></dl>
<dl class="section user"><dt>Errors returnable\n Any of the values POSIX open() or CreateFile() can return.</dt><dd></dd></dl>
<div class="fragment"><div class="line"><a name="l00877"></a><span class="lineno">  877</span>&#160;{</div>
<div class="line"><a name="l00878"></a><span class="lineno">  878</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="namespacellfio__v2__xxx.html#a3eb3e8ef0ddff1270b3d78d4178335c7">mapped_file_handle::mapped_temp_file</a>(std::forward&lt;decltype(reservation)&gt;(reservation), std::forward&lt;decltype(name)&gt;(name),</div>
<div class="line"><a name="l00879"></a><span class="lineno">  879</span>&#160;                                              std::forward&lt;decltype(_mode)&gt;(_mode), std::forward&lt;decltype(_creation)&gt;(_creation),</div>
<div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;                                              std::forward&lt;decltype(_caching)&gt;(_caching), std::forward&lt;decltype(flags)&gt;(flags));</div>
<div class="line"><a name="l00881"></a><span class="lineno">  881</span>&#160;}</div>
<div class="ttc" id="anamespacellfio__v2__xxx_html_a3eb3e8ef0ddff1270b3d78d4178335c7"><div class="ttname"><a href="namespacellfio__v2__xxx.html#a3eb3e8ef0ddff1270b3d78d4178335c7">llfio_v2_xxx::mapped_temp_file</a></div><div class="ttdeci">result&lt; mapped_file_handle &gt; mapped_temp_file(mapped_file_handle::size_type reservation, mapped_file_handle::path_view_type name=mapped_file_handle::path_view_type(), mapped_file_handle::mode _mode=mapped_file_handle::mode::write, mapped_file_handle::creation _creation=mapped_file_handle::creation::if_needed, mapped_file_handle::caching _caching=mapped_file_handle::caching::temporary, mapped_file_handle::flag flags=mapped_file_handle::flag::unlink_on_first_close) noexcept</div><div class="ttdef"><b>Definition:</b> mapped_file_handle.hpp:871</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a3b775591c19686ab10aa812fa3c82917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b775591c19686ab10aa812fa3c82917">&#9670;&nbsp;</a></span>mapped_temp_inode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result&lt;<a class="el" href="classllfio__v2__xxx_1_1mapped__file__handle.html">mapped_file_handle</a>&gt; llfio_v2_xxx::mapped_temp_inode </td>
          <td>(</td>
          <td class="paramtype">mapped_file_handle::size_type&#160;</td>
          <td class="paramname"><em>reservation</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllfio__v2__xxx_1_1path__handle.html">path_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>dir</em> = <code><a class="el" href="namespacellfio__v2__xxx_1_1path__discovery.html#a2dd74ea752f3f511d58ccccdcac7f4fd">path_discovery::storage_backed_temporary_files_directory</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1handle.html#aa3930273a2d4cabbac309e0b75701dca">mapped_file_handle::mode</a>&#160;</td>
          <td class="paramname"><em>_mode</em> = <code><a class="el" href="classllfio__v2__xxx_1_1handle.html#aa3930273a2d4cabbac309e0b75701dcaaefb2a684e4afb7d55e6147fbe5a332ee">mapped_file_handle::mode::write</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1handle.html#aecd3a7db6cee3aec07d32fe6f99e6852">mapped_file_handle::caching</a>&#160;</td>
          <td class="paramname"><em>_caching</em> = <code><a class="el" href="classllfio__v2__xxx_1_1handle.html#aecd3a7db6cee3aec07d32fe6f99e6852ad5197d93c063a2b1e22d1630a39b7aef">mapped_file_handle::caching::temporary</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mapped_file_handle::flag&#160;</td>
          <td class="paramname"><em>flags</em> = <code>mapped_file_handle::flag::none</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><em>Securely</em> create a mapped file handle creating a temporary anonymous inode in the filesystem referred to by <em>dirpath</em>. The inode created has no name nor accessible path on the filing system and ceases to exist as soon as the last handle is closed, making it ideal for use as a temporary file where other processes do not need to have access to its contents via some path on the filing system (a classic use case is for backing shared memory maps).</p>
<dl class="section user"><dt>Errors returnable\n Any of the values POSIX open() or CreateFile() can return.</dt><dd></dd></dl>
<div class="fragment"><div class="line"><a name="l00897"></a><span class="lineno">  897</span>&#160;{</div>
<div class="line"><a name="l00898"></a><span class="lineno">  898</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="namespacellfio__v2__xxx.html#a3b775591c19686ab10aa812fa3c82917">mapped_file_handle::mapped_temp_inode</a>(std::forward&lt;decltype(reservation)&gt;(reservation), std::forward&lt;decltype(dir)&gt;(dir),</div>
<div class="line"><a name="l00899"></a><span class="lineno">  899</span>&#160;                                               std::forward&lt;decltype(_mode)&gt;(_mode), std::forward&lt;decltype(_caching)&gt;(_caching),</div>
<div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;                                               std::forward&lt;decltype(flags)&gt;(flags));</div>
<div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160;}</div>
<div class="ttc" id="anamespacellfio__v2__xxx_html_a3b775591c19686ab10aa812fa3c82917"><div class="ttname"><a href="namespacellfio__v2__xxx.html#a3b775591c19686ab10aa812fa3c82917">llfio_v2_xxx::mapped_temp_inode</a></div><div class="ttdeci">result&lt; mapped_file_handle &gt; mapped_temp_inode(mapped_file_handle::size_type reservation=0, const path_handle &amp;dir=path_discovery::storage_backed_temporary_files_directory(), mapped_file_handle::mode _mode=mapped_file_handle::mode::write, mapped_file_handle::caching _caching=mapped_file_handle::caching::temporary, mapped_file_handle::flag flags=mapped_file_handle::flag::none) noexcept</div><div class="ttdef"><b>Definition:</b> mapped_file_handle.hpp:892</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a092f75c4e639c85797120488d486fa38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a092f75c4e639c85797120488d486fa38">&#9670;&nbsp;</a></span>mapped_uniquely_named_file()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result&lt;<a class="el" href="classllfio__v2__xxx_1_1mapped__file__handle.html">mapped_file_handle</a>&gt; llfio_v2_xxx::mapped_uniquely_named_file </td>
          <td>(</td>
          <td class="paramtype">mapped_file_handle::size_type&#160;</td>
          <td class="paramname"><em>reservation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllfio__v2__xxx_1_1path__handle.html">path_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>dirpath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1handle.html#aa3930273a2d4cabbac309e0b75701dca">mapped_file_handle::mode</a>&#160;</td>
          <td class="paramname"><em>_mode</em> = <code><a class="el" href="classllfio__v2__xxx_1_1handle.html#aa3930273a2d4cabbac309e0b75701dcaaefb2a684e4afb7d55e6147fbe5a332ee">mapped_file_handle::mode::write</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1handle.html#aecd3a7db6cee3aec07d32fe6f99e6852">mapped_file_handle::caching</a>&#160;</td>
          <td class="paramname"><em>_caching</em> = <code><a class="el" href="classllfio__v2__xxx_1_1handle.html#aecd3a7db6cee3aec07d32fe6f99e6852ad5197d93c063a2b1e22d1630a39b7aef">mapped_file_handle::caching::temporary</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mapped_file_handle::flag&#160;</td>
          <td class="paramname"><em>flags</em> = <code>mapped_file_handle::flag::none</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an mapped file handle creating a randomly named file on a path. The file is opened exclusively with <code>creation::only_if_not_exist</code> so it will never collide with nor overwrite any existing file. Note also that caching defaults to temporary which hints to the OS to only flush changes to physical storage as lately as possible.</p>
<dl class="section user"><dt>Errors returnable\n Any of the values POSIX open() or CreateFile() can return.</dt><dd></dd></dl>
<div class="fragment"><div class="line"><a name="l00851"></a><span class="lineno">  851</span>&#160;{</div>
<div class="line"><a name="l00852"></a><span class="lineno">  852</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="namespacellfio__v2__xxx.html#a092f75c4e639c85797120488d486fa38">mapped_file_handle::mapped_uniquely_named_file</a>(std::forward&lt;decltype(reservation)&gt;(reservation), std::forward&lt;decltype(dirpath)&gt;(dirpath),</div>
<div class="line"><a name="l00853"></a><span class="lineno">  853</span>&#160;                                                        std::forward&lt;decltype(_mode)&gt;(_mode), std::forward&lt;decltype(_caching)&gt;(_caching),</div>
<div class="line"><a name="l00854"></a><span class="lineno">  854</span>&#160;                                                        std::forward&lt;decltype(flags)&gt;(flags));</div>
<div class="line"><a name="l00855"></a><span class="lineno">  855</span>&#160;}</div>
<div class="ttc" id="anamespacellfio__v2__xxx_html_a092f75c4e639c85797120488d486fa38"><div class="ttname"><a href="namespacellfio__v2__xxx.html#a092f75c4e639c85797120488d486fa38">llfio_v2_xxx::mapped_uniquely_named_file</a></div><div class="ttdeci">result&lt; mapped_file_handle &gt; mapped_uniquely_named_file(mapped_file_handle::size_type reservation, const path_handle &amp;dirpath, mapped_file_handle::mode _mode=mapped_file_handle::mode::write, mapped_file_handle::caching _caching=mapped_file_handle::caching::temporary, mapped_file_handle::flag flags=mapped_file_handle::flag::none) noexcept</div><div class="ttdef"><b>Definition:</b> mapped_file_handle.hpp:847</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a1759f4cee184d433f4446a39ff8bfa02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1759f4cee184d433f4446a39ff8bfa02">&#9670;&nbsp;</a></span>maximum_extent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result&lt;file_handle::extent_type&gt; llfio_v2_xxx::maximum_extent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllfio__v2__xxx_1_1file__handle.html">file_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the current maximum permitted extent of the file.</p>
<dl class="section user"><dt>Errors returnable\n Any of the values POSIX fstat() or GetFileInformationByHandleEx() can return.</dt><dd></dd></dl>
<div class="fragment"><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;{</div>
<div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">self</span>.maximum_extent();</div>
<div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a992163d3f408a79ede51325ecfac0d25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a992163d3f408a79ede51325ecfac0d25">&#9670;&nbsp;</a></span>nvram_barrier()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structllfio__v2__xxx_1_1byte__io__multiplexer_1_1const__buffer__type.html">byte_io_handle::const_buffer_type</a> llfio_v2_xxx::nvram_barrier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structllfio__v2__xxx_1_1byte__io__multiplexer_1_1const__buffer__type.html">byte_io_handle::const_buffer_type</a>&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>evict</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Lightweight inlined barrier which causes the CPU to write out all buffered writes and dirty cache lines in the request to main memory. </p><dl class="section return"><dt>Returns</dt><dd>The cache lines actually barriered. This may be empty. This function does not return an error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>The range of cache lines to write barrier. </td></tr>
    <tr><td class="paramname">evict</td><td>Whether to also evict the cache lines from CPU caches, useful if they will not be used again.</td></tr>
  </table>
  </dd>
</dl>
<p>Upon return, one knows that memory in the returned buffer has been barriered (it may be empty if there is no support for this operation in LLFIO, or if the current CPU does not support this operation). You may find the <code>is_nvram()</code> observer of particular use here. </p>
<div class="fragment"><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;{</div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;  <span class="keyword">auto</span> *tp = (byte_io_handle::const_buffer_type::pointer) (((uintptr_t) req.data()) &amp; ~63);</div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;  byte_io_handle::const_buffer_type ret{tp, (size_t) (req.data() + 63 + req.size() - tp) &amp; ~63};</div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;  <span class="keywordflow">if</span>(memory_flush_none == mem_flush_stores(ret.data(), ret.size(), evict ? memory_flush_evict : memory_flush_retain))</div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;  {</div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;    ret = {tp, 0};</div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;  }</div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;  <span class="keywordflow">return</span> ret;</div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a49f7bb77eb38fbe1280019225b66b78b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49f7bb77eb38fbe1280019225b66b78b">&#9670;&nbsp;</a></span>path()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result&lt;<a class="el" href="classllfio__v2__xxx_1_1path__handle.html">path_handle</a>&gt; llfio_v2_xxx::path </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllfio__v2__xxx_1_1path__handle.html">path_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1path__handle.html#a6f2c51636f17ae97255106d37ef4187c">path_handle::path_view_type</a>&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a path handle opening access to some location on the filing system. Some operating systems provide a particularly lightweight method of doing this (Linux: <code>O_PATH</code>, Windows: no access perms) which is much faster than opening a directory. For other systems, we open a directory with read only permissions.</p>
<dl class="section user"><dt>Errors returnable\n Any of the values POSIX open() or CreateFile() can return.</dt><dd></dd></dl>
<div class="fragment"><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;{</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="namespacellfio__v2__xxx.html#ad8b12afdd4c80d69d2530bd40f92427c">path_handle::path</a>(std::forward&lt;decltype(base)&gt;(base), std::forward&lt;decltype(<a class="code" href="namespacellfio__v2__xxx.html#ad8b12afdd4c80d69d2530bd40f92427c">path</a>)&gt;(<a class="code" href="namespacellfio__v2__xxx.html#ad8b12afdd4c80d69d2530bd40f92427c">path</a>));</div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;}</div>
<div class="ttc" id="anamespacellfio__v2__xxx_html_ad8b12afdd4c80d69d2530bd40f92427c"><div class="ttname"><a href="namespacellfio__v2__xxx.html#ad8b12afdd4c80d69d2530bd40f92427c">llfio_v2_xxx::path</a></div><div class="ttdeci">result&lt; path_handle &gt; path(path_handle::path_view_type _path) noexcept</div><div class="ttdoc">This is an overloaded member function, provided for convenience. It differs from the above function o...</div><div class="ttdef"><b>Definition:</b> path_handle.hpp:176</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a727d8ebc7f42ff3124d1734a1a1f0563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a727d8ebc7f42ff3124d1734a1a1f0563">&#9670;&nbsp;</a></span>poll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result&lt;size_t&gt; llfio_v2_xxx::poll </td>
          <td>(</td>
          <td class="paramtype">span&lt; poll_what &gt;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">span&lt; <a class="el" href="classllfio__v2__xxx_1_1pollable__handle.html">pollable_handle</a> * &gt;&#160;</td>
          <td class="paramname"><em>handles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">span&lt; const poll_what &gt;&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllfio__v2__xxx_1_1deadline.html">deadline</a>&#160;</td>
          <td class="paramname"><em>d</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Polls a list of pollable handles awaiting a change in state. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of handles with changed state. Handles not <code>is_kernel_handle()</code> receive <code>poll_what::not_pollable</code>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>An array of <code>poll_what</code> set with the results of the poll. The bits in this array are NOT cleared by this operation, so you need to clear this manualy before the call if that's what you need. </td></tr>
    <tr><td class="paramname">handles</td><td>An array of pointers to <code>handle</code>. Individual pointers can be null if you want to skip them. </td></tr>
    <tr><td class="paramname">query</td><td>An array of <code>poll_what</code> to check. </td></tr>
    <tr><td class="paramname">d</td><td>An optional timeout. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Errors returnable\n Whatever POSIX poll() or Windows WSAPoll() can return.</dt><dd></dd></dl>
<p>Note that the maximum number of handles which can be passed to this function is 1024 (the platform syscall may refuse even that many). Note that this function is <code>O(N)</code> to handle count, so more than a few hundred is a bad idea in any case. If you need to wait on more handles than this, you need to implement a <code>byte_io_multiplexer</code> for your platform.</p>
<p>The sizes of <code>out</code>, <code>handles</code> and <code>query</code> must be the same, or an error is returned.</p>
<dl class="section note"><dt>Note</dt><dd>On POSIX <code>pipe_handle</code> is a <code>pollable_handle</code>, but on Windows it is not. Also, on Windows, you cannot mix socket handles from different networking stacks in the same poll. </dd></dl>

</div>
</div>
<a id="a26baf26ed8a75301a92134497cc3ac8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26baf26ed8a75301a92134497cc3ac8a">&#9670;&nbsp;</a></span>QUICKCPPLIB_BITFIELD_BEGIN_T() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llfio_v2_xxx::QUICKCPPLIB_BITFIELD_BEGIN_T </td>
          <td>(</td>
          <td class="paramtype">poll_what&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>What to poll. </p>
<p>&lt; Query nothing for this handle.</p>
<p>&lt; If this handle is readable.</p>
<p>&lt; If this handle is writable.</p>
<p>&lt; If this handle is errored. This is always set in the output even if not requested.</p>
<p>&lt; If this handle is closed/hung up. This is always set in the output even if not requested.</p>
<p>&lt; This handle is not pollable.</p>
<div class="fragment"><div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;{</div>
<div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;<a class="code" href="namespacellfio__v2__xxx_1_1ip.html#a2b874cadb614a4ef4ba44fdf3dd8dd74ac9a302c8c365bd927a21930678b71a8a">none</a> = 0U,  <span class="comment">//!&lt; Query nothing for this handle.</span></div>
<div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160; </div>
<div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;is_readable = (1U &lt;&lt; 0U),  <span class="comment">//!&lt; If this handle is readable.</span></div>
<div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;is_writable = (1U &lt;&lt; 1U),  <span class="comment">//!&lt; If this handle is writable.</span></div>
<div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;is_errored = (1U &lt;&lt; 2U),   <span class="comment">//!&lt; If this handle is errored. This is always set in the output even if not requested.</span></div>
<div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;is_closed = (1U &lt;&lt; 3U),    <span class="comment">//!&lt; If this handle is closed/hung up. This is always set in the output even if not requested.</span></div>
<div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160; </div>
<div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;not_pollable = (1U &lt;&lt; 7U)  <span class="comment">//!&lt; This handle is not pollable.</span></div>
<div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;}  <span class="comment">//</span></div>
<div class="ttc" id="anamespacellfio__v2__xxx_1_1ip_html_a2b874cadb614a4ef4ba44fdf3dd8dd74ac9a302c8c365bd927a21930678b71a8a"><div class="ttname"><a href="namespacellfio__v2__xxx_1_1ip.html#a2b874cadb614a4ef4ba44fdf3dd8dd74ac9a302c8c365bd927a21930678b71a8a">llfio_v2_xxx::ip::none</a></div><div class="ttdeci">@ none</div><div class="ttdoc">No flags.</div><div class="ttdef"><b>Definition:</b> byte_socket_handle.hpp:235</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a30f0de9f074d32381006e42b02a3669e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30f0de9f074d32381006e42b02a3669e">&#9670;&nbsp;</a></span>QUICKCPPLIB_BITFIELD_BEGIN_T() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llfio_v2_xxx::QUICKCPPLIB_BITFIELD_BEGIN_T </td>
          <td>(</td>
          <td class="paramtype">tls_socket_source_implementation_features&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Feature bits for TLS socket sources. </p>
<p>&lt; No bits set</p>
<p>&lt; This socket source provides kernel sockets i.e. their native handles will be valid kernel sockets which can be used in <code>poll()</code> etc</p>
<p>&lt; This socket source is the "system" rather than "third party" implementation for TLS sockets</p>
<p>&lt; This socket source provides an i/o multiplexer</p>
<p>&lt; This socket source may be able to wrap third party plain sockets</p>
<p>&lt; This socket source provides FIPS_140_2 compliant algorithms</p>
<p>&lt; All bits set</p>
<div class="fragment"><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;                                                                                 {</div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;<a class="code" href="namespacellfio__v2__xxx_1_1ip.html#a2b874cadb614a4ef4ba44fdf3dd8dd74ac9a302c8c365bd927a21930678b71a8a">none</a> = 0U,  <span class="comment">//!&lt; No bits set</span></div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160; </div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;kernel_sockets =</div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;(1U &lt;&lt; 0U),  <span class="comment">//!&lt; This socket source provides kernel sockets i.e. their native handles will be valid kernel sockets which can be used in `poll()` etc</span></div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;system_implementation = (1U &lt;&lt; 1U),  <span class="comment">//!&lt; This socket source is the &quot;system&quot; rather than &quot;third party&quot; implementation for TLS sockets</span></div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;io_multiplexer = (1U &lt;&lt; 2U),         <span class="comment">//!&lt; This socket source provides an i/o multiplexer</span></div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;supports_wrap = (1U &lt;&lt; 3U),          <span class="comment">//!&lt; This socket source may be able to wrap third party plain sockets</span></div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160; </div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;<a class="code" href="namespacellfio__v2__xxx.html#a6269702375c265b9985fe47df4447c7baf7da33fdf71e962b32ddd8345e293911">FIPS_140_2</a> = (1U &lt;&lt; 16U),  <span class="comment">//!&lt; This socket source provides FIPS_140_2 compliant algorithms</span></div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160; </div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;all = 0xffffffff  <span class="comment">//!&lt; All bits set</span></div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;}  <span class="comment">//</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="acbd9eb25fed94bb0bc8fa888b3c26bdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbd9eb25fed94bb0bc8fa888b3c26bdf">&#9670;&nbsp;</a></span>read() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structllfio__v2__xxx_1_1byte__io__multiplexer_1_1io__result.html">byte_io_handle::io_result</a>&lt;byte_io_handle::buffers_type&gt; llfio_v2_xxx::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1byte__io__handle.html">byte_io_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllfio__v2__xxx_1_1byte__io__multiplexer_1_1io__request.html">byte_io_handle::io_request</a>&lt; byte_io_handle::buffers_type &gt;&#160;</td>
          <td class="paramname"><em>reqs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllfio__v2__xxx_1_1deadline.html">deadline</a>&#160;</td>
          <td class="paramname"><em>d</em> = <code><a class="el" href="structllfio__v2__xxx_1_1deadline.html">deadline</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read data from the open handle. </p>
<dl class="section warning"><dt>Warning</dt><dd>Depending on the implementation backend, <b>very</b> different buffers may be returned than you supplied. You should <b>always</b> use the buffers returned and assume that they point to different memory and that each buffer's size will have changed.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The buffers read, which may not be the buffers input. The size of each scatter-gather buffer is updated with the number of bytes of that buffer transferred, and the pointer to the data may be <em>completely</em> different to what was submitted (e.g. it may point into a memory map). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The object whose member function to call. </td></tr>
    <tr><td class="paramname">reqs</td><td>A scatter-gather and offset request. </td></tr>
    <tr><td class="paramname">d</td><td>An optional deadline by which the i/o must complete, else it is cancelled. Note function may return significantly after this deadline if the i/o takes long to cancel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Errors returnable\n Any of the values POSIX read() can return, errc::timed_out, errc::operation_canceled. errc::not_supported may be</dt><dd>returned if deadline i/o is not possible with this particular handle configuration (e.g. reading from regular files on POSIX or reading from a non-overlapped HANDLE on Windows). </dd></dl>
<dl class="section user"><dt>Memory Allocations\n The default synchronous implementation in file_handle performs no memory allocation.</dt><dd></dd></dl>
<div class="fragment"><div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;{</div>
<div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">self</span>.read(std::forward&lt;decltype(reqs)&gt;(reqs), std::forward&lt;decltype(d)&gt;(d));</div>
<div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab993693c98cdb52e2d611f8f9e24e4e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab993693c98cdb52e2d611f8f9e24e4e2">&#9670;&nbsp;</a></span>read() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structllfio__v2__xxx_1_1byte__io__multiplexer_1_1io__result.html">map_handle::io_result</a>&lt;map_handle::buffers_type&gt; llfio_v2_xxx::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1map__handle.html">map_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllfio__v2__xxx_1_1byte__io__multiplexer_1_1io__request.html">map_handle::io_request</a>&lt; map_handle::buffers_type &gt;&#160;</td>
          <td class="paramname"><em>reqs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllfio__v2__xxx_1_1deadline.html">deadline</a>&#160;</td>
          <td class="paramname"><em>d</em> = <code><a class="el" href="structllfio__v2__xxx_1_1deadline.html">deadline</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read data from the mapped view. </p>
<dl class="section note"><dt>Note</dt><dd>Because this implementation never copies memory, you can pass in buffers with a null address.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The buffers read, which will never be the buffers input because they will point into the mapped view. The size of each scatter-gather buffer is updated with the number of bytes of that buffer transferred. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The object whose member function to call. </td></tr>
    <tr><td class="paramname">reqs</td><td>A scatter-gather and offset request. </td></tr>
    <tr><td class="paramname">d</td><td>Ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Errors returnable\n None, though the various signals and structured exception throws common to using memory maps may occur.</dt><dd></dd></dl>
<dl class="section user"><dt>Memory Allocations\n None.</dt><dd></dd></dl>
<div class="fragment"><div class="line"><a name="l01178"></a><span class="lineno"> 1178</span>&#160;{</div>
<div class="line"><a name="l01179"></a><span class="lineno"> 1179</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">self</span>.read(std::forward&lt;decltype(reqs)&gt;(reqs), std::forward&lt;decltype(d)&gt;(d));</div>
<div class="line"><a name="l01180"></a><span class="lineno"> 1180</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a60fa5c64c83ce05c8287c5379d082e49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60fa5c64c83ce05c8287c5379d082e49">&#9670;&nbsp;</a></span>relink()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result&lt;void&gt; llfio_v2_xxx::relink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html">fs_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllfio__v2__xxx_1_1path__handle.html">path_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#abcd8c8171f4e561620864295e8d5879b">fs_handle::path_view_type</a>&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>atomic_replace</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllfio__v2__xxx_1_1deadline.html">deadline</a>&#160;</td>
          <td class="paramname"><em>d</em> = <code>std::chrono::seconds(30)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Relinks the current path of this open handle to the new path specified. If <code>atomic_replace</code> is true, the relink <b>atomically</b> and silently replaces any item at the new path specified. This operation is both atomic and silent matching POSIX behaviour even on Microsoft Windows where no Win32 API can match POSIX semantics.</p>
<dl class="section warning"><dt>Warning</dt><dd>Some operating systems provide a race free syscall for renaming an open handle (Windows). On all other operating systems this call is <b>racy</b> and can result in the wrong file entry being relinked. Note that unless <code>flag::disable_safety_unlinks</code> is set, this implementation opens a <code>path_handle</code> to the source containing directory first, then checks before relinking that the item about to be relinked has the same inode as the open file handle. It will retry this matching until success until the deadline given. This should prevent most unmalicious accidental loss of data.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The object whose member function to call. </td></tr>
    <tr><td class="paramname">base</td><td>Base for any relative path. </td></tr>
    <tr><td class="paramname">path</td><td>The relative or absolute new path to relink to. </td></tr>
    <tr><td class="paramname">atomic_replace</td><td>Atomically replace the destination if a file entry already is present there. Choosing false for this will fail if a file entry is already present at the destination, and may not be an atomic operation on some platforms (i.e. both the old and new names may be linked to the same inode for a very short period of time). Windows and recent Linuxes are always atomic. </td></tr>
    <tr><td class="paramname">d</td><td>The deadline by which the matching of the containing directory to the open handle's inode must succeed, else <code>errc::timed_out</code> will be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Memory Allocations\n Except on platforms with race free syscalls for renaming open handles (Windows), calls</dt><dd><code>current_path()</code> via <code>parent_path_handle()</code> and thus is both expensive and calls malloc many times. </dd></dl>
<div class="fragment"><div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;{</div>
<div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">self</span>.relink(std::forward&lt;decltype(base)&gt;(base), std::forward&lt;decltype(<a class="code" href="namespacellfio__v2__xxx.html#a49f7bb77eb38fbe1280019225b66b78b">path</a>)&gt;(<a class="code" href="namespacellfio__v2__xxx.html#a49f7bb77eb38fbe1280019225b66b78b">path</a>), std::forward&lt;decltype(atomic_replace)&gt;(atomic_replace),</div>
<div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;                     std::forward&lt;decltype(d)&gt;(d));</div>
<div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3d55c0a3b567c7ed05053a94750bb133"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d55c0a3b567c7ed05053a94750bb133">&#9670;&nbsp;</a></span>section() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result&lt;<a class="el" href="classllfio__v2__xxx_1_1section__handle.html">section_handle</a>&gt; llfio_v2_xxx::section </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1file__handle.html">file_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>backing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">section_handle::extent_type&#160;</td>
          <td class="paramname"><em>bytes</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a memory section backed by a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">backing</td><td>The handle to use as backing storage. </td></tr>
    <tr><td class="paramname">bytes</td><td>The initial size of this section, which cannot be larger than any backing file. Zero means to use <code>backing.maximum_extent()</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>This convenience overload create a writable section if the backing file is writable, otherwise a read-only section.</p>
<dl class="section user"><dt>Errors returnable\n Any of the values POSIX dup(), open() or NtCreateSection() can return.</dt><dd></dd></dl>
<div class="fragment"><div class="line"><a name="l01055"></a><span class="lineno"> 1055</span>&#160;{</div>
<div class="line"><a name="l01056"></a><span class="lineno"> 1056</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="namespacellfio__v2__xxx.html#a5323ac4d73623d99f92109a5c184e5dd">section_handle::section</a>(std::forward&lt;decltype(backing)&gt;(backing), std::forward&lt;decltype(bytes)&gt;(bytes));</div>
<div class="line"><a name="l01057"></a><span class="lineno"> 1057</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac9be77116e7a2d8c029dd066dfa363fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9be77116e7a2d8c029dd066dfa363fb">&#9670;&nbsp;</a></span>section() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result&lt;<a class="el" href="classllfio__v2__xxx_1_1section__handle.html">section_handle</a>&gt; llfio_v2_xxx::section </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1file__handle.html">file_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>backing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">section_handle::extent_type&#160;</td>
          <td class="paramname"><em>maximum_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">section_handle::flag&#160;</td>
          <td class="paramname"><em>_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a memory section backed by a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">backing</td><td>The handle to use as backing storage. </td></tr>
    <tr><td class="paramname">maximum_size</td><td>The initial size of this section, which cannot be larger than any backing file. Zero means to use <code>backing.maximum_extent()</code>. </td></tr>
    <tr><td class="paramname">_flag</td><td>How to create the section.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Errors returnable\n Any of the values POSIX dup(), open() or NtCreateSection() can return.</dt><dd></dd></dl>
<div class="fragment"><div class="line"><a name="l01042"></a><span class="lineno"> 1042</span>&#160;{</div>
<div class="line"><a name="l01043"></a><span class="lineno"> 1043</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="namespacellfio__v2__xxx.html#a5323ac4d73623d99f92109a5c184e5dd">section_handle::section</a>(std::forward&lt;decltype(backing)&gt;(backing), std::forward&lt;decltype(maximum_size)&gt;(maximum_size),</div>
<div class="line"><a name="l01044"></a><span class="lineno"> 1044</span>&#160;                                 std::forward&lt;decltype(_flag)&gt;(_flag));</div>
<div class="line"><a name="l01045"></a><span class="lineno"> 1045</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5323ac4d73623d99f92109a5c184e5dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5323ac4d73623d99f92109a5c184e5dd">&#9670;&nbsp;</a></span>section() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result&lt;<a class="el" href="classllfio__v2__xxx_1_1section__handle.html">section_handle</a>&gt; llfio_v2_xxx::section </td>
          <td>(</td>
          <td class="paramtype">section_handle::extent_type&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllfio__v2__xxx_1_1path__handle.html">path_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>dirh</em> = <code><a class="el" href="namespacellfio__v2__xxx_1_1path__discovery.html#a2dd74ea752f3f511d58ccccdcac7f4fd">path_discovery::storage_backed_temporary_files_directory</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">section_handle::flag&#160;</td>
          <td class="paramname"><em>_flag</em> = <code>section_handle::flag::read&#160;|&#160;section_handle::flag::write</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a memory section backed by an anonymous, managed file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>The initial size of this section. Cannot be zero. </td></tr>
    <tr><td class="paramname">dirh</td><td>Where to create the anonymous, managed file. </td></tr>
    <tr><td class="paramname">_flag</td><td>How to create the section.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Errors returnable\n Any of the values POSIX dup(), open() or NtCreateSection() can return.</dt><dd></dd></dl>
<div class="fragment"><div class="line"><a name="l01067"></a><span class="lineno"> 1067</span>&#160;{</div>
<div class="line"><a name="l01068"></a><span class="lineno"> 1068</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="namespacellfio__v2__xxx.html#a5323ac4d73623d99f92109a5c184e5dd">section_handle::section</a>(std::forward&lt;decltype(bytes)&gt;(bytes), std::forward&lt;decltype(dirh)&gt;(dirh), std::forward&lt;decltype(_flag)&gt;(_flag));</div>
<div class="line"><a name="l01069"></a><span class="lineno"> 1069</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="addbdc12d4993a8ee40c105a02a105a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addbdc12d4993a8ee40c105a02a105a61">&#9670;&nbsp;</a></span>temp_directory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result&lt;<a class="el" href="classllfio__v2__xxx_1_1directory__handle.html">directory_handle</a>&gt; llfio_v2_xxx::temp_directory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1path__view.html">directory_handle::path_view_type</a>&#160;</td>
          <td class="paramname"><em>name</em> = <code><a class="el" href="classllfio__v2__xxx_1_1path__view.html">directory_handle::path_view_type</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1handle.html#aa3930273a2d4cabbac309e0b75701dca">directory_handle::mode</a>&#160;</td>
          <td class="paramname"><em>_mode</em> = <code><a class="el" href="classllfio__v2__xxx_1_1handle.html#aa3930273a2d4cabbac309e0b75701dcaaefb2a684e4afb7d55e6147fbe5a332ee">directory_handle::mode::write</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1handle.html#af0b352d0f273ba6fa70c178b2c2fee42">directory_handle::creation</a>&#160;</td>
          <td class="paramname"><em>_creation</em> = <code><a class="el" href="classllfio__v2__xxx_1_1handle.html#af0b352d0f273ba6fa70c178b2c2fee42a8f0339e854eb5321306a443ce9199e1d">directory_handle::creation::if_needed</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1handle.html#aecd3a7db6cee3aec07d32fe6f99e6852">directory_handle::caching</a>&#160;</td>
          <td class="paramname"><em>_caching</em> = <code><a class="el" href="classllfio__v2__xxx_1_1handle.html#aecd3a7db6cee3aec07d32fe6f99e6852aa181a603769c1f98ad927e7367c7aa51">directory_handle::caching::all</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">directory_handle::flag&#160;</td>
          <td class="paramname"><em>flags</em> = <code>directory_handle::flag::none</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a directory handle creating the named directory on some path which the OS declares to be suitable for temporary files. Note also that an empty name is equivalent to calling <code>uniquely_named_file(path_discovery::storage_backed_temporary_files_directory())</code> and the creation parameter is ignored.</p>
<dl class="section user"><dt>Errors returnable\n Any of the values POSIX open() or CreateFile() can return.</dt><dd></dd></dl>
<div class="fragment"><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;{</div>
<div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="namespacellfio__v2__xxx.html#addbdc12d4993a8ee40c105a02a105a61">directory_handle::temp_directory</a>(std::forward&lt;decltype(name)&gt;(name), std::forward&lt;decltype(_mode)&gt;(_mode),</div>
<div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;                                          std::forward&lt;decltype(_creation)&gt;(_creation), std::forward&lt;decltype(_caching)&gt;(_caching),</div>
<div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;                                          std::forward&lt;decltype(flags)&gt;(flags));</div>
<div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;}</div>
<div class="ttc" id="anamespacellfio__v2__xxx_html_addbdc12d4993a8ee40c105a02a105a61"><div class="ttname"><a href="namespacellfio__v2__xxx.html#addbdc12d4993a8ee40c105a02a105a61">llfio_v2_xxx::temp_directory</a></div><div class="ttdeci">result&lt; directory_handle &gt; temp_directory(directory_handle::path_view_type name=directory_handle::path_view_type(), directory_handle::mode _mode=directory_handle::mode::write, directory_handle::creation _creation=directory_handle::creation::if_needed, directory_handle::caching _caching=directory_handle::caching::all, directory_handle::flag flags=directory_handle::flag::none) noexcept</div><div class="ttdef"><b>Definition:</b> directory_handle.hpp:495</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a70d9ef3b988a880d171015b754bb7b27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70d9ef3b988a880d171015b754bb7b27">&#9670;&nbsp;</a></span>temp_file()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result&lt;<a class="el" href="classllfio__v2__xxx_1_1file__handle.html">file_handle</a>&gt; llfio_v2_xxx::temp_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1path__view.html">file_handle::path_view_type</a>&#160;</td>
          <td class="paramname"><em>name</em> = <code><a class="el" href="classllfio__v2__xxx_1_1path__view.html">file_handle::path_view_type</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1handle.html#aa3930273a2d4cabbac309e0b75701dca">file_handle::mode</a>&#160;</td>
          <td class="paramname"><em>_mode</em> = <code><a class="el" href="classllfio__v2__xxx_1_1handle.html#aa3930273a2d4cabbac309e0b75701dcaaefb2a684e4afb7d55e6147fbe5a332ee">file_handle::mode::write</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1handle.html#af0b352d0f273ba6fa70c178b2c2fee42">file_handle::creation</a>&#160;</td>
          <td class="paramname"><em>_creation</em> = <code><a class="el" href="classllfio__v2__xxx_1_1handle.html#af0b352d0f273ba6fa70c178b2c2fee42a8f0339e854eb5321306a443ce9199e1d">file_handle::creation::if_needed</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1handle.html#aecd3a7db6cee3aec07d32fe6f99e6852">file_handle::caching</a>&#160;</td>
          <td class="paramname"><em>_caching</em> = <code><a class="el" href="classllfio__v2__xxx_1_1handle.html#aecd3a7db6cee3aec07d32fe6f99e6852ad5197d93c063a2b1e22d1630a39b7aef">file_handle::caching::temporary</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">file_handle::flag&#160;</td>
          <td class="paramname"><em>flags</em> = <code>file_handle::flag::unlink_on_first_close</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a file handle creating the named file on some path which the OS declares to be suitable for temporary files. Most OSs are very lazy about flushing changes made to these temporary files. Note the default flags are to have the newly created file deleted on first handle close. Note also that an empty name is equivalent to calling <code>uniquely_named_file(path_discovery::storage_backed_temporary_files_directory())</code> and the creation parameter is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>If the temporary file you are creating is not going to have its path sent to another process for usage, this is the WRONG function to use. Use <code>temp_inode()</code> instead, it is far more secure.</dd></dl>
<dl class="section user"><dt>Errors returnable\n Any of the values POSIX open() or CreateFile() can return.</dt><dd></dd></dl>
<div class="fragment"><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;{</div>
<div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="namespacellfio__v2__xxx.html#a70d9ef3b988a880d171015b754bb7b27">file_handle::temp_file</a>(std::forward&lt;decltype(name)&gt;(name), std::forward&lt;decltype(_mode)&gt;(_mode), std::forward&lt;decltype(_creation)&gt;(_creation),</div>
<div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;                                std::forward&lt;decltype(_caching)&gt;(_caching), std::forward&lt;decltype(flags)&gt;(flags));</div>
<div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;}</div>
<div class="ttc" id="anamespacellfio__v2__xxx_html_a70d9ef3b988a880d171015b754bb7b27"><div class="ttname"><a href="namespacellfio__v2__xxx.html#a70d9ef3b988a880d171015b754bb7b27">llfio_v2_xxx::temp_file</a></div><div class="ttdeci">result&lt; file_handle &gt; temp_file(file_handle::path_view_type name=file_handle::path_view_type(), file_handle::mode _mode=file_handle::mode::write, file_handle::creation _creation=file_handle::creation::if_needed, file_handle::caching _caching=file_handle::caching::temporary, file_handle::flag flags=file_handle::flag::unlink_on_first_close) noexcept</div><div class="ttdef"><b>Definition:</b> file_handle.hpp:471</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a48668d0e1d2bfebef7c31abf285d9631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48668d0e1d2bfebef7c31abf285d9631">&#9670;&nbsp;</a></span>temp_inode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result&lt;<a class="el" href="classllfio__v2__xxx_1_1file__handle.html">file_handle</a>&gt; llfio_v2_xxx::temp_inode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllfio__v2__xxx_1_1path__handle.html">path_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>dirh</em> = <code><a class="el" href="namespacellfio__v2__xxx_1_1path__discovery.html#a2dd74ea752f3f511d58ccccdcac7f4fd">path_discovery::storage_backed_temporary_files_directory</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1handle.html#aa3930273a2d4cabbac309e0b75701dca">file_handle::mode</a>&#160;</td>
          <td class="paramname"><em>_mode</em> = <code><a class="el" href="classllfio__v2__xxx_1_1handle.html#aa3930273a2d4cabbac309e0b75701dcaaefb2a684e4afb7d55e6147fbe5a332ee">file_handle::mode::write</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1handle.html#aecd3a7db6cee3aec07d32fe6f99e6852">file_handle::caching</a>&#160;</td>
          <td class="paramname"><em>_caching</em> = <code><a class="el" href="classllfio__v2__xxx_1_1handle.html#aecd3a7db6cee3aec07d32fe6f99e6852ad5197d93c063a2b1e22d1630a39b7aef">file_handle::caching::temporary</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">file_handle::flag&#160;</td>
          <td class="paramname"><em>flags</em> = <code>file_handle::flag::none</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><em>Securely</em> create a file handle creating a temporary anonymous inode in the filesystem referred to by <em>dirpath</em>. The inode created has no name nor accessible path on the filing system and ceases to exist as soon as the last handle is closed, making it ideal for use as a temporary file where other processes do not need to have access to its contents via some path on the filing system (a classic use case is for backing shared memory maps).</p>
<dl class="section user"><dt>Errors returnable\n Any of the values POSIX open() or CreateFile() can return.</dt><dd></dd></dl>
<div class="fragment"><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;{</div>
<div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="namespacellfio__v2__xxx.html#a48668d0e1d2bfebef7c31abf285d9631">file_handle::temp_inode</a>(std::forward&lt;decltype(dirh)&gt;(dirh), std::forward&lt;decltype(_mode)&gt;(_mode), std::forward&lt;decltype(_caching)&gt;(_caching),</div>
<div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;                                 std::forward&lt;decltype(flags)&gt;(flags));</div>
<div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;}</div>
<div class="ttc" id="anamespacellfio__v2__xxx_html_a48668d0e1d2bfebef7c31abf285d9631"><div class="ttname"><a href="namespacellfio__v2__xxx.html#a48668d0e1d2bfebef7c31abf285d9631">llfio_v2_xxx::temp_inode</a></div><div class="ttdeci">result&lt; file_handle &gt; temp_inode(const path_handle &amp;dirh=path_discovery::storage_backed_temporary_files_directory(), file_handle::mode _mode=file_handle::mode::write, file_handle::caching _caching=file_handle::caching::temporary, file_handle::flag flags=file_handle::flag::none) noexcept</div><div class="ttdef"><b>Definition:</b> file_handle.hpp:489</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ab561e45415bf19b8cc6064b6b313d94d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab561e45415bf19b8cc6064b6b313d94d">&#9670;&nbsp;</a></span>to_win32_path()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result&lt;filesystem::path&gt; llfio_v2_xxx::to_win32_path </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllfio__v2__xxx_1_1fs__handle.html">fs_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacellfio__v2__xxx.html#abcb445e5dfcc0eb04ce49ac8af0bc89a">win32_path_namespace</a>&#160;</td>
          <td class="paramname"><em>mapping</em> = <code><a class="el" href="namespacellfio__v2__xxx.html#abcb445e5dfcc0eb04ce49ac8af0bc89aa100b8cad7cf2a56f6df78f171f97a1ec">win32_path_namespace::any</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps the current path of <code>h</code> into a form suitable for Win32 APIs. Passes through unmodified on POSIX, so you can use this in portable code. </p>
<dl class="section return"><dt>Returns</dt><dd>The mapped current path of <code>h</code>, which may have been validated to refer to the exact same inode via <code>.unique_id()</code> (see below). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>The handle whose <code>.current_path()</code> is to be mapped into a form suitable for Win32 APIs. </td></tr>
    <tr><td class="paramname">mapping</td><td>Which Win32 path namespace to map onto.</td></tr>
  </table>
  </dd>
</dl>
<p>This implementation may need to validate that the mapping of the current path of <code>h</code> onto the desired Win32 path namespace does indeed refer to the same file:</p>
<ul>
<li><code>win32_path_namespace::device</code> transforms <code>\!!\Device\...</code> =&gt; <code>\\.\...</code> and ensures that the mapped file's unique id matches the original, otherwise returning failure.</li>
<li><code>win32_path_namespace::dos</code> enumerates all the DOS devices on the system and what those map onto within the NT kernel namespace. This mapping is for obvious reasons quite slow.</li>
<li><code>win32_path_namespace::guid_volume</code> simply fetches the GUID of the volume of the handle, and constructs a valid Win32 path from that.</li>
<li><code>win32_path_namespace::any</code> means attempt <code>guid_volume</code> first, and if it fails (e.g. your file is on a network share) then it attempts <code>dos</code>. This semantic may change in the future, however any path emitted will always be a valid Win32 path. </li>
</ul>
<div class="fragment"><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;  {</div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;    (void) mapping;</div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;    <span class="keywordflow">return</span> h._get_handle().current_path();</div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a16ee1bea5a5791ecde266420e00fba81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16ee1bea5a5791ecde266420e00fba81">&#9670;&nbsp;</a></span>truncate() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result&lt;file_handle::extent_type&gt; llfio_v2_xxx::truncate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1file__handle.html">file_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">file_handle::extent_type&#160;</td>
          <td class="paramname"><em>newsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resize the current maximum permitted extent of the file to the given extent, avoiding any new allocation of physical storage where supported. Note that on extents based filing systems this will succeed even if there is insufficient free space on the storage medium.</p>
<dl class="section return"><dt>Returns</dt><dd>The bytes actually truncated to. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The object whose member function to call. </td></tr>
    <tr><td class="paramname">newsize</td><td>The bytes to truncate the file to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Errors returnable\n Any of the values POSIX ftruncate() or SetFileInformationByHandle() can return.</dt><dd></dd></dl>
<div class="fragment"><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;{</div>
<div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">self</span>.truncate(std::forward&lt;decltype(newsize)&gt;(newsize));</div>
<div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8231f6ba00d0d5840b47981ecc148e51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8231f6ba00d0d5840b47981ecc148e51">&#9670;&nbsp;</a></span>truncate() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result&lt;map_handle::size_type&gt; llfio_v2_xxx::truncate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1map__handle.html">map_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">map_handle::size_type&#160;</td>
          <td class="paramname"><em>newsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>permit_relocation</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resize the reservation of the memory map without changing the address (unless the map was zero sized, in which case a new address will be chosen).</p>
<p>If shrinking, address space is released on POSIX, and on Windows if the new size is zero. If the new size is zero, the address is set to null to prevent surprises. Windows does not support modifying existing mapped regions, so if the new size is not zero, the call will probably fail. Windows should let you truncate a previous extension however, if it is exact.</p>
<p>If expanding, an attempt is made to map in new reservation immediately after the current address reservation, thus extending the reservation. If anything else is mapped in after the current reservation, the function fails.</p>
<dl class="section note"><dt>Note</dt><dd>On all supported platforms apart from OS X, proprietary flags exist to avoid performing a map if a map extension cannot be immediately placed after the current map. On OS X, we hint where we'd like the new map to go, but if something is already there OS X will place the map elsewhere. In this situation, we delete the new map and return failure, which is inefficient, but there is nothing else we can do.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The bytes actually reserved. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The object whose member function to call. </td></tr>
    <tr><td class="paramname">newsize</td><td>The bytes to truncate the map reservation to. Rounded up to the nearest page size (POSIX) or 64Kb on Windows. </td></tr>
    <tr><td class="paramname">permit_relocation</td><td>Permit the address to change (some OSs provide a syscall for resizing a memory map). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Errors returnable\n Any of the values POSIX mremap(), mmap(addr) or VirtualAlloc(addr) can return.</dt><dd></dd></dl>
<div class="fragment"><div class="line"><a name="l01161"></a><span class="lineno"> 1161</span>&#160;{</div>
<div class="line"><a name="l01162"></a><span class="lineno"> 1162</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">self</span>.truncate(std::forward&lt;decltype(newsize)&gt;(newsize), std::forward&lt;decltype(permit_relocation)&gt;(permit_relocation));</div>
<div class="line"><a name="l01163"></a><span class="lineno"> 1163</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa6b0c71dfe04ceae64818d4c91d05537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6b0c71dfe04ceae64818d4c91d05537">&#9670;&nbsp;</a></span>truncate() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result&lt;section_handle::extent_type&gt; llfio_v2_xxx::truncate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1section__handle.html">section_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">section_handle::extent_type&#160;</td>
          <td class="paramname"><em>newsize</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resize the current maximum permitted extent of the memory section to the given extent. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The object whose member function to call. </td></tr>
    <tr><td class="paramname">newsize</td><td>The new size of the memory section, which cannot be zero. Specify zero to use <code>backing.maximum_extent()</code>. This cannot exceed the size of any backing file used if that file is not writable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Errors returnable\n Any of the values NtExtendSection() or ftruncate() can return.</dt><dd></dd></dl>
<div class="fragment"><div class="line"><a name="l01083"></a><span class="lineno"> 1083</span>&#160;{</div>
<div class="line"><a name="l01084"></a><span class="lineno"> 1084</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">self</span>.truncate(std::forward&lt;decltype(newsize)&gt;(newsize));</div>
<div class="line"><a name="l01085"></a><span class="lineno"> 1085</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aba506997f2999cabbe0a7bd2a1d3b6e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba506997f2999cabbe0a7bd2a1d3b6e0">&#9670;&nbsp;</a></span>uniquely_named_directory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result&lt;<a class="el" href="classllfio__v2__xxx_1_1directory__handle.html">directory_handle</a>&gt; llfio_v2_xxx::uniquely_named_directory </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllfio__v2__xxx_1_1path__handle.html">path_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>dirpath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1handle.html#aa3930273a2d4cabbac309e0b75701dca">directory_handle::mode</a>&#160;</td>
          <td class="paramname"><em>_mode</em> = <code><a class="el" href="classllfio__v2__xxx_1_1handle.html#aa3930273a2d4cabbac309e0b75701dcaaefb2a684e4afb7d55e6147fbe5a332ee">directory_handle::mode::write</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1handle.html#aecd3a7db6cee3aec07d32fe6f99e6852">directory_handle::caching</a>&#160;</td>
          <td class="paramname"><em>_caching</em> = <code><a class="el" href="classllfio__v2__xxx_1_1handle.html#aecd3a7db6cee3aec07d32fe6f99e6852ad5197d93c063a2b1e22d1630a39b7aef">directory_handle::caching::temporary</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">directory_handle::flag&#160;</td>
          <td class="paramname"><em>flags</em> = <code>directory_handle::flag::none</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a directory handle creating a randomly named file on a path. The file is opened exclusively with <code>creation::only_if_not_exist</code> so it will never collide with nor overwrite any existing entry.</p>
<dl class="section user"><dt>Errors returnable\n Any of the values POSIX open() or CreateFile() can return.</dt><dd></dd></dl>
<div class="fragment"><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;{</div>
<div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="namespacellfio__v2__xxx.html#aba506997f2999cabbe0a7bd2a1d3b6e0">directory_handle::uniquely_named_directory</a>(std::forward&lt;decltype(dirpath)&gt;(dirpath), std::forward&lt;decltype(_mode)&gt;(_mode),</div>
<div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;                                                    std::forward&lt;decltype(_caching)&gt;(_caching), std::forward&lt;decltype(flags)&gt;(flags));</div>
<div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;}</div>
<div class="ttc" id="anamespacellfio__v2__xxx_html_aba506997f2999cabbe0a7bd2a1d3b6e0"><div class="ttname"><a href="namespacellfio__v2__xxx.html#aba506997f2999cabbe0a7bd2a1d3b6e0">llfio_v2_xxx::uniquely_named_directory</a></div><div class="ttdeci">result&lt; directory_handle &gt; uniquely_named_directory(const path_handle &amp;dirpath, directory_handle::mode _mode=directory_handle::mode::write, directory_handle::caching _caching=directory_handle::caching::temporary, directory_handle::flag flags=directory_handle::flag::none) noexcept</div><div class="ttdef"><b>Definition:</b> directory_handle.hpp:480</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a5d9582bf6887848cd9fc363a282a1c21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d9582bf6887848cd9fc363a282a1c21">&#9670;&nbsp;</a></span>uniquely_named_file()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result&lt;<a class="el" href="classllfio__v2__xxx_1_1file__handle.html">file_handle</a>&gt; llfio_v2_xxx::uniquely_named_file </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllfio__v2__xxx_1_1path__handle.html">path_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>dirpath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1handle.html#aa3930273a2d4cabbac309e0b75701dca">file_handle::mode</a>&#160;</td>
          <td class="paramname"><em>_mode</em> = <code><a class="el" href="classllfio__v2__xxx_1_1handle.html#aa3930273a2d4cabbac309e0b75701dcaaefb2a684e4afb7d55e6147fbe5a332ee">file_handle::mode::write</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1handle.html#aecd3a7db6cee3aec07d32fe6f99e6852">file_handle::caching</a>&#160;</td>
          <td class="paramname"><em>_caching</em> = <code><a class="el" href="classllfio__v2__xxx_1_1handle.html#aecd3a7db6cee3aec07d32fe6f99e6852ad5197d93c063a2b1e22d1630a39b7aef">file_handle::caching::temporary</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">file_handle::flag&#160;</td>
          <td class="paramname"><em>flags</em> = <code>file_handle::flag::none</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a file handle creating a randomly named file on a path. The file is opened exclusively with <code>creation::only_if_not_exist</code> so it will never collide with nor overwrite any existing file. Note also that caching defaults to temporary which hints to the OS to only flush changes to physical storage as lately as possible.</p>
<dl class="section user"><dt>Errors returnable\n Any of the values POSIX open() or CreateFile() can return.</dt><dd></dd></dl>
<div class="fragment"><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;{</div>
<div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="namespacellfio__v2__xxx.html#a5d9582bf6887848cd9fc363a282a1c21">file_handle::uniquely_named_file</a>(std::forward&lt;decltype(dirpath)&gt;(dirpath), std::forward&lt;decltype(_mode)&gt;(_mode),</div>
<div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;                                          std::forward&lt;decltype(_caching)&gt;(_caching), std::forward&lt;decltype(flags)&gt;(flags));</div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;}</div>
<div class="ttc" id="anamespacellfio__v2__xxx_html_a5d9582bf6887848cd9fc363a282a1c21"><div class="ttname"><a href="namespacellfio__v2__xxx.html#a5d9582bf6887848cd9fc363a282a1c21">llfio_v2_xxx::uniquely_named_file</a></div><div class="ttdeci">result&lt; file_handle &gt; uniquely_named_file(const path_handle &amp;dirpath, file_handle::mode _mode=file_handle::mode::write, file_handle::caching _caching=file_handle::caching::temporary, file_handle::flag flags=file_handle::flag::none) noexcept</div><div class="ttdef"><b>Definition:</b> file_handle.hpp:449</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a3c20b46beeb225aa63ade3dc42e73362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c20b46beeb225aa63ade3dc42e73362">&#9670;&nbsp;</a></span>unlink()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result&lt;void&gt; llfio_v2_xxx::unlink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html">fs_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllfio__v2__xxx_1_1deadline.html">deadline</a>&#160;</td>
          <td class="paramname"><em>d</em> = <code>std::chrono::seconds(30)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unlinks the current path of this open handle, causing its entry to immediately disappear from the filing system. On Windows unless <code>flag::win_disable_unlink_emulation</code> is set, this behaviour is simulated by renaming the file to something random and setting its delete-on-last-close flag. Note that Windows may prevent the renaming of a file in use by another process, if so it will NOT be renamed. After the next handle to that file closes, it will become permanently unopenable by anyone else until the last handle is closed, whereupon the entry will be eventually removed by the operating system.</p>
<dl class="section warning"><dt>Warning</dt><dd>Some operating systems provide a race free syscall for unlinking an open handle (Windows). On all other operating systems this call is <b>racy</b> and can result in the wrong file entry being unlinked. Note that unless <code>flag::disable_safety_unlinks</code> is set, this implementation opens a <code>path_handle</code> to the containing directory first, then checks that the item about to be unlinked has the same inode as the open file handle. It will retry this matching until success until the deadline given. This should prevent most unmalicious accidental loss of data.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The object whose member function to call. </td></tr>
    <tr><td class="paramname">d</td><td>The deadline by which the matching of the containing directory to the open handle's inode must succeed, else <code>errc::timed_out</code> will be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Memory Allocations\n Except on platforms with race free syscalls for unlinking open handles (Windows), calls</dt><dd><code>current_path()</code> and thus is both expensive and calls malloc many times. On Windows, also calls <code>current_path()</code> if <code>flag::disable_safety_unlinks</code> is not set. </dd></dl>
<div class="fragment"><div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;{</div>
<div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">self</span>.unlink(std::forward&lt;decltype(d)&gt;(d));</div>
<div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a59a3e33e0a5f68b867049fd640059b4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59a3e33e0a5f68b867049fd640059b4d">&#9670;&nbsp;</a></span>write() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structllfio__v2__xxx_1_1byte__io__multiplexer_1_1io__result.html">byte_io_handle::io_result</a>&lt;byte_io_handle::const_buffers_type&gt; llfio_v2_xxx::write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1byte__io__handle.html">byte_io_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllfio__v2__xxx_1_1byte__io__multiplexer_1_1io__request.html">byte_io_handle::io_request</a>&lt; byte_io_handle::const_buffers_type &gt;&#160;</td>
          <td class="paramname"><em>reqs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllfio__v2__xxx_1_1deadline.html">deadline</a>&#160;</td>
          <td class="paramname"><em>d</em> = <code><a class="el" href="structllfio__v2__xxx_1_1deadline.html">deadline</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write data to the open handle. </p>
<dl class="section warning"><dt>Warning</dt><dd>Depending on the implementation backend, not all of the buffers input may be written and the some buffers at the end of the returned buffers may return with zero bytes written. For example, with a zeroed deadline, some backends may only consume as many buffers as the system has available write slots for, thus for those backends this call is "non-blocking" in the sense that it will return immediately even if it could not schedule a single buffer write. Another example is that some implementations will not auto-extend the length of a file when a write exceeds the maximum extent, you will need to issue a <code>truncate(newsize)</code> first.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The buffers written, which may not be the buffers input. The size of each scatter-gather buffer is updated with the number of bytes of that buffer transferred. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The object whose member function to call. </td></tr>
    <tr><td class="paramname">reqs</td><td>A scatter-gather and offset request. </td></tr>
    <tr><td class="paramname">d</td><td>An optional deadline by which the i/o must complete, else it is cancelled. Note function may return significantly after this deadline if the i/o takes long to cancel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Errors returnable\n Any of the values POSIX write() can return, errc::timed_out, errc::operation_canceled. errc::not_supported may be</dt><dd>returned if deadline i/o is not possible with this particular handle configuration (e.g. writing to regular files on POSIX or writing to a non-overlapped HANDLE on Windows). </dd></dl>
<dl class="section user"><dt>Memory Allocations\n The default synchronous implementation in file_handle performs no memory allocation.</dt><dd></dd></dl>
<div class="fragment"><div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;{</div>
<div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">self</span>.write(std::forward&lt;decltype(reqs)&gt;(reqs), std::forward&lt;decltype(d)&gt;(d));</div>
<div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a681ed7e98ac17e6bb336b9287365141b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a681ed7e98ac17e6bb336b9287365141b">&#9670;&nbsp;</a></span>write() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structllfio__v2__xxx_1_1byte__io__multiplexer_1_1io__result.html">map_handle::io_result</a>&lt;map_handle::const_buffers_type&gt; llfio_v2_xxx::write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1map__handle.html">map_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllfio__v2__xxx_1_1byte__io__multiplexer_1_1io__request.html">map_handle::io_request</a>&lt; map_handle::const_buffers_type &gt;&#160;</td>
          <td class="paramname"><em>reqs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllfio__v2__xxx_1_1deadline.html">deadline</a>&#160;</td>
          <td class="paramname"><em>d</em> = <code><a class="el" href="structllfio__v2__xxx_1_1deadline.html">deadline</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write data to the mapped view. </p>
<dl class="section return"><dt>Returns</dt><dd>The buffers written, which will never be the buffers input because they will point at where the data was copied into the mapped view. The size of each scatter-gather buffer is updated with the number of bytes of that buffer transferred. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The object whose member function to call. </td></tr>
    <tr><td class="paramname">reqs</td><td>A scatter-gather and offset request. </td></tr>
    <tr><td class="paramname">d</td><td>Ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Errors returnable\n None, though the various signals and structured exception throws common to using memory maps may occur.</dt><dd></dd></dl>
<dl class="section user"><dt>Memory Allocations\n None.</dt><dd></dd></dl>
<div class="fragment"><div class="line"><a name="l01193"></a><span class="lineno"> 1193</span>&#160;{</div>
<div class="line"><a name="l01194"></a><span class="lineno"> 1194</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">self</span>.write(std::forward&lt;decltype(reqs)&gt;(reqs), std::forward&lt;decltype(d)&gt;(d));</div>
<div class="line"><a name="l01195"></a><span class="lineno"> 1195</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad0fb15649a46da0d75b5797bfda8dc2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0fb15649a46da0d75b5797bfda8dc2e">&#9670;&nbsp;</a></span>zero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result&lt;file_handle::extent_type&gt; llfio_v2_xxx::zero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1file__handle.html">file_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">file_handle::extent_type&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">file_handle::extent_type&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllfio__v2__xxx_1_1deadline.html">deadline</a>&#160;</td>
          <td class="paramname"><em>d</em> = <code><a class="el" href="structllfio__v2__xxx_1_1deadline.html">deadline</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Efficiently zero, and possibly deallocate, data on storage. </p>
<p>On most major operating systems and with recent filing systems which are "extents based", one can deallocate the physical storage of a file, causing the space deallocated to appear all bits zero. This call attempts to deallocate whole pages (usually 4Kb) entirely, and memset's any excess to all bits zero. This call works on most Linux filing systems with a recent kernel, Microsoft Windows with NTFS, and FreeBSD with ZFS. On other systems it simply writes zeros.</p>
<dl class="section return"><dt>Returns</dt><dd>The bytes zeroed. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The object whose member function to call. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset to start zeroing from. </td></tr>
    <tr><td class="paramname">bytes</td><td>The number of bytes to zero. </td></tr>
    <tr><td class="paramname">d</td><td>An optional deadline by which the i/o must complete, else it is cancelled. Note function may return significantly after this deadline if the i/o takes long to cancel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Errors returnable\n Any of the values POSIX write() can return, errc::timed_out, errc::operation_canceled. errc::not_supported may be</dt><dd>returned if deadline i/o is not possible with this particular handle configuration (e.g. writing to regular files on POSIX or writing to a non-overlapped HANDLE on Windows). </dd></dl>
<dl class="section user"><dt>Memory Allocations\n The default synchronous implementation in file_handle performs no memory allocation.</dt><dd></dd></dl>
<div class="fragment"><div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;{</div>
<div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">self</span>.zero(std::forward&lt;decltype(offset)&gt;(offset), std::forward&lt;decltype(bytes)&gt;(bytes), std::forward&lt;decltype(d)&gt;(d));</div>
<div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacellfio__v2__xxx.html">llfio_v2_xxx</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
