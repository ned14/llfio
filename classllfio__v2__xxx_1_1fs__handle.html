<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LLFIO: llfio_v2_xxx::fs_handle Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LLFIO<span id="projectnumber">&#160;v2.00</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classllfio__v2__xxx_1_1fs__handle.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classllfio__v2__xxx_1_1fs__handle-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">llfio_v2_xxx::fs_handle Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>A handle to something with a device and inode number.  
 <a href="classllfio__v2__xxx_1_1fs__handle.html#details">More...</a></p>

<p><code>#include &quot;fs_handle.hpp&quot;</code></p>
<div class="dynheader">
Inheritance diagram for llfio_v2_xxx::fs_handle:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classllfio__v2__xxx_1_1fs__handle.png" usemap="#llfio_5Fv2_5Fxxx::fs_5Fhandle_map" alt=""/>
  <map id="llfio_5Fv2_5Fxxx::fs_5Fhandle_map" name="llfio_5Fv2_5Fxxx::fs_5Fhandle_map">
<area href="classllfio__v2__xxx_1_1directory__handle.html" title="A handle to a directory which can be enumerated." alt="llfio_v2_xxx::directory_handle" shape="rect" coords="0,56,222,80"/>
<area href="classllfio__v2__xxx_1_1file__handle.html" title="A handle to a regular file or device." alt="llfio_v2_xxx::file_handle" shape="rect" coords="232,56,454,80"/>
<area href="classllfio__v2__xxx_1_1pipe__handle.html" title="A handle to a named or anonymous pipe." alt="llfio_v2_xxx::pipe_handle" shape="rect" coords="464,56,686,80"/>
<area href="classllfio__v2__xxx_1_1symlink__handle.html" title="A handle to an inode which redirects to a different path." alt="llfio_v2_xxx::symlink_handle" shape="rect" coords="696,56,918,80"/>
<area href="classllfio__v2__xxx_1_1fast__random__file__handle.html" title="A handle to synthesised, non-cryptographic, pseudo-random data." alt="llfio_v2_xxx::fast_random_file_handle" shape="rect" coords="116,112,338,136"/>
<area href="classllfio__v2__xxx_1_1mapped__file__handle.html" title="A memory mapped regular file or device." alt="llfio_v2_xxx::mapped_file_handle" shape="rect" coords="348,112,570,136"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac43e0058de471b7b8c4a9f08e621038f" id="r_ac43e0058de471b7b8c4a9f08e621038f"><td class="memItemLeft" align="right" valign="top"><a id="ac43e0058de471b7b8c4a9f08e621038f" name="ac43e0058de471b7b8c4a9f08e621038f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>dev_t</b> = uint64_t</td></tr>
<tr class="separator:ac43e0058de471b7b8c4a9f08e621038f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6716da1bdd65c32c91eb3e4f34ccde98" id="r_a6716da1bdd65c32c91eb3e4f34ccde98"><td class="memItemLeft" align="right" valign="top"><a id="a6716da1bdd65c32c91eb3e4f34ccde98" name="a6716da1bdd65c32c91eb3e4f34ccde98"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ino_t</b> = uint64_t</td></tr>
<tr class="separator:a6716da1bdd65c32c91eb3e4f34ccde98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcd8c8171f4e561620864295e8d5879b" id="r_abcd8c8171f4e561620864295e8d5879b"><td class="memItemLeft" align="right" valign="top"><a id="abcd8c8171f4e561620864295e8d5879b" name="abcd8c8171f4e561620864295e8d5879b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>path_view_type</b> = <a class="el" href="classllfio__v2__xxx_1_1path__view.html">path_view</a></td></tr>
<tr class="memdesc:abcd8c8171f4e561620864295e8d5879b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The path view type used by this handle. <br /></td></tr>
<tr class="separator:abcd8c8171f4e561620864295e8d5879b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a65884346740af7fb4648c79d44a750" id="r_a1a65884346740af7fb4648c79d44a750"><td class="memItemLeft" align="right" valign="top"><a id="a1a65884346740af7fb4648c79d44a750" name="a1a65884346740af7fb4648c79d44a750"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>unique_id_type</b> = QUICKCPPLIB_NAMESPACE::integers128::uint128</td></tr>
<tr class="memdesc:a1a65884346740af7fb4648c79d44a750"><td class="mdescLeft">&#160;</td><td class="mdescRight">The unique identifier type used by this handle. <br /></td></tr>
<tr class="separator:a1a65884346740af7fb4648c79d44a750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab82a83c5e44659e01a2218f0af41bde7" id="r_ab82a83c5e44659e01a2218f0af41bde7"><td class="memItemLeft" align="right" valign="top"><a id="ab82a83c5e44659e01a2218f0af41bde7" name="ab82a83c5e44659e01a2218f0af41bde7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>unique_id_type_hasher</b> = QUICKCPPLIB_NAMESPACE::integers128::uint128_hasher</td></tr>
<tr class="memdesc:ab82a83c5e44659e01a2218f0af41bde7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A hasher for the unique identifier type used by this handle. <br /></td></tr>
<tr class="separator:ab82a83c5e44659e01a2218f0af41bde7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afbebcaabf0282923ff76f6a83d3b4073" id="r_afbebcaabf0282923ff76f6a83d3b4073"><td class="memItemLeft" align="right" valign="top"><a id="afbebcaabf0282923ff76f6a83d3b4073" name="afbebcaabf0282923ff76f6a83d3b4073"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>fs_handle</b> (const <a class="el" href="classllfio__v2__xxx_1_1fs__handle.html">fs_handle</a> &amp;)=delete</td></tr>
<tr class="memdesc:afbebcaabf0282923ff76f6a83d3b4073"><td class="mdescLeft">&#160;</td><td class="mdescRight">No copy construction (use <code>clone()</code>) <br /></td></tr>
<tr class="separator:afbebcaabf0282923ff76f6a83d3b4073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43d237ebe8efc8682f4c31c2aff68aff" id="r_a43d237ebe8efc8682f4c31c2aff68aff"><td class="memItemLeft" align="right" valign="top"><a id="a43d237ebe8efc8682f4c31c2aff68aff" name="a43d237ebe8efc8682f4c31c2aff68aff"></a>
<a class="el" href="classllfio__v2__xxx_1_1fs__handle.html">fs_handle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classllfio__v2__xxx_1_1fs__handle.html">fs_handle</a> &amp;o)=delete</td></tr>
<tr class="memdesc:a43d237ebe8efc8682f4c31c2aff68aff"><td class="mdescLeft">&#160;</td><td class="mdescRight">No copy assignment. <br /></td></tr>
<tr class="separator:a43d237ebe8efc8682f4c31c2aff68aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac24ed4cdb96690d7da95cd17b0f3d090" id="r_ac24ed4cdb96690d7da95cd17b0f3d090"><td class="memItemLeft" align="right" valign="top">dev_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#ac24ed4cdb96690d7da95cd17b0f3d090">st_dev</a> () const noexcept</td></tr>
<tr class="memdesc:ac24ed4cdb96690d7da95cd17b0f3d090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unless <code>flag::disable_safety_unlinks</code> is set, the device id of the file when opened.  <br /></td></tr>
<tr class="separator:ac24ed4cdb96690d7da95cd17b0f3d090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad6465d30ee438b860ccc59c0e0fc4dc" id="r_aad6465d30ee438b860ccc59c0e0fc4dc"><td class="memItemLeft" align="right" valign="top">ino_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#aad6465d30ee438b860ccc59c0e0fc4dc">st_ino</a> () const noexcept</td></tr>
<tr class="memdesc:aad6465d30ee438b860ccc59c0e0fc4dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unless <code>flag::disable_safety_unlinks</code> is set, the inode of the file when opened. When combined with st_dev(), forms a unique identifer on this system.  <br /></td></tr>
<tr class="separator:aad6465d30ee438b860ccc59c0e0fc4dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9793fe40564fda2437783488bd51b9f1" id="r_a9793fe40564fda2437783488bd51b9f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#a1a65884346740af7fb4648c79d44a750">unique_id_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#a9793fe40564fda2437783488bd51b9f1">unique_id</a> () const noexcept</td></tr>
<tr class="memdesc:a9793fe40564fda2437783488bd51b9f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A unique identifier for this handle across the entire system. Can be used in hash tables etc.  <br /></td></tr>
<tr class="separator:a9793fe40564fda2437783488bd51b9f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a4bc903ac41d8fcca6b8c55c6bcc76" id="r_a79a4bc903ac41d8fcca6b8c55c6bcc76"><td class="memItemLeft" align="right" valign="top">virtual result&lt; <a class="el" href="classllfio__v2__xxx_1_1path__handle.html">path_handle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#a79a4bc903ac41d8fcca6b8c55c6bcc76">parent_path_handle</a> (<a class="el" href="structllfio__v2__xxx_1_1deadline.html">deadline</a> d=std::chrono::seconds(30)) const noexcept</td></tr>
<tr class="memdesc:a79a4bc903ac41d8fcca6b8c55c6bcc76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a handle to the path <b>currently</b> containing this handle's file entry.  <br /></td></tr>
<tr class="separator:a79a4bc903ac41d8fcca6b8c55c6bcc76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eeaf9d77a1279b4f0d3062de509f77f" id="r_a1eeaf9d77a1279b4f0d3062de509f77f"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a1eeaf9d77a1279b4f0d3062de509f77f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#a1eeaf9d77a1279b4f0d3062de509f77f">try_parent_path_handle</a> (Args &amp;&amp;... args) noexcept</td></tr>
<tr class="separator:a1eeaf9d77a1279b4f0d3062de509f77f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ea4bd2d5a66fbde4cdbfe463166a4f" id="r_a41ea4bd2d5a66fbde4cdbfe463166a4f"><td class="memTemplParams" colspan="2">template&lt;class... Args, class Rep , class Period &gt; </td></tr>
<tr class="memitem:a41ea4bd2d5a66fbde4cdbfe463166a4f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#a41ea4bd2d5a66fbde4cdbfe463166a4f">try_parent_path_handle_for</a> (Args &amp;&amp;... args, const std::chrono::duration&lt; Rep, Period &gt; &amp;duration) noexcept</td></tr>
<tr class="separator:a41ea4bd2d5a66fbde4cdbfe463166a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb1fe8c7901382307d84848fdc0afcb" id="r_acbb1fe8c7901382307d84848fdc0afcb"><td class="memTemplParams" colspan="2">template&lt;class... Args, class Clock , class Duration &gt; </td></tr>
<tr class="memitem:acbb1fe8c7901382307d84848fdc0afcb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#acbb1fe8c7901382307d84848fdc0afcb">try_parent_path_handle_until</a> (Args &amp;&amp;... args, const std::chrono::time_point&lt; Clock, Duration &gt; &amp;timeout) noexcept</td></tr>
<tr class="separator:acbb1fe8c7901382307d84848fdc0afcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8574050f1988a925322d5a60a84c714b" id="r_a8574050f1988a925322d5a60a84c714b"><td class="memItemLeft" align="right" valign="top">virtual result&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#a8574050f1988a925322d5a60a84c714b">relink</a> (const <a class="el" href="classllfio__v2__xxx_1_1path__handle.html">path_handle</a> &amp;base, <a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#abcd8c8171f4e561620864295e8d5879b">path_view_type</a> <a class="el" href="namespacellfio__v2__xxx.html#af059edd6f3f0aac8e118bf371907ecf6">path</a>, bool atomic_replace=true, <a class="el" href="structllfio__v2__xxx_1_1deadline.html">deadline</a> d=std::chrono::seconds(30)) noexcept</td></tr>
<tr class="memdesc:a8574050f1988a925322d5a60a84c714b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relinks the current path of this open handle to the new path specified. If <code>atomic_replace</code> is true, the relink <b>atomically</b> and silently replaces any item at the new path specified. This operation is both atomic and matching POSIX behaviour even on Microsoft Windows where no Win32 API can match POSIX semantics.  <br /></td></tr>
<tr class="separator:a8574050f1988a925322d5a60a84c714b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f5f9892f6652359f2330bf6d9b89e17" id="r_a7f5f9892f6652359f2330bf6d9b89e17"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a7f5f9892f6652359f2330bf6d9b89e17"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#a7f5f9892f6652359f2330bf6d9b89e17">try_relink</a> (Args &amp;&amp;... args) noexcept</td></tr>
<tr class="separator:a7f5f9892f6652359f2330bf6d9b89e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5565cd5f2fcbb9472b2a00795cc0bcc" id="r_af5565cd5f2fcbb9472b2a00795cc0bcc"><td class="memTemplParams" colspan="2">template&lt;class... Args, class Rep , class Period &gt; </td></tr>
<tr class="memitem:af5565cd5f2fcbb9472b2a00795cc0bcc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#af5565cd5f2fcbb9472b2a00795cc0bcc">try_relink_for</a> (Args &amp;&amp;... args, const std::chrono::duration&lt; Rep, Period &gt; &amp;duration) noexcept</td></tr>
<tr class="separator:af5565cd5f2fcbb9472b2a00795cc0bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc4e2ade67dfb9140007cc31f4b6b20" id="r_a1fc4e2ade67dfb9140007cc31f4b6b20"><td class="memTemplParams" colspan="2">template&lt;class... Args, class Clock , class Duration &gt; </td></tr>
<tr class="memitem:a1fc4e2ade67dfb9140007cc31f4b6b20"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#a1fc4e2ade67dfb9140007cc31f4b6b20">try_relink_until</a> (Args &amp;&amp;... args, const std::chrono::time_point&lt; Clock, Duration &gt; &amp;timeout) noexcept</td></tr>
<tr class="separator:a1fc4e2ade67dfb9140007cc31f4b6b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eda0c5e6795f31f98f74eb9063a70ed" id="r_a7eda0c5e6795f31f98f74eb9063a70ed"><td class="memItemLeft" align="right" valign="top">virtual result&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#a7eda0c5e6795f31f98f74eb9063a70ed">link</a> (const <a class="el" href="classllfio__v2__xxx_1_1path__handle.html">path_handle</a> &amp;base, <a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#abcd8c8171f4e561620864295e8d5879b">path_view_type</a> <a class="el" href="namespacellfio__v2__xxx.html#af059edd6f3f0aac8e118bf371907ecf6">path</a>, <a class="el" href="structllfio__v2__xxx_1_1deadline.html">deadline</a> d=std::chrono::seconds(30)) noexcept</td></tr>
<tr class="memdesc:a7eda0c5e6795f31f98f74eb9063a70ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Links the inode referred to by this open handle to the path specified. The current path of this open handle is not changed, unless it has no current path due to being unlinked.  <br /></td></tr>
<tr class="separator:a7eda0c5e6795f31f98f74eb9063a70ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43b812385c7fc8aae9e59838a1411bb" id="r_ad43b812385c7fc8aae9e59838a1411bb"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:ad43b812385c7fc8aae9e59838a1411bb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#ad43b812385c7fc8aae9e59838a1411bb">try_link</a> (Args &amp;&amp;... args) noexcept</td></tr>
<tr class="separator:ad43b812385c7fc8aae9e59838a1411bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65d73e0e89bac484ce40427b58dcfe53" id="r_a65d73e0e89bac484ce40427b58dcfe53"><td class="memTemplParams" colspan="2">template&lt;class... Args, class Rep , class Period &gt; </td></tr>
<tr class="memitem:a65d73e0e89bac484ce40427b58dcfe53"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#a65d73e0e89bac484ce40427b58dcfe53">try_link_for</a> (Args &amp;&amp;... args, const std::chrono::duration&lt; Rep, Period &gt; &amp;duration) noexcept</td></tr>
<tr class="separator:a65d73e0e89bac484ce40427b58dcfe53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2703814c7599d2081ca10763bbeba4a" id="r_ad2703814c7599d2081ca10763bbeba4a"><td class="memTemplParams" colspan="2">template&lt;class... Args, class Clock , class Duration &gt; </td></tr>
<tr class="memitem:ad2703814c7599d2081ca10763bbeba4a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#ad2703814c7599d2081ca10763bbeba4a">try_link_until</a> (Args &amp;&amp;... args, const std::chrono::time_point&lt; Clock, Duration &gt; &amp;timeout) noexcept</td></tr>
<tr class="separator:ad2703814c7599d2081ca10763bbeba4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4f17a0b437d430a37d3875d8570bf2" id="r_a7b4f17a0b437d430a37d3875d8570bf2"><td class="memItemLeft" align="right" valign="top">virtual result&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#a7b4f17a0b437d430a37d3875d8570bf2">unlink</a> (<a class="el" href="structllfio__v2__xxx_1_1deadline.html">deadline</a> d=std::chrono::seconds(30)) noexcept</td></tr>
<tr class="memdesc:a7b4f17a0b437d430a37d3875d8570bf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlinks the current path of this open handle, causing its entry to immediately disappear from the filing system.  <br /></td></tr>
<tr class="separator:a7b4f17a0b437d430a37d3875d8570bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f77a249baf4e0c5de2172669a7724d7" id="r_a7f77a249baf4e0c5de2172669a7724d7"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a7f77a249baf4e0c5de2172669a7724d7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#a7f77a249baf4e0c5de2172669a7724d7">try_unlink</a> (Args &amp;&amp;... args) noexcept</td></tr>
<tr class="separator:a7f77a249baf4e0c5de2172669a7724d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a209de025a2d3e202a61c50b52d43f2af" id="r_a209de025a2d3e202a61c50b52d43f2af"><td class="memTemplParams" colspan="2">template&lt;class... Args, class Rep , class Period &gt; </td></tr>
<tr class="memitem:a209de025a2d3e202a61c50b52d43f2af"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#a209de025a2d3e202a61c50b52d43f2af">try_unlink_for</a> (Args &amp;&amp;... args, const std::chrono::duration&lt; Rep, Period &gt; &amp;duration) noexcept</td></tr>
<tr class="separator:a209de025a2d3e202a61c50b52d43f2af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c4133fef23811abcb01e1faf2b19d3" id="r_ae9c4133fef23811abcb01e1faf2b19d3"><td class="memTemplParams" colspan="2">template&lt;class... Args, class Clock , class Duration &gt; </td></tr>
<tr class="memitem:ae9c4133fef23811abcb01e1faf2b19d3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#ae9c4133fef23811abcb01e1faf2b19d3">try_unlink_until</a> (Args &amp;&amp;... args, const std::chrono::time_point&lt; Clock, Duration &gt; &amp;timeout) noexcept</td></tr>
<tr class="separator:ae9c4133fef23811abcb01e1faf2b19d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2899c3cabc9101bbd1eca895668a2d83" id="r_a2899c3cabc9101bbd1eca895668a2d83"><td class="memItemLeft" align="right" valign="top">virtual result&lt; span&lt; <a class="el" href="classllfio__v2__xxx_1_1path__view__component.html">path_view_component</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#a2899c3cabc9101bbd1eca895668a2d83">list_extended_attributes</a> (span&lt; byte &gt; tofill) const noexcept</td></tr>
<tr class="memdesc:a2899c3cabc9101bbd1eca895668a2d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the supplied buffer with the names of all extended attributes set on this file or directory, returning a span of path view components.  <br /></td></tr>
<tr class="separator:a2899c3cabc9101bbd1eca895668a2d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421c7f47706ed774d98cdbcc3b580d9c" id="r_a421c7f47706ed774d98cdbcc3b580d9c"><td class="memItemLeft" align="right" valign="top">virtual result&lt; span&lt; byte &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#a421c7f47706ed774d98cdbcc3b580d9c">get_extended_attribute</a> (span&lt; byte &gt; tofill, <a class="el" href="classllfio__v2__xxx_1_1path__view__component.html">path_view_component</a> name) const noexcept</td></tr>
<tr class="memdesc:a421c7f47706ed774d98cdbcc3b580d9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the value of an extended attribute set on this file or directory.  <br /></td></tr>
<tr class="separator:a421c7f47706ed774d98cdbcc3b580d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf22bb7a215f7f150f57f0a77164026" id="r_a1bf22bb7a215f7f150f57f0a77164026"><td class="memItemLeft" align="right" valign="top">virtual result&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#a1bf22bb7a215f7f150f57f0a77164026">set_extended_attribute</a> (<a class="el" href="classllfio__v2__xxx_1_1path__view__component.html">path_view_component</a> name, span&lt; const byte &gt; value) noexcept</td></tr>
<tr class="memdesc:a1bf22bb7a215f7f150f57f0a77164026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of an extended attribute on this file or directory.  <br /></td></tr>
<tr class="separator:a1bf22bb7a215f7f150f57f0a77164026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bf5f372c10a6e643797bd763b0ed7e0" id="r_a7bf5f372c10a6e643797bd763b0ed7e0"><td class="memItemLeft" align="right" valign="top">virtual result&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#a7bf5f372c10a6e643797bd763b0ed7e0">remove_extended_attribute</a> (<a class="el" href="classllfio__v2__xxx_1_1path__view__component.html">path_view_component</a>) noexcept</td></tr>
<tr class="memdesc:a7bf5f372c10a6e643797bd763b0ed7e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the extended attribute set on this file or directory.  <br /></td></tr>
<tr class="separator:a7bf5f372c10a6e643797bd763b0ed7e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab77ab0e6128cc79fc88d27ab16b1dfe4" id="r_ab77ab0e6128cc79fc88d27ab16b1dfe4"><td class="memItemLeft" align="right" valign="top">result&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#ab77ab0e6128cc79fc88d27ab16b1dfe4">copy_extended_attributes</a> (const <a class="el" href="classllfio__v2__xxx_1_1fs__handle.html">fs_handle</a> &amp;src, bool replace_all_local_attributes=false) noexcept</td></tr>
<tr class="memdesc:ab77ab0e6128cc79fc88d27ab16b1dfe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the extended attributes from one entity to another, optionally replacing all the extended attributes on the destination.  <br /></td></tr>
<tr class="separator:ab77ab0e6128cc79fc88d27ab16b1dfe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:af11804f144a9c95b03ce431cdcf41148" id="r_af11804f144a9c95b03ce431cdcf41148"><td class="memItemLeft" align="right" valign="top"><a id="af11804f144a9c95b03ce431cdcf41148" name="af11804f144a9c95b03ce431cdcf41148"></a>
result&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_fetch_inode</b> () const noexcept</td></tr>
<tr class="memdesc:af11804f144a9c95b03ce431cdcf41148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill in _devid and _inode from the handle via fstat() <br /></td></tr>
<tr class="separator:af11804f144a9c95b03ce431cdcf41148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9a9c3dc7270404d6c1e645aa353bd80" id="r_ab9a9c3dc7270404d6c1e645aa353bd80"><td class="memItemLeft" align="right" valign="top"><a id="ab9a9c3dc7270404d6c1e645aa353bd80" name="ab9a9c3dc7270404d6c1e645aa353bd80"></a>
virtual const <a class="el" href="classllfio__v2__xxx_1_1handle.html">handle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>_get_handle</b> () const noexcept=0</td></tr>
<tr class="separator:ab9a9c3dc7270404d6c1e645aa353bd80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae687c2e19c1a05a74155e1a62d84d27" id="r_aae687c2e19c1a05a74155e1a62d84d27"><td class="memItemLeft" align="right" valign="top"><a id="aae687c2e19c1a05a74155e1a62d84d27" name="aae687c2e19c1a05a74155e1a62d84d27"></a>
virtual result&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_replace_handle</b> (<a class="el" href="classllfio__v2__xxx_1_1handle.html">handle</a> &amp;&amp;o) noexcept=0</td></tr>
<tr class="separator:aae687c2e19c1a05a74155e1a62d84d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d2070f6019c86e19de3707bf59ffa97" id="r_a1d2070f6019c86e19de3707bf59ffa97"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#a1d2070f6019c86e19de3707bf59ffa97">fs_handle</a> ()</td></tr>
<tr class="memdesc:a1d2070f6019c86e19de3707bf59ffa97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="separator:a1d2070f6019c86e19de3707bf59ffa97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a282f0296cda08ad5ce2f9add2c16a77d" id="r_a282f0296cda08ad5ce2f9add2c16a77d"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#a282f0296cda08ad5ce2f9add2c16a77d">fs_handle</a> (dev_t devid, ino_t inode)</td></tr>
<tr class="memdesc:a282f0296cda08ad5ce2f9add2c16a77d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a handle.  <br /></td></tr>
<tr class="separator:a282f0296cda08ad5ce2f9add2c16a77d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69cc7b561e6ef3a54ccfb2c4743e5c6f" id="r_a69cc7b561e6ef3a54ccfb2c4743e5c6f"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#a69cc7b561e6ef3a54ccfb2c4743e5c6f">fs_handle</a> (<a class="el" href="classllfio__v2__xxx_1_1fs__handle.html">fs_handle</a> &amp;&amp;o) noexcept</td></tr>
<tr class="memdesc:a69cc7b561e6ef3a54ccfb2c4743e5c6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implicit move construction of fs_handle permitted.  <br /></td></tr>
<tr class="separator:a69cc7b561e6ef3a54ccfb2c4743e5c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2182c799ac54baa85ff4d1e06b04528a" id="r_a2182c799ac54baa85ff4d1e06b04528a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html">fs_handle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#a2182c799ac54baa85ff4d1e06b04528a">operator=</a> (<a class="el" href="classllfio__v2__xxx_1_1fs__handle.html">fs_handle</a> &amp;&amp;o) noexcept</td></tr>
<tr class="memdesc:a2182c799ac54baa85ff4d1e06b04528a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment of fs_handle permitted.  <br /></td></tr>
<tr class="separator:a2182c799ac54baa85ff4d1e06b04528a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a4d20a64cf182162a49962ed25d2126b3" id="r_a4d20a64cf182162a49962ed25d2126b3"><td class="memItemLeft" align="right" valign="top">dev_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#a4d20a64cf182162a49962ed25d2126b3">_devid</a> {0}</td></tr>
<tr class="separator:a4d20a64cf182162a49962ed25d2126b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8454764db3cd47e65ec7853b9cb0b3fa" id="r_a8454764db3cd47e65ec7853b9cb0b3fa"><td class="memItemLeft" align="right" valign="top">ino_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#a8454764db3cd47e65ec7853b9cb0b3fa">_inode</a> {0}</td></tr>
<tr class="separator:a8454764db3cd47e65ec7853b9cb0b3fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:af0fa5755fb5adfde2ebd8de60aa16c3c" id="r_af0fa5755fb5adfde2ebd8de60aa16c3c"><td class="memItemLeft" align="right" valign="top">result&lt; filesystem::path &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#af0fa5755fb5adfde2ebd8de60aa16c3c">to_win32_path</a> (const <a class="el" href="classllfio__v2__xxx_1_1fs__handle.html">fs_handle</a> &amp;h, <a class="el" href="namespacellfio__v2__xxx.html#abcb445e5dfcc0eb04ce49ac8af0bc89a">win32_path_namespace</a> mapping) noexcept</td></tr>
<tr class="memdesc:af0fa5755fb5adfde2ebd8de60aa16c3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps the current path of <code>h</code> into a form suitable for Win32 APIs. Passes through unmodified on POSIX, so you can use this in portable code.  <br /></td></tr>
<tr class="separator:af0fa5755fb5adfde2ebd8de60aa16c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A handle to something with a device and inode number. </p>
<dl class="section see"><dt>See also</dt><dd><code>algorithm::cached_parent_handle_adapter&lt;T&gt;</code> </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1d2070f6019c86e19de3707bf59ffa97" name="a1d2070f6019c86e19de3707bf59ffa97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d2070f6019c86e19de3707bf59ffa97">&#9670;&#160;</a></span>fs_handle() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr llfio_v2_xxx::fs_handle::fs_handle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<div class="fragment"><div class="line"><span class="lineno">  174</span>{}  <span class="comment">// NOLINT</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a282f0296cda08ad5ce2f9add2c16a77d" name="a282f0296cda08ad5ce2f9add2c16a77d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a282f0296cda08ad5ce2f9add2c16a77d">&#9670;&#160;</a></span>fs_handle() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr llfio_v2_xxx::fs_handle::fs_handle </td>
          <td>(</td>
          <td class="paramtype">dev_t&#160;</td>
          <td class="paramname"><em>devid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ino_t&#160;</td>
          <td class="paramname"><em>inode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a handle. </p>
<div class="fragment"><div class="line"><span class="lineno">  178</span>      : _devid(devid)</div>
<div class="line"><span class="lineno">  179</span>      , _inode(inode)</div>
<div class="line"><span class="lineno">  180</span>  {</div>
<div class="line"><span class="lineno">  181</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a69cc7b561e6ef3a54ccfb2c4743e5c6f" name="a69cc7b561e6ef3a54ccfb2c4743e5c6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69cc7b561e6ef3a54ccfb2c4743e5c6f">&#9670;&#160;</a></span>fs_handle() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr llfio_v2_xxx::fs_handle::fs_handle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html">fs_handle</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implicit move construction of fs_handle permitted. </p>
<div class="fragment"><div class="line"><span class="lineno">  184</span>      : _devid(o._devid)</div>
<div class="line"><span class="lineno">  185</span>      , _inode(o._inode)</div>
<div class="line"><span class="lineno">  186</span>  {</div>
<div class="line"><span class="lineno">  187</span>    o._devid = 0;</div>
<div class="line"><span class="lineno">  188</span>    o._inode = 0;</div>
<div class="line"><span class="lineno">  189</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab77ab0e6128cc79fc88d27ab16b1dfe4" name="ab77ab0e6128cc79fc88d27ab16b1dfe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab77ab0e6128cc79fc88d27ab16b1dfe4">&#9670;&#160;</a></span>copy_extended_attributes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result&lt; size_t &gt; llfio_v2_xxx::fs_handle::copy_extended_attributes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllfio__v2__xxx_1_1fs__handle.html">fs_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>replace_all_local_attributes</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the extended attributes from one entity to another, optionally replacing all the extended attributes on the destination. </p>
<p>This convenience function is implemented using the APIs above, and therefore is racy with respect to concurrent users. If you specifiy an invalid source with <code>replace_all_local_attributes = true</code>, then this is a convenient way to remove all extended attributes on the local inode.</p>
<dl class="section note"><dt>Note</dt><dd>This function uses 130Kb of stack and cannot handle attribute values larger than 64Kb. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  446</span>  {</div>
<div class="line"><span class="lineno">  447</span>    <span class="keyword">auto</span> &amp;h = _get_handle();</div>
<div class="line"><span class="lineno">  448</span>    (void) h;</div>
<div class="line"><span class="lineno">  449</span>    LLFIO_LOG_FUNCTION_CALL(&amp;h);</div>
<div class="line"><span class="lineno">  450</span>    <span class="keywordtype">byte</span> buffer[65536 + 4096];</div>
<div class="line"><span class="lineno">  451</span>    <span class="keywordflow">if</span>(replace_all_local_attributes)</div>
<div class="line"><span class="lineno">  452</span>    {</div>
<div class="line"><span class="lineno">  453</span>      <span class="keywordflow">for</span>(;;)</div>
<div class="line"><span class="lineno">  454</span>      {</div>
<div class="line"><span class="lineno">  455</span>        OUTCOME_TRY(<span class="keyword">auto</span> &amp;&amp;attribs, <a class="code hl_function" href="classllfio__v2__xxx_1_1fs__handle.html#a2899c3cabc9101bbd1eca895668a2d83">list_extended_attributes</a>(buffer));</div>
<div class="line"><span class="lineno">  456</span>        <span class="keywordflow">if</span>(attribs.empty())</div>
<div class="line"><span class="lineno">  457</span>        {</div>
<div class="line"><span class="lineno">  458</span>          <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  459</span>        }</div>
<div class="line"><span class="lineno">  460</span>        <span class="keywordflow">for</span>(<span class="keyword">auto</span> &amp;attrib : attribs)</div>
<div class="line"><span class="lineno">  461</span>        {</div>
<div class="line"><span class="lineno">  462</span>          OUTCOME_TRY(<a class="code hl_function" href="classllfio__v2__xxx_1_1fs__handle.html#a7bf5f372c10a6e643797bd763b0ed7e0">remove_extended_attribute</a>(attrib));</div>
<div class="line"><span class="lineno">  463</span>        }</div>
<div class="line"><span class="lineno">  464</span>      }</div>
<div class="line"><span class="lineno">  465</span>    }</div>
<div class="line"><span class="lineno">  466</span>    <span class="keywordflow">if</span>(src._get_handle().is_valid())</div>
<div class="line"><span class="lineno">  467</span>    {</div>
<div class="line"><span class="lineno">  468</span>      OUTCOME_TRY(<span class="keyword">auto</span> &amp;&amp;attribs, src.list_extended_attributes(buffer));</div>
<div class="line"><span class="lineno">  469</span>      <span class="keywordflow">for</span>(<span class="keyword">auto</span> &amp;attrib : attribs)</div>
<div class="line"><span class="lineno">  470</span>      {</div>
<div class="line"><span class="lineno">  471</span>        <span class="keywordtype">byte</span> buffer2[65536];</div>
<div class="line"><span class="lineno">  472</span>        OUTCOME_TRY(<span class="keyword">auto</span> &amp;&amp;value, src.get_extended_attribute(buffer2, attrib));</div>
<div class="line"><span class="lineno">  473</span>        OUTCOME_TRY(<a class="code hl_function" href="classllfio__v2__xxx_1_1fs__handle.html#a1bf22bb7a215f7f150f57f0a77164026">set_extended_attribute</a>(attrib, value));</div>
<div class="line"><span class="lineno">  474</span>      }</div>
<div class="line"><span class="lineno">  475</span>    }</div>
<div class="line"><span class="lineno">  476</span>    <span class="keywordflow">return</span> success();</div>
<div class="line"><span class="lineno">  477</span>  }</div>
<div class="ttc" id="aclassllfio__v2__xxx_1_1fs__handle_html_a1bf22bb7a215f7f150f57f0a77164026"><div class="ttname"><a href="classllfio__v2__xxx_1_1fs__handle.html#a1bf22bb7a215f7f150f57f0a77164026">llfio_v2_xxx::fs_handle::set_extended_attribute</a></div><div class="ttdeci">virtual result&lt; void &gt; set_extended_attribute(path_view_component name, span&lt; const byte &gt; value) noexcept</div><div class="ttdoc">Sets the value of an extended attribute on this file or directory.</div></div>
<div class="ttc" id="aclassllfio__v2__xxx_1_1fs__handle_html_a2899c3cabc9101bbd1eca895668a2d83"><div class="ttname"><a href="classllfio__v2__xxx_1_1fs__handle.html#a2899c3cabc9101bbd1eca895668a2d83">llfio_v2_xxx::fs_handle::list_extended_attributes</a></div><div class="ttdeci">virtual result&lt; span&lt; path_view_component &gt; &gt; list_extended_attributes(span&lt; byte &gt; tofill) const noexcept</div><div class="ttdoc">Fill the supplied buffer with the names of all extended attributes set on this file or directory,...</div></div>
<div class="ttc" id="aclassllfio__v2__xxx_1_1fs__handle_html_a7bf5f372c10a6e643797bd763b0ed7e0"><div class="ttname"><a href="classllfio__v2__xxx_1_1fs__handle.html#a7bf5f372c10a6e643797bd763b0ed7e0">llfio_v2_xxx::fs_handle::remove_extended_attribute</a></div><div class="ttdeci">virtual result&lt; void &gt; remove_extended_attribute(path_view_component) noexcept</div><div class="ttdoc">Removes the extended attribute set on this file or directory.</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a421c7f47706ed774d98cdbcc3b580d9c" name="a421c7f47706ed774d98cdbcc3b580d9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a421c7f47706ed774d98cdbcc3b580d9c">&#9670;&#160;</a></span>get_extended_attribute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual result&lt; span&lt; byte &gt; &gt; llfio_v2_xxx::fs_handle::get_extended_attribute </td>
          <td>(</td>
          <td class="paramtype">span&lt; byte &gt;&#160;</td>
          <td class="paramname"><em>tofill</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1path__view__component.html">path_view_component</a>&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the value of an extended attribute set on this file or directory. </p>
<dl class="section note"><dt>Note</dt><dd>On Windows, this is the list of alternate streams on a file, NOT NTFS extended attributes. </dd></dl>

</div>
</div>
<a id="a7eda0c5e6795f31f98f74eb9063a70ed" name="a7eda0c5e6795f31f98f74eb9063a70ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eda0c5e6795f31f98f74eb9063a70ed">&#9670;&#160;</a></span>link()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual result&lt; void &gt; llfio_v2_xxx::fs_handle::link </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllfio__v2__xxx_1_1path__handle.html">path_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#abcd8c8171f4e561620864295e8d5879b">path_view_type</a>&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllfio__v2__xxx_1_1deadline.html">deadline</a>&#160;</td>
          <td class="paramname"><em>d</em> = <code>std::chrono::seconds(30)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Links the inode referred to by this open handle to the path specified. The current path of this open handle is not changed, unless it has no current path due to being unlinked. </p>
<dl class="section warning"><dt>Warning</dt><dd>Some operating systems provide a race free syscall for linking an open handle to a new location (Linux, Windows). On all other operating systems this call is <b>racy</b> and can result in the wrong inode being linked. Note that unless <code>flag::disable_safety_unlinks</code> is set, this implementation opens a <code>path_handle</code> to the source containing directory first, then checks before linking that the item about to be hard linked has the same inode as the open file handle. It will retry this matching until success until the deadline given. This should prevent most unmalicious accidental loss of data.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Base for any relative path. </td></tr>
    <tr><td class="paramname">path</td><td>The relative or absolute new path to hard link to. </td></tr>
    <tr><td class="paramname">d</td><td>The deadline by which the matching of the containing directory to the open handle's inode must succeed, else <code>errc::timed_out</code> will be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Memory Allocations\n Except on platforms with race free syscalls for renaming open handles (Windows), calls</dt><dd><code>current_path()</code> via <code>parent_path_handle()</code> and thus is both expensive and calls malloc many times. </dd></dl>

</div>
</div>
<a id="a2899c3cabc9101bbd1eca895668a2d83" name="a2899c3cabc9101bbd1eca895668a2d83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2899c3cabc9101bbd1eca895668a2d83">&#9670;&#160;</a></span>list_extended_attributes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual result&lt; span&lt; <a class="el" href="classllfio__v2__xxx_1_1path__view__component.html">path_view_component</a> &gt; &gt; llfio_v2_xxx::fs_handle::list_extended_attributes </td>
          <td>(</td>
          <td class="paramtype">span&lt; byte &gt;&#160;</td>
          <td class="paramname"><em>tofill</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill the supplied buffer with the names of all extended attributes set on this file or directory, returning a span of path view components. </p>
<p>Note that this routine is a very thin wrap of <code>listxattr()</code> on POSIX and <code>NtQueryInformationFile()</code> on Windows. If the supplied buffer is too small, the syscall typically returns failure rather than do a partial fill. Most implementations do not support more than 64Kb of extended attribute information per inode so maybe 70Kb is a safe default (to account for the return value storage), however properly written code will detect the buffer being too small and will auto-expand it until success.</p>
<dl class="section note"><dt>Note</dt><dd>On Windows, this is the list of alternate streams on a file, NOT NTFS extended attributes.</dd></dl>
<dl class="section user"><dt>Race Guarantees\n The list of extended attributes is fetched in a single syscall. This may be an</dt><dd>atomically consistent snapshot. </dd></dl>

</div>
</div>
<a id="a2182c799ac54baa85ff4d1e06b04528a" name="a2182c799ac54baa85ff4d1e06b04528a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2182c799ac54baa85ff4d1e06b04528a">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html">fs_handle</a> &amp; llfio_v2_xxx::fs_handle::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html">fs_handle</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment of fs_handle permitted. </p>
<div class="fragment"><div class="line"><span class="lineno">  192</span>  {</div>
<div class="line"><span class="lineno">  193</span>    <span class="keywordflow">if</span>(<span class="keyword">this</span> == &amp;o)</div>
<div class="line"><span class="lineno">  194</span>    {</div>
<div class="line"><span class="lineno">  195</span>      <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><span class="lineno">  196</span>    }</div>
<div class="line"><span class="lineno">  197</span>    _devid = o._devid;</div>
<div class="line"><span class="lineno">  198</span>    _inode = o._inode;</div>
<div class="line"><span class="lineno">  199</span>    o._devid = 0;</div>
<div class="line"><span class="lineno">  200</span>    o._inode = 0;</div>
<div class="line"><span class="lineno">  201</span>    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><span class="lineno">  202</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a79a4bc903ac41d8fcca6b8c55c6bcc76" name="a79a4bc903ac41d8fcca6b8c55c6bcc76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79a4bc903ac41d8fcca6b8c55c6bcc76">&#9670;&#160;</a></span>parent_path_handle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual result&lt; <a class="el" href="classllfio__v2__xxx_1_1path__handle.html">path_handle</a> &gt; llfio_v2_xxx::fs_handle::parent_path_handle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structllfio__v2__xxx_1_1deadline.html">deadline</a>&#160;</td>
          <td class="paramname"><em>d</em> = <code>std::chrono::seconds(30)</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain a handle to the path <b>currently</b> containing this handle's file entry. </p>
<dl class="section warning"><dt>Warning</dt><dd>This call is <b>racy</b> and can result in the wrong path handle being returned. Note that unless <code>flag::disable_safety_unlinks</code> is set, this implementation opens a <code>path_handle</code> to the source containing directory, then checks if the file entry within has the same inode as the open file handle. It will retry this matching until success until the deadline given.</dd></dl>
<dl class="section user"><dt>Memory Allocations\n Calls <code>current_path()</code> and thus is both expensive and calls malloc many times.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>algorithm::cached_parent_handle_adapter&lt;T&gt;</code> which overrides this with a zero cost implementation, thus making unlinking and relinking very considerably quicker. </dd></dl>

</div>
</div>
<a id="a8574050f1988a925322d5a60a84c714b" name="a8574050f1988a925322d5a60a84c714b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8574050f1988a925322d5a60a84c714b">&#9670;&#160;</a></span>relink()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual result&lt; void &gt; llfio_v2_xxx::fs_handle::relink </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllfio__v2__xxx_1_1path__handle.html">path_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#abcd8c8171f4e561620864295e8d5879b">path_view_type</a>&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>atomic_replace</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllfio__v2__xxx_1_1deadline.html">deadline</a>&#160;</td>
          <td class="paramname"><em>d</em> = <code>std::chrono::seconds(30)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Relinks the current path of this open handle to the new path specified. If <code>atomic_replace</code> is true, the relink <b>atomically</b> and silently replaces any item at the new path specified. This operation is both atomic and matching POSIX behaviour even on Microsoft Windows where no Win32 API can match POSIX semantics. </p>
<p>Note that if <code>atomic_replace</code> is false, the operation <em>may</em> be implemented as creating a hard link to the destination (which fails if the destination exists), opening a new file descriptor to the destination, closing the existing file descriptor, replacing the existing file descriptor with the new one (this is to ensure path tracking continues to work), then unlinking the previous link. Thus <code>native_handle()</code>'s value <em>may</em> change. This is not the case on Microsoft Windows nor Linux, both of which provide syscalls capable of refusing to rename if the destination exists.</p>
<p>If the handle refers to a pipe, on Microsoft Windows the base path handle is ignored as there is a single global named pipe namespace. Unless the path fragment begins with <code>\</code>, the string <code>\??\</code> is prefixed to the name before passing it to the NT kernel API which performs the rename. This is because <code>\\.\</code> in Win32 maps onto <code>\??\</code> in the NT kernel.</p>
<dl class="section warning"><dt>Warning</dt><dd>Some operating systems provide a race free syscall for renaming an open handle (Windows). On all other operating systems this call is <b>racy</b> and can result in the wrong file entry being relinked. Note that unless <code>flag::disable_safety_unlinks</code> is set, this implementation opens a <code>path_handle</code> to the source containing directory first, then checks before relinking that the item about to be relinked has the same inode as the open file handle. It will retry this matching until success until the deadline given. This should prevent most unmalicious accidental loss of data.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Base for any relative path. </td></tr>
    <tr><td class="paramname">path</td><td>The relative or absolute new path to relink to. </td></tr>
    <tr><td class="paramname">atomic_replace</td><td>Atomically replace the destination if a file entry already is present there. Choosing false for this will fail if a file entry is already present at the destination, and may not be an atomic operation on some platforms (i.e. both the old and new names may be linked to the same inode for a very short period of time). Windows and recent Linuxes are always atomic. </td></tr>
    <tr><td class="paramname">d</td><td>The deadline by which the matching of the containing directory to the open handle's inode must succeed, else <code>errc::timed_out</code> will be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Memory Allocations\n Except on platforms with race free syscalls for renaming open handles (Windows), calls</dt><dd><code>current_path()</code> via <code>parent_path_handle()</code> and thus is both expensive and calls malloc many times. </dd></dl>

<p>Reimplemented in <a class="el" href="classllfio__v2__xxx_1_1mapped__file__handle.html#a612b033c4687f7025b58fa92e90aabfb">llfio_v2_xxx::mapped_file_handle</a>.</p>

</div>
</div>
<a id="a7bf5f372c10a6e643797bd763b0ed7e0" name="a7bf5f372c10a6e643797bd763b0ed7e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bf5f372c10a6e643797bd763b0ed7e0">&#9670;&#160;</a></span>remove_extended_attribute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual result&lt; void &gt; llfio_v2_xxx::fs_handle::remove_extended_attribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1path__view__component.html">path_view_component</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the extended attribute set on this file or directory. </p>
<dl class="section note"><dt>Note</dt><dd>On Windows, this is the list of alternate streams on a file, NOT NTFS extended attributes. We do not prevent you trying to remove internal alternate streams, either. </dd></dl>

</div>
</div>
<a id="a1bf22bb7a215f7f150f57f0a77164026" name="a1bf22bb7a215f7f150f57f0a77164026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bf22bb7a215f7f150f57f0a77164026">&#9670;&#160;</a></span>set_extended_attribute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual result&lt; void &gt; llfio_v2_xxx::fs_handle::set_extended_attribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1path__view__component.html">path_view_component</a>&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">span&lt; const byte &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value of an extended attribute on this file or directory. </p>
<p>To prevent collision in a globally visible resource, there is a convention whereby you ought to namespace the names of your values as <code>namespace.attribute</code> e.g. <code>appname.setting</code> to prevent unintentional collision with other programs. Obviously, do choose a unique <code>appname</code> if there is any chance another program might use the same namespace name.</p>
<p>On POSIX, there are additional namespacing requirements: before your value name, you need to prefix one of <code>user</code> or <code>system</code>, so the actual name you might set would be <code>user.appname.propname</code>. Windows does not have the <code>user</code>/<code>system</code> prefix requirement, but it does no harm to do the exact same on Windows as on POSIX.</p>
<p>The host OS and target filing system choose the limits on value size, and will fail accordingly. Some impose a maximum of 64Kb for all names and values per inode, others have a 4Kb maximum value size, there are lots of combinations. You are probably safest not setting many names, and keep the values short.</p>
<dl class="section warning"><dt>Warning</dt><dd>Extended attributes are 'brittle' because they can get silently wiped at any moment. Never store anything in extended attributes which cannot be recalculated if missing. The ideal use case for extended attributes is as a cache of additional metadata about a file or directory e.g. "I last checked this directory at timestamp X", or "the MD5 hash at last modified
timestamp X for this file was Y". Also remember that other processes can and do arbitrarily modify extended attributes concurrent to you.</dd></dl>
<h3><a class="anchor" id="autotoc_md8"></a>
Windows only</h3>
<p>This API is implemented as file alternate data streams, rather than the Extended Attributes API as accessed via <code>NtSetEaFile()</code> and <code>NtQueryEaFile()</code> (which actually modify the file alternate data stream <code>::$EA</code> in any case).</p>
<p>The reason why is that <code>NtSetEaFile()</code> can only <b>append</b> new records to EA storage. It cannot deallocate any existing EA records, if you try to do so you will get <code>STATUS_EA_CORRUPT_ERROR</code>. You can append setting the same name to a different value, which can include a null value which then appears as if the name is no longer there. But there is a cap of 64kB for the EA record, and once it is consumed, it is gone forever for that inode.</p>
<p>Obviously that doesn't map at all well onto POSIX extended attributes, where you can set the value of an attribute as frequently as you like. The closest equivalent on Windows is therefore file alternate data streams, even though the attribute's value is then worked with as a whole proper file with all the attendant performance consequences.</p>
<p>As a result, <code>name</code> must be a valid filename and not contain any characters not permitted in a filename. We use the NT API here, so the character restrictions are far fewer than for the Win32 API e.g. single character names do NOT cause misoperation like on Win32. </p>

</div>
</div>
<a id="ac24ed4cdb96690d7da95cd17b0f3d090" name="ac24ed4cdb96690d7da95cd17b0f3d090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac24ed4cdb96690d7da95cd17b0f3d090">&#9670;&#160;</a></span>st_dev()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dev_t llfio_v2_xxx::fs_handle::st_dev </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unless <code>flag::disable_safety_unlinks</code> is set, the device id of the file when opened. </p>
<div class="fragment"><div class="line"><span class="lineno">  212</span>  {</div>
<div class="line"><span class="lineno">  213</span>    <span class="keywordflow">if</span>(_devid == 0 &amp;&amp; _inode == 0)</div>
<div class="line"><span class="lineno">  214</span>    {</div>
<div class="line"><span class="lineno">  215</span>      (void) <a class="code hl_function" href="classllfio__v2__xxx_1_1fs__handle.html#af11804f144a9c95b03ce431cdcf41148">_fetch_inode</a>();</div>
<div class="line"><span class="lineno">  216</span>    }</div>
<div class="line"><span class="lineno">  217</span>    <span class="keywordflow">return</span> _devid;</div>
<div class="line"><span class="lineno">  218</span>  }</div>
<div class="ttc" id="aclassllfio__v2__xxx_1_1fs__handle_html_af11804f144a9c95b03ce431cdcf41148"><div class="ttname"><a href="classllfio__v2__xxx_1_1fs__handle.html#af11804f144a9c95b03ce431cdcf41148">llfio_v2_xxx::fs_handle::_fetch_inode</a></div><div class="ttdeci">result&lt; void &gt; _fetch_inode() const noexcept</div><div class="ttdoc">Fill in _devid and _inode from the handle via fstat()</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aad6465d30ee438b860ccc59c0e0fc4dc" name="aad6465d30ee438b860ccc59c0e0fc4dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad6465d30ee438b860ccc59c0e0fc4dc">&#9670;&#160;</a></span>st_ino()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ino_t llfio_v2_xxx::fs_handle::st_ino </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unless <code>flag::disable_safety_unlinks</code> is set, the inode of the file when opened. When combined with st_dev(), forms a unique identifer on this system. </p>
<div class="fragment"><div class="line"><span class="lineno">  221</span>  {</div>
<div class="line"><span class="lineno">  222</span>    <span class="keywordflow">if</span>(_devid == 0 &amp;&amp; _inode == 0)</div>
<div class="line"><span class="lineno">  223</span>    {</div>
<div class="line"><span class="lineno">  224</span>      (void) <a class="code hl_function" href="classllfio__v2__xxx_1_1fs__handle.html#af11804f144a9c95b03ce431cdcf41148">_fetch_inode</a>();</div>
<div class="line"><span class="lineno">  225</span>    }</div>
<div class="line"><span class="lineno">  226</span>    <span class="keywordflow">return</span> _inode;</div>
<div class="line"><span class="lineno">  227</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad43b812385c7fc8aae9e59838a1411bb" name="ad43b812385c7fc8aae9e59838a1411bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad43b812385c7fc8aae9e59838a1411bb">&#9670;&#160;</a></span>try_link()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool llfio_v2_xxx::fs_handle::try_link </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a65d73e0e89bac484ce40427b58dcfe53" name="a65d73e0e89bac484ce40427b58dcfe53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65d73e0e89bac484ce40427b58dcfe53">&#9670;&#160;</a></span>try_link_for()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Args, class Rep , class Period &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool llfio_v2_xxx::fs_handle::try_link_for </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>duration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad2703814c7599d2081ca10763bbeba4a" name="ad2703814c7599d2081ca10763bbeba4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2703814c7599d2081ca10763bbeba4a">&#9670;&#160;</a></span>try_link_until()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Args, class Clock , class Duration &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool llfio_v2_xxx::fs_handle::try_link_until </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::time_point&lt; Clock, Duration &gt; &amp;&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1eeaf9d77a1279b4f0d3062de509f77f" name="a1eeaf9d77a1279b4f0d3062de509f77f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eeaf9d77a1279b4f0d3062de509f77f">&#9670;&#160;</a></span>try_parent_path_handle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool llfio_v2_xxx::fs_handle::try_parent_path_handle </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a41ea4bd2d5a66fbde4cdbfe463166a4f" name="a41ea4bd2d5a66fbde4cdbfe463166a4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41ea4bd2d5a66fbde4cdbfe463166a4f">&#9670;&#160;</a></span>try_parent_path_handle_for()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Args, class Rep , class Period &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool llfio_v2_xxx::fs_handle::try_parent_path_handle_for </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>duration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acbb1fe8c7901382307d84848fdc0afcb" name="acbb1fe8c7901382307d84848fdc0afcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbb1fe8c7901382307d84848fdc0afcb">&#9670;&#160;</a></span>try_parent_path_handle_until()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Args, class Clock , class Duration &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool llfio_v2_xxx::fs_handle::try_parent_path_handle_until </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::time_point&lt; Clock, Duration &gt; &amp;&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7f5f9892f6652359f2330bf6d9b89e17" name="a7f5f9892f6652359f2330bf6d9b89e17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f5f9892f6652359f2330bf6d9b89e17">&#9670;&#160;</a></span>try_relink()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool llfio_v2_xxx::fs_handle::try_relink </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af5565cd5f2fcbb9472b2a00795cc0bcc" name="af5565cd5f2fcbb9472b2a00795cc0bcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5565cd5f2fcbb9472b2a00795cc0bcc">&#9670;&#160;</a></span>try_relink_for()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Args, class Rep , class Period &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool llfio_v2_xxx::fs_handle::try_relink_for </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>duration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1fc4e2ade67dfb9140007cc31f4b6b20" name="a1fc4e2ade67dfb9140007cc31f4b6b20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fc4e2ade67dfb9140007cc31f4b6b20">&#9670;&#160;</a></span>try_relink_until()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Args, class Clock , class Duration &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool llfio_v2_xxx::fs_handle::try_relink_until </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::time_point&lt; Clock, Duration &gt; &amp;&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7f77a249baf4e0c5de2172669a7724d7" name="a7f77a249baf4e0c5de2172669a7724d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f77a249baf4e0c5de2172669a7724d7">&#9670;&#160;</a></span>try_unlink()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool llfio_v2_xxx::fs_handle::try_unlink </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a209de025a2d3e202a61c50b52d43f2af" name="a209de025a2d3e202a61c50b52d43f2af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a209de025a2d3e202a61c50b52d43f2af">&#9670;&#160;</a></span>try_unlink_for()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Args, class Rep , class Period &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool llfio_v2_xxx::fs_handle::try_unlink_for </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>duration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae9c4133fef23811abcb01e1faf2b19d3" name="ae9c4133fef23811abcb01e1faf2b19d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9c4133fef23811abcb01e1faf2b19d3">&#9670;&#160;</a></span>try_unlink_until()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Args, class Clock , class Duration &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool llfio_v2_xxx::fs_handle::try_unlink_until </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::time_point&lt; Clock, Duration &gt; &amp;&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9793fe40564fda2437783488bd51b9f1" name="a9793fe40564fda2437783488bd51b9f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9793fe40564fda2437783488bd51b9f1">&#9670;&#160;</a></span>unique_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#a1a65884346740af7fb4648c79d44a750">unique_id_type</a> llfio_v2_xxx::fs_handle::unique_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A unique identifier for this handle across the entire system. Can be used in hash tables etc. </p>
<div class="fragment"><div class="line"><span class="lineno">  230</span>  {</div>
<div class="line"><span class="lineno">  231</span>    <span class="keywordflow">if</span>(_devid == 0 &amp;&amp; _inode == 0)</div>
<div class="line"><span class="lineno">  232</span>    {</div>
<div class="line"><span class="lineno">  233</span>      (void) <a class="code hl_function" href="classllfio__v2__xxx_1_1fs__handle.html#af11804f144a9c95b03ce431cdcf41148">_fetch_inode</a>();</div>
<div class="line"><span class="lineno">  234</span>    }</div>
<div class="line"><span class="lineno">  235</span>    <a class="code hl_typedef" href="classllfio__v2__xxx_1_1fs__handle.html#a1a65884346740af7fb4648c79d44a750">unique_id_type</a> ret;</div>
<div class="line"><span class="lineno">  236</span>    ret.as_longlongs[0] = _devid;</div>
<div class="line"><span class="lineno">  237</span>    ret.as_longlongs[1] = _inode;</div>
<div class="line"><span class="lineno">  238</span>    <span class="keywordflow">return</span> ret;</div>
<div class="line"><span class="lineno">  239</span>  }</div>
<div class="ttc" id="aclassllfio__v2__xxx_1_1fs__handle_html_a1a65884346740af7fb4648c79d44a750"><div class="ttname"><a href="classllfio__v2__xxx_1_1fs__handle.html#a1a65884346740af7fb4648c79d44a750">llfio_v2_xxx::fs_handle::unique_id_type</a></div><div class="ttdeci">QUICKCPPLIB_NAMESPACE::integers128::uint128 unique_id_type</div><div class="ttdoc">The unique identifier type used by this handle.</div><div class="ttdef"><b>Definition</b> fs_handle.hpp:157</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a7b4f17a0b437d430a37d3875d8570bf2" name="a7b4f17a0b437d430a37d3875d8570bf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b4f17a0b437d430a37d3875d8570bf2">&#9670;&#160;</a></span>unlink()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual result&lt; void &gt; llfio_v2_xxx::fs_handle::unlink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structllfio__v2__xxx_1_1deadline.html">deadline</a>&#160;</td>
          <td class="paramname"><em>d</em> = <code>std::chrono::seconds(30)</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unlinks the current path of this open handle, causing its entry to immediately disappear from the filing system. </p>
<p>On Windows before Windows 10 1709 unless <code>flag::win_disable_unlink_emulation</code> is set, this behaviour is simulated by renaming the file to something random and setting its delete-on-last-close flag. Note that Windows may prevent the renaming of a file in use by another process, if so it will NOT be renamed. After the next handle to that file closes, it will become permanently unopenable by anyone else until the last handle is closed, whereupon the entry will be eventually removed by the operating system.</p>
<dl class="section warning"><dt>Warning</dt><dd>Some operating systems provide a race free syscall for unlinking an open handle (Windows). On all other operating systems this call is <b>racy</b> and can result in the wrong file entry being unlinked. Note that unless <code>flag::disable_safety_unlinks</code> is set, this implementation opens a <code>path_handle</code> to the containing directory first, then checks that the item about to be unlinked has the same inode as the open file handle. It will retry this matching until success until the deadline given. This should prevent most unmalicious accidental loss of data.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The deadline by which the matching of the containing directory to the open handle's inode must succeed, else <code>errc::timed_out</code> will be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Memory Allocations\n Except on platforms with race free syscalls for unlinking open handles (Windows), calls</dt><dd><code>current_path()</code> and thus is both expensive and calls malloc many times. On Windows, also calls <code>current_path()</code> if <code>flag::disable_safety_unlinks</code> is not set. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="af0fa5755fb5adfde2ebd8de60aa16c3c" name="af0fa5755fb5adfde2ebd8de60aa16c3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0fa5755fb5adfde2ebd8de60aa16c3c">&#9670;&#160;</a></span>to_win32_path</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result&lt; filesystem::path &gt; to_win32_path </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllfio__v2__xxx_1_1fs__handle.html">fs_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacellfio__v2__xxx.html#abcb445e5dfcc0eb04ce49ac8af0bc89a">win32_path_namespace</a>&#160;</td>
          <td class="paramname"><em>mapping</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps the current path of <code>h</code> into a form suitable for Win32 APIs. Passes through unmodified on POSIX, so you can use this in portable code. </p>
<dl class="section return"><dt>Returns</dt><dd>The mapped current path of <code>h</code>, which may have been validated to refer to the exact same inode via <code>.unique_id()</code> (see below). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>The handle whose <code>.current_path()</code> is to be mapped into a form suitable for Win32 APIs. </td></tr>
    <tr><td class="paramname">mapping</td><td>Which Win32 path namespace to map onto.</td></tr>
  </table>
  </dd>
</dl>
<p>This implementation may need to validate that the mapping of the current path of <code>h</code> onto the desired Win32 path namespace does indeed refer to the same file:</p>
<ul>
<li><code>win32_path_namespace::device</code> transforms <code>\!!\Device\...</code> =&gt; <code>\\.\...</code> and ensures that the mapped file's unique id matches the original, otherwise returning failure.</li>
<li><code>win32_path_namespace::dos</code> enumerates all the DOS devices on the system and what those map onto within the NT kernel namespace. This mapping is for obvious reasons quite slow.</li>
<li><code>win32_path_namespace::guid_volume</code> simply fetches the GUID of the volume of the handle, and constructs a valid Win32 path from that.</li>
<li><code>win32_path_namespace::any</code> means attempt <code>guid_volume</code> first, and if it fails (e.g. your file is on a network share) then it attempts <code>dos</code>. This semantic may change in the future, however any path emitted will always be a valid Win32 path. </li>
</ul>
<div class="fragment"><div class="line"><span class="lineno">  145</span>  {</div>
<div class="line"><span class="lineno">  146</span>    (void) mapping;</div>
<div class="line"><span class="lineno">  147</span>    <span class="keywordflow">return</span> h._get_handle().current_path();</div>
<div class="line"><span class="lineno">  148</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a4d20a64cf182162a49962ed25d2126b3" name="a4d20a64cf182162a49962ed25d2126b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d20a64cf182162a49962ed25d2126b3">&#9670;&#160;</a></span>_devid</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dev_t llfio_v2_xxx::fs_handle::_devid {0}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  162</span>{0};</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8454764db3cd47e65ec7853b9cb0b3fa" name="a8454764db3cd47e65ec7853b9cb0b3fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8454764db3cd47e65ec7853b9cb0b3fa">&#9670;&#160;</a></span>_inode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ino_t llfio_v2_xxx::fs_handle::_inode {0}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  163</span>{0};</div>
</div><!-- fragment -->
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/llfio/v2.0/<a class="el" href="fs__handle_8hpp.html">fs_handle.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacellfio__v2__xxx.html">llfio_v2_xxx</a></li><li class="navelem"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html">fs_handle</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
