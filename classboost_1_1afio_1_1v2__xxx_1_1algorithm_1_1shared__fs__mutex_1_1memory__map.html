<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Boost.AFIO: boost::afio::v2_xxx::algorithm::shared_fs_mutex::memory_map&lt; Hasher, HashIndexSize, SpinlockType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.AFIO
   &#160;<span id="projectnumber">v2.00 early alpha</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">boost::afio::v2_xxx::algorithm::shared_fs_mutex::memory_map&lt; Hasher, HashIndexSize, SpinlockType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Many entity memory mapped shared/exclusive file system based lock.  
 <a href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="memory__map_8hpp_source.html">memory_map.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for boost::afio::v2_xxx::algorithm::shared_fs_mutex::memory_map&lt; Hasher, HashIndexSize, SpinlockType &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.png" usemap="#boost::afio::v2_xxx::algorithm::shared_fs_mutex::memory_map&lt; Hasher, HashIndexSize, SpinlockType &gt;_map" alt=""/>
  <map id="boost::afio::v2_xxx::algorithm::shared_fs_mutex::memory_map&lt; Hasher, HashIndexSize, SpinlockType &gt;_map" name="boost::afio::v2_xxx::algorithm::shared_fs_mutex::memory_map&lt; Hasher, HashIndexSize, SpinlockType &gt;_map">
<area href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html" title="Abstract base class for an object which protects shared filing system resources." alt="boost::afio::v2_xxx::algorithm::shared_fs_mutex::shared_fs_mutex" shape="rect" coords="0,0,594,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map_1_1__entity__idx.html">_entity_idx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a071f43d9e4dca8c5f0c8d7ab551e4d8d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a071f43d9e4dca8c5f0c8d7ab551e4d8d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html#a071f43d9e4dca8c5f0c8d7ab551e4d8d">entity_type</a> = <a class="el" href="structboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex_1_1entity__type.html">shared_fs_mutex::entity_type</a></td></tr>
<tr class="memdesc:a071f43d9e4dca8c5f0c8d7ab551e4d8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of an entity id. <br/></td></tr>
<tr class="separator:a071f43d9e4dca8c5f0c8d7ab551e4d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f3e252a8c155f9b835745c1e5df30a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9f3e252a8c155f9b835745c1e5df30a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html#ae9f3e252a8c155f9b835745c1e5df30a">entities_type</a> = <a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html#a02af43575220c42252610c818e109b72">shared_fs_mutex::entities_type</a></td></tr>
<tr class="memdesc:ae9f3e252a8c155f9b835745c1e5df30a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a sequence of entities. <br/></td></tr>
<tr class="separator:ae9f3e252a8c155f9b835745c1e5df30a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ab075ffa6ac8e7c616de146e784f83"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a68ab075ffa6ac8e7c616de146e784f83"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html#a68ab075ffa6ac8e7c616de146e784f83">hasher_type</a> = Hasher&lt; <a class="el" href="structboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex_1_1entity__type.html#ac3de71379e096fa5eafb449253517251">entity_type::value_type</a> &gt;</td></tr>
<tr class="memdesc:a68ab075ffa6ac8e7c616de146e784f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the hasher being used. <br/></td></tr>
<tr class="separator:a68ab075ffa6ac8e7c616de146e784f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac010a9ebbf8c2176ae3871b28cdf50d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac010a9ebbf8c2176ae3871b28cdf50d5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html#ac010a9ebbf8c2176ae3871b28cdf50d5">spinlock_type</a> = SpinlockType</td></tr>
<tr class="memdesc:ac010a9ebbf8c2176ae3871b28cdf50d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the spinlock being used. <br/></td></tr>
<tr class="separator:ac010a9ebbf8c2176ae3871b28cdf50d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5908f9f45b5b365a7d82997285c2acb5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5908f9f45b5b365a7d82997285c2acb5"></a>
<a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html">shared_fs_mutex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html#a5908f9f45b5b365a7d82997285c2acb5">fallback</a> () const noexcept</td></tr>
<tr class="memdesc:a5908f9f45b5b365a7d82997285c2acb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the fallback lock. <br/></td></tr>
<tr class="separator:a5908f9f45b5b365a7d82997285c2acb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a435b244e76c966c4827f27c3d64ac79c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a435b244e76c966c4827f27c3d64ac79c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html#a435b244e76c966c4827f27c3d64ac79c">fallback</a> (<a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html">shared_fs_mutex</a> *fbl) noexcept</td></tr>
<tr class="memdesc:a435b244e76c966c4827f27c3d64ac79c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the fallback lock. <br/></td></tr>
<tr class="separator:a435b244e76c966c4827f27c3d64ac79c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5971ff6c2a54bdcacfd071a7ba640e3a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5971ff6c2a54bdcacfd071a7ba640e3a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html#a5971ff6c2a54bdcacfd071a7ba640e3a">is_degraded</a> () const noexcept</td></tr>
<tr class="memdesc:a5971ff6c2a54bdcacfd071a7ba640e3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if this lock has degraded due to a network user trying to use it. <br/></td></tr>
<tr class="separator:a5971ff6c2a54bdcacfd071a7ba640e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a016539453fa3746be02d15830654e79b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a016539453fa3746be02d15830654e79b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html#a016539453fa3746be02d15830654e79b">memory_map</a> (<a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html">memory_map</a> &amp;&amp;o) noexcept</td></tr>
<tr class="memdesc:a016539453fa3746be02d15830654e79b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. <br/></td></tr>
<tr class="separator:a016539453fa3746be02d15830654e79b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd33e6e74443893130dd8517e2fd000e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd33e6e74443893130dd8517e2fd000e"></a>
<a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html">memory_map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html#afd33e6e74443893130dd8517e2fd000e">operator=</a> (<a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html">memory_map</a> &amp;&amp;o) noexcept</td></tr>
<tr class="memdesc:afd33e6e74443893130dd8517e2fd000e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assign. <br/></td></tr>
<tr class="separator:afd33e6e74443893130dd8517e2fd000e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a507508205fafa66ebc84dbaf4452c1f5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a507508205fafa66ebc84dbaf4452c1f5"></a>
const <a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1file__handle.html">file_handle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html#a507508205fafa66ebc84dbaf4452c1f5">handle</a> () const noexcept</td></tr>
<tr class="memdesc:a507508205fafa66ebc84dbaf4452c1f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the handle to file being used for this lock. <br/></td></tr>
<tr class="separator:a507508205fafa66ebc84dbaf4452c1f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b690325543b3e850274f4b92a34d797"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b690325543b3e850274f4b92a34d797"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html#a3b690325543b3e850274f4b92a34d797">unlock</a> (<a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html#a02af43575220c42252610c818e109b72">entities_type</a> entities, unsigned long long hint) noexceptoverridefinal</td></tr>
<tr class="memdesc:a3b690325543b3e850274f4b92a34d797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock a previously locked sequence of entities. <br/></td></tr>
<tr class="separator:a3b690325543b3e850274f4b92a34d797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d121be3d16ec5fcd15d61e59f8b66bd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d121be3d16ec5fcd15d61e59f8b66bd"></a>
<a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html#a071f43d9e4dca8c5f0c8d7ab551e4d8d">entity_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html#a6d121be3d16ec5fcd15d61e59f8b66bd">entity_from_buffer</a> (const char *buffer, size_t bytes, bool exclusive=true) noexcept</td></tr>
<tr class="memdesc:a6d121be3d16ec5fcd15d61e59f8b66bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates an entity id from a sequence of bytes. <br/></td></tr>
<tr class="separator:a6d121be3d16ec5fcd15d61e59f8b66bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc91b1e075ed52fc277c59213cf7b357"><td class="memTemplParams" colspan="2"><a class="anchor" id="adc91b1e075ed52fc277c59213cf7b357"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:adc91b1e075ed52fc277c59213cf7b357"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html#a071f43d9e4dca8c5f0c8d7ab551e4d8d">entity_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html#adc91b1e075ed52fc277c59213cf7b357">entity_from_string</a> (const std::basic_string&lt; T &gt; &amp;str, bool exclusive=true) noexcept</td></tr>
<tr class="memdesc:adc91b1e075ed52fc277c59213cf7b357"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates an entity id from a string. <br/></td></tr>
<tr class="separator:adc91b1e075ed52fc277c59213cf7b357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a493872c8b5dbfa83fdf82242b928e112"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a493872c8b5dbfa83fdf82242b928e112"></a>
<a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html#a071f43d9e4dca8c5f0c8d7ab551e4d8d">entity_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html#a493872c8b5dbfa83fdf82242b928e112">random_entity</a> (bool exclusive=true) noexcept</td></tr>
<tr class="memdesc:a493872c8b5dbfa83fdf82242b928e112"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a cryptographically random entity id. <br/></td></tr>
<tr class="separator:a493872c8b5dbfa83fdf82242b928e112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50848058867ee3533b812378aff20b03"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50848058867ee3533b812378aff20b03"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html#a50848058867ee3533b812378aff20b03">fill_random_entities</a> (span&lt; <a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html#a071f43d9e4dca8c5f0c8d7ab551e4d8d">entity_type</a> &gt; seq, bool exclusive=true) noexcept</td></tr>
<tr class="memdesc:a50848058867ee3533b812378aff20b03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a sequence of entity ids with cryptographic randomness. Much faster than calling <a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html#a493872c8b5dbfa83fdf82242b928e112" title="Generates a cryptographically random entity id.">random_entity()</a> individually. <br/></td></tr>
<tr class="separator:a50848058867ee3533b812378aff20b03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19fafd3b1f9a098c9e60212e7ba97e32"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19fafd3b1f9a098c9e60212e7ba97e32"></a>
<a class="el" href="namespaceboost_1_1afio_1_1v2__xxx.html#ac8d06ecaa9660e7251c1251d88c1305c">result</a>&lt; <a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex_1_1entities__guard.html">entities_guard</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html#a19fafd3b1f9a098c9e60212e7ba97e32">lock</a> (<a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html#a02af43575220c42252610c818e109b72">entities_type</a> entities, <a class="el" href="structboost_1_1afio_1_1v2__xxx_1_1deadline.html">deadline</a> d=<a class="el" href="structboost_1_1afio_1_1v2__xxx_1_1deadline.html">deadline</a>(), bool spin_not_sleep=false) noexcept</td></tr>
<tr class="memdesc:a19fafd3b1f9a098c9e60212e7ba97e32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock all of a sequence of entities for exclusive or shared access. <br/></td></tr>
<tr class="separator:a19fafd3b1f9a098c9e60212e7ba97e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade23c2f167c550c66fa5522ad3e27b7e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade23c2f167c550c66fa5522ad3e27b7e"></a>
<a class="el" href="namespaceboost_1_1afio_1_1v2__xxx.html#ac8d06ecaa9660e7251c1251d88c1305c">result</a>&lt; <a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex_1_1entities__guard.html">entities_guard</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html#ade23c2f167c550c66fa5522ad3e27b7e">lock</a> (<a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html#a071f43d9e4dca8c5f0c8d7ab551e4d8d">entity_type</a> entity, <a class="el" href="structboost_1_1afio_1_1v2__xxx_1_1deadline.html">deadline</a> d=<a class="el" href="structboost_1_1afio_1_1v2__xxx_1_1deadline.html">deadline</a>(), bool spin_not_sleep=false) noexcept</td></tr>
<tr class="memdesc:ade23c2f167c550c66fa5522ad3e27b7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock a single entity for exclusive or shared access. <br/></td></tr>
<tr class="separator:ade23c2f167c550c66fa5522ad3e27b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a851d41aee26d0d58cc7e6371724dfd80"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a851d41aee26d0d58cc7e6371724dfd80"></a>
<a class="el" href="namespaceboost_1_1afio_1_1v2__xxx.html#ac8d06ecaa9660e7251c1251d88c1305c">result</a>&lt; <a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex_1_1entities__guard.html">entities_guard</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html#a851d41aee26d0d58cc7e6371724dfd80">try_lock</a> (<a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html#a02af43575220c42252610c818e109b72">entities_type</a> entities) noexcept</td></tr>
<tr class="memdesc:a851d41aee26d0d58cc7e6371724dfd80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to lock all of a sequence of entities for exclusive or shared access. <br/></td></tr>
<tr class="separator:a851d41aee26d0d58cc7e6371724dfd80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8f772f5f052920879526dbb66a90823"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8f772f5f052920879526dbb66a90823"></a>
<a class="el" href="namespaceboost_1_1afio_1_1v2__xxx.html#ac8d06ecaa9660e7251c1251d88c1305c">result</a>&lt; <a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex_1_1entities__guard.html">entities_guard</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html#ad8f772f5f052920879526dbb66a90823">try_lock</a> (<a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html#a071f43d9e4dca8c5f0c8d7ab551e4d8d">entity_type</a> entity) noexcept</td></tr>
<tr class="memdesc:ad8f772f5f052920879526dbb66a90823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to lock a single entity for exclusive or shared access. <br/></td></tr>
<tr class="separator:ad8f772f5f052920879526dbb66a90823"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:af05e02f0e3cfa63e002bd87fa795b719"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceboost_1_1afio_1_1v2__xxx.html#ac8d06ecaa9660e7251c1251d88c1305c">result</a>&lt; <a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html">memory_map</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html#af05e02f0e3cfa63e002bd87fa795b719">fs_mutex_map</a> (file_handle::path_type lockfile, <a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html">shared_fs_mutex</a> *fallbacklock=nullptr) noexcept</td></tr>
<tr class="separator:af05e02f0e3cfa63e002bd87fa795b719"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a57c556cc305199e11a4d5fcd0c1b922e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a57c556cc305199e11a4d5fcd0c1b922e"></a>
virtual <a class="el" href="namespaceboost_1_1afio_1_1v2__xxx.html#ac8d06ecaa9660e7251c1251d88c1305c">result</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_lock</b> (<a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex_1_1entities__guard.html">entities_guard</a> &amp;out, <a class="el" href="structboost_1_1afio_1_1v2__xxx_1_1deadline.html">deadline</a> d, bool spin_not_sleep) noexceptoverridefinal</td></tr>
<tr class="separator:a57c556cc305199e11a4d5fcd0c1b922e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a252543c17db459bf7d2352531f672aa0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a252543c17db459bf7d2352531f672aa0"></a>
static span&lt; <a class="el" href="structboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map_1_1__entity__idx.html">_entity_idx</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_hash_entities</b> (<a class="el" href="structboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map_1_1__entity__idx.html">_entity_idx</a> *entity_to_idx, <a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html#a02af43575220c42252610c818e109b72">entities_type</a> &amp;entities)</td></tr>
<tr class="separator:a252543c17db459bf7d2352531f672aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a791219f822fa8e707e2c5676bd3f22c2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a791219f822fa8e707e2c5676bd3f22c2"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>_entity_type_endian_check</b> ()</td></tr>
<tr class="separator:a791219f822fa8e707e2c5676bd3f22c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;template&lt; class &gt; class Hasher = boost_lite::algorithm::hash::fnv1a_hash, size_t HashIndexSize = 4096, class SpinlockType = boost_lite::configurable_spinlock::shared_spinlock&lt;&gt;&gt;<br/>
class boost::afio::v2_xxx::algorithm::shared_fs_mutex::memory_map&lt; Hasher, HashIndexSize, SpinlockType &gt;</h3>

<p>Many entity memory mapped shared/exclusive file system based lock. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Hasher</td><td>A STL compatible hash algorithm to use (defaults to <code>fnv1a_hash</code>) </td></tr>
    <tr><td class="paramname">HashIndexSize</td><td>The size in bytes of the hash index to use (defaults to 4Kb) </td></tr>
    <tr><td class="paramname">SpinlockType</td><td>The type of spinlock to use (defaults to a <code>SharedMutex</code> concept spinlock)</td></tr>
  </table>
  </dd>
</dl>
<p>This is the highest performing filing system mutex in AFIO, but it comes with a long list of potential gotchas. It works by creating a random temporary file somewhere on the system and placing its path in a file at the lock file location. The random temporary file is mapped into memory by all processes using the lock where an open addressed hash table is kept. Each entity is hashed into somewhere in the hash table and its individual spin lock is used to implement the exclusion. As with <code><a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1byte__ranges.html" title="Many entity shared/exclusive file system based lock.">byte_ranges</a></code>, each entity is locked individually in sequence but if a particular lock fails, all are unlocked and the list is randomised before trying again. Because this locking implementation is entirely implemented in userspace using shared memory without any kernel syscalls, performance is probably as fast as any many-arbitrary-entity shared locking system could be.</p>
<p>Performance ought to be excellent so long as no lock user attempts to use the lock from across a networked filing system. As soon as a locking entity fails to find the temporary file given in the lock file location, it will <em>permanently</em> degrade the memory mapped lock into the "fallback" lock specified in the constructor (if you do not specify one, <code>EBUSY</code> will be forever returned from then on when trying to lock). It is up to the end user to decide when it might be time to destroy and reconstruct <code><a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html" title="Many entity memory mapped shared/exclusive file system based lock.">memory_map</a></code> in order to restore full performance.</p>
<ul>
<li>Compatible with networked file systems, though with a substantial performance degrade as described above.</li>
<li>Linear complexity to number of concurrent users up until hash table starts to get full or hashed entries collide.</li>
<li>Sudden power loss during use is recovered from.</li>
<li>Safe for multithreaded usage of the same instance.</li>
<li>In the lightly contended case, an order of magnitude faster than any other <code><a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html" title="Abstract base class for an object which protects shared filing system resources.">shared_fs_mutex</a></code> algorithm.</li>
</ul>
<p>Caveats:</p>
<ul>
<li>A transition between mapped and fallback locks will block forever until all current mapped memory users have realised the transition has happened. This can take a very significant amount of time if a lock user does not regularly lock its locks. <dl class="todo"><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd>It should be possible to auto early out from a <a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html" title="Many entity memory mapped shared/exclusive file system based lock.">memory_map</a> transition by scanning the memory map for any locked items, and if none then to proceed.</dd></dl>
</li>
</ul>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="af05e02f0e3cfa63e002bd87fa795b719"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class &gt; class Hasher = boost_lite::algorithm::hash::fnv1a_hash, size_t HashIndexSize = 4096, class SpinlockType  = boost_lite::configurable_spinlock::shared_spinlock&lt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespaceboost_1_1afio_1_1v2__xxx.html#ac8d06ecaa9660e7251c1251d88c1305c">result</a>&lt;<a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html">memory_map</a>&gt; <a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html">boost::afio::v2_xxx::algorithm::shared_fs_mutex::memory_map</a>&lt; Hasher, HashIndexSize, SpinlockType &gt;::fs_mutex_map </td>
          <td>(</td>
          <td class="paramtype">file_handle::path_type&#160;</td>
          <td class="paramname"><em>lockfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html">shared_fs_mutex</a> *&#160;</td>
          <td class="paramname"><em>fallbacklock</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialises a shared filing system mutex using the file at <em>lockfile</em> and an optional fallback lock. </p>
<dl class="section user"><dt>Errors returnable</dt><dd>Awaiting the clang result&lt;&gt; AST parser which auto generates all the error codes which could occur, but a particularly important one is <code>EBUSY</code> which will be returned if the memory map lock is already in a degraded state (i.e. just use the fallback lock directly). </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000009">Todo:</a></b></dt><dd>fs_mutex_map needs to check if this inode is that at the path after lock is granted, awaiting stat_t port. </dd></dl>
<div class="fragment"><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;      {</div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;        BOOST_AFIO_LOG_FUNCTION_CALL(0);</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;        <span class="keywordflow">try</span></div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;        {</div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;          BOOST_OUTCOME_FILTER_ERROR(ret, <a class="code" href="classboost_1_1afio_1_1v2__xxx_1_1file__handle.html#af912595f8964b78186236a2cec1150a4">file_handle::file</a>(std::move(lockfile), file_handle::mode::write, file_handle::creation::if_needed, file_handle::caching::reads));</div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;          file_handle temph;</div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;          <span class="comment">// Am I the first person to this file? Lock the inuse exclusively</span></div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;          <span class="keyword">auto</span> lockinuse = ret.try_lock(_lockinuseoffset, 1, <span class="keyword">true</span>);</div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;          file_handle::extent_guard mapinuse;</div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;          <span class="keywordflow">if</span>(lockinuse.has_error())</div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;          {</div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;            <span class="keywordflow">if</span>(lockinuse.get_error().value() != ETIMEDOUT)</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;              <span class="keywordflow">return</span> lockinuse.get_error();</div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;            <span class="comment">// Somebody else is also using this file, so try to read the hash index file I ought to use</span></div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;            lockinuse = ret.lock(_lockinuseoffset, 1, <span class="keyword">false</span>);  <span class="comment">// last byte shared access</span></div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;            <span class="keywordtype">char</span> buffer[65536];</div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;            memset(buffer, 0, <span class="keyword">sizeof</span>(buffer));</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;            {</div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;              BOOST_OUTCOME_FILTER_ERROR(_, ret.read(0, buffer, 65535));</div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;              (void) _;</div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;            }</div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;            fixme_path::value_type *temphpath = (fixme_path::value_type *) buffer;</div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;            result&lt;file_handle&gt; _temph;</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;            <span class="comment">// If path is zeroed, fall back onto backup lock</span></div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;            <span class="keywordflow">if</span>(!buffer[0])</div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;              <span class="keywordflow">goto</span> use_fall_back_lock;</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;            <span class="keywordflow">else</span></div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;              _temph = <a class="code" href="classboost_1_1afio_1_1v2__xxx_1_1file__handle.html#af912595f8964b78186236a2cec1150a4">file_handle::file</a>(temphpath, file_handle::mode::write, file_handle::creation::open_existing, file_handle::caching::temporary);</div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;            <span class="comment">// If temp file doesn&#39;t exist, I am on a different machine</span></div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;            <span class="keywordflow">if</span>(!_temph)</div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;            {</div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;              <span class="comment">// Zop the path so any new entrants into this lock will go to the fallback lock</span></div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;              memset(buffer, 0, 4096);</div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;              (void) ret.write(0, buffer, 4096);</div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;            use_fall_back_lock:</div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;              <span class="comment">// I am guaranteed that all mmap users have locked the second last byte</span></div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;              <span class="comment">// and will unlock it once everyone has stopped using the mmap, so make</span></div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;              <span class="comment">// absolutely sure the mmap is not in use by anyone by taking an exclusive</span></div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;              <span class="comment">// lock on the second final byte</span></div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;              BOOST_OUTCOME_FILTER_ERROR(mapinuse2, ret.lock(_mapinuseoffset, 1, <span class="keyword">true</span>));</div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;              <span class="comment">// Release the exclusive lock and tell caller to just use the fallback lock directly</span></div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;              <span class="keywordflow">return</span> make_errored_result&lt;memory_map&gt;(EBUSY);</div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;            }</div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;            <span class="keywordflow">else</span></div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;            {</div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;              <span class="comment">// Mark the map as being in use by me too</span></div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;              BOOST_OUTCOME_FILTER_ERROR(mapinuse2, ret.lock(_mapinuseoffset, 1, <span class="keyword">false</span>));</div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;              mapinuse = std::move(mapinuse2);</div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;              temph = std::move(_temph.get());</div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;            }</div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;          }</div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;          <span class="keywordflow">else</span></div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;          {</div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;            <span class="comment">// I am the first person to be using this (stale?) file, so create a new hash index file and write its path</span></div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;            ret.truncate(0);</div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;            BOOST_OUTCOME_FILTER_ERROR(_temph, <a class="code" href="classboost_1_1afio_1_1v2__xxx_1_1file__handle.html#a603b0827a9ae139b8f5806b1297fa5f0">file_handle::random_file</a>(<a class="code" href="namespaceboost_1_1afio_1_1v2__xxx.html#ad7da7a1d3240d7574fc7c6ee5831b7ee" title="Returns a path to a directory reported by the operating system to be suitable for storing temporary f...">fixme_temporary_files_directory</a>()));</div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;            temph = std::move(_temph);</div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;            <span class="keyword">auto</span> temppath(temph.path());</div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;            temph.truncate(HashIndexSize);</div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;            <span class="comment">// Write the path of my new hash index file and convert my lock to a shared one</span></div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;            {</div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;              BOOST_OUTCOME_FILTER_ERROR(_, ret.write(0, (<span class="keyword">const</span> <span class="keywordtype">char</span> *) temppath.c_str(), temppath.native().size() * <span class="keyword">sizeof</span>(*temppath.c_str())));</div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;              (void) _;</div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;            }</div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;            <span class="comment">// Convert exclusive whole file lock into lock in use</span></div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;            BOOST_OUTCOME_FILTER_ERROR(lockinuse2, ret.lock(_lockinuseoffset, 1, <span class="keyword">false</span>));</div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;            BOOST_OUTCOME_FILTER_ERROR(mapinuse2, ret.lock(_mapinuseoffset, 1, <span class="keyword">false</span>));</div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;            mapinuse = std::move(mapinuse2);</div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;            lockinuse = std::move(lockinuse2);</div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;          }</div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;          <span class="comment">// Map the files into memory, being very careful that the lock file is only ever mapped read only</span></div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;          <span class="comment">// as some OSs can get confused if you use non-mmaped writes on a region mapped for writing.</span></div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;          BOOST_OUTCOME_FILTER_ERROR(hsection, <a class="code" href="classboost_1_1afio_1_1v2__xxx_1_1section__handle.html#a09eab0e7e479b3c3a07a57567ae3e354" title="Create a memory section.">section_handle::section</a>(ret, 0, section_handle::flag::read));</div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;          BOOST_OUTCOME_FILTER_ERROR(temphsection, <a class="code" href="classboost_1_1afio_1_1v2__xxx_1_1section__handle.html#a09eab0e7e479b3c3a07a57567ae3e354" title="Create a memory section.">section_handle::section</a>(temph, HashIndexSize));</div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;          BOOST_OUTCOME_FILTER_ERROR(hmap, <a class="code" href="classboost_1_1afio_1_1v2__xxx_1_1map__handle.html#a6f0fc242efb1e28078aa13812335df3b">map_handle::map</a>(hsection, 0, 0, section_handle::flag::read));</div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;          BOOST_OUTCOME_FILTER_ERROR(temphmap, <a class="code" href="classboost_1_1afio_1_1v2__xxx_1_1map__handle.html#a6f0fc242efb1e28078aa13812335df3b">map_handle::map</a>(temphsection, HashIndexSize));</div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;          <span class="keywordflow">return</span> memory_map(std::move(ret), std::move(temph), std::move(lockinuse.get()), std::move(mapinuse), std::move(hmap), std::move(temphmap), fallbacklock);</div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;        }</div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;        BOOST_OUTCOME_CATCH_EXCEPTION_TO_RESULT(memory_map)</div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;      }</div>
</div><!-- fragment -->
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/boost/afio/v2.0/algorithm/shared_fs_mutex/<a class="el" href="memory__map_8hpp_source.html">memory_map.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceboost.html">boost</a></li><li class="navelem"><a class="el" href="namespaceboost_1_1afio.html">afio</a></li><li class="navelem"><a class="el" href="namespaceboost_1_1afio_1_1v2__xxx.html">v2_xxx</a></li><li class="navelem"><a class="el" href="namespaceboost_1_1afio_1_1v2__xxx_1_1algorithm.html">algorithm</a></li><li class="navelem"><a class="el" href="namespaceboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex.html">shared_fs_mutex</a></li><li class="navelem"><a class="el" href="classboost_1_1afio_1_1v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html">memory_map</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.3.1 </li>
  </ul>
</div>
</body>
</html>
