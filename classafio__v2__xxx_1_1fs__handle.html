<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AFIO: afio_v2_xxx::fs_handle Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AFIO
   &#160;<span id="projectnumber">v2.00 late alpha</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classafio__v2__xxx_1_1fs__handle.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classafio__v2__xxx_1_1fs__handle-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">afio_v2_xxx::fs_handle Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>A handle to something with a device and inode number.  
 <a href="classafio__v2__xxx_1_1fs__handle.html#details">More...</a></p>

<p><code>#include &quot;fs_handle.hpp&quot;</code></p>
<div class="dynheader">
Inheritance diagram for afio_v2_xxx::fs_handle:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classafio__v2__xxx_1_1fs__handle.png" usemap="#afio_5Fv2_5Fxxx::fs_5Fhandle_map" alt=""/>
  <map id="afio_5Fv2_5Fxxx::fs_5Fhandle_map" name="afio_5Fv2_5Fxxx::fs_5Fhandle_map">
<area href="classafio__v2__xxx_1_1directory__handle.html" title="A handle to a directory which can be enumerated. " alt="afio_v2_xxx::directory_handle" shape="rect" coords="0,56,198,80"/>
<area href="classafio__v2__xxx_1_1file__handle.html" title="A handle to a regular file or device, kept data layout compatible with async_file_handle. " alt="afio_v2_xxx::file_handle" shape="rect" coords="208,56,406,80"/>
<area href="classafio__v2__xxx_1_1async__file__handle.html" title="An asynchronous handle to an open something. " alt="afio_v2_xxx::async_file_handle" shape="rect" coords="104,112,302,136"/>
<area href="classafio__v2__xxx_1_1mapped__file__handle.html" title="A memory mapped regular file or device. " alt="afio_v2_xxx::mapped_file_handle" shape="rect" coords="312,112,510,136"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:afa9594900c7b43101dd736fe04107b27"><td class="memItemLeft" align="right" valign="top"><a id="afa9594900c7b43101dd736fe04107b27"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>dev_t</b> = uint64_t</td></tr>
<tr class="separator:afa9594900c7b43101dd736fe04107b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a752dc7c312bca8335642bad8645f2273"><td class="memItemLeft" align="right" valign="top"><a id="a752dc7c312bca8335642bad8645f2273"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ino_t</b> = uint64_t</td></tr>
<tr class="separator:a752dc7c312bca8335642bad8645f2273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25247b15af82faf1db557b3e45e13d7"><td class="memItemLeft" align="right" valign="top"><a id="ac25247b15af82faf1db557b3e45e13d7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classafio__v2__xxx_1_1fs__handle.html#ac25247b15af82faf1db557b3e45e13d7">path_view_type</a> = <a class="el" href="classafio__v2__xxx_1_1path__view.html">path_view</a></td></tr>
<tr class="memdesc:ac25247b15af82faf1db557b3e45e13d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The path view type used by this handle. <br /></td></tr>
<tr class="separator:ac25247b15af82faf1db557b3e45e13d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0344f48ef10fa2b94199d5566aedd879"><td class="memItemLeft" align="right" valign="top"><a id="a0344f48ef10fa2b94199d5566aedd879"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classafio__v2__xxx_1_1fs__handle.html#a0344f48ef10fa2b94199d5566aedd879">unique_id_type</a> = QUICKCPPLIB_NAMESPACE::integers128::uint128</td></tr>
<tr class="memdesc:a0344f48ef10fa2b94199d5566aedd879"><td class="mdescLeft">&#160;</td><td class="mdescRight">The unique identifier type used by this handle. <br /></td></tr>
<tr class="separator:a0344f48ef10fa2b94199d5566aedd879"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a274f5d82e11f92ed62e05919076508b8"><td class="memItemLeft" align="right" valign="top"><a id="a274f5d82e11f92ed62e05919076508b8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classafio__v2__xxx_1_1fs__handle.html#a274f5d82e11f92ed62e05919076508b8">fs_handle</a> (const <a class="el" href="classafio__v2__xxx_1_1fs__handle.html">fs_handle</a> &amp;)=delete</td></tr>
<tr class="memdesc:a274f5d82e11f92ed62e05919076508b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">No copy construction (use <code>clone()</code>) <br /></td></tr>
<tr class="separator:a274f5d82e11f92ed62e05919076508b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a334ed7c11091e8f3f83686b8aeaa1c5b"><td class="memItemLeft" align="right" valign="top"><a id="a334ed7c11091e8f3f83686b8aeaa1c5b"></a>
<a class="el" href="classafio__v2__xxx_1_1fs__handle.html">fs_handle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classafio__v2__xxx_1_1fs__handle.html#a334ed7c11091e8f3f83686b8aeaa1c5b">operator=</a> (const <a class="el" href="classafio__v2__xxx_1_1fs__handle.html">fs_handle</a> &amp;o)=delete</td></tr>
<tr class="memdesc:a334ed7c11091e8f3f83686b8aeaa1c5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">No copy assignment. <br /></td></tr>
<tr class="separator:a334ed7c11091e8f3f83686b8aeaa1c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf1012040064a3d429adfae8e6f443f0"><td class="memItemLeft" align="right" valign="top"><a id="abf1012040064a3d429adfae8e6f443f0"></a>
dev_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classafio__v2__xxx_1_1fs__handle.html#abf1012040064a3d429adfae8e6f443f0">st_dev</a> () const noexcept</td></tr>
<tr class="memdesc:abf1012040064a3d429adfae8e6f443f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unless <code>flag::disable_safety_unlinks</code> is set, the device id of the file when opened. <br /></td></tr>
<tr class="separator:abf1012040064a3d429adfae8e6f443f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f7779618e9b0e27bd1619025dcbb617"><td class="memItemLeft" align="right" valign="top"><a id="a1f7779618e9b0e27bd1619025dcbb617"></a>
ino_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classafio__v2__xxx_1_1fs__handle.html#a1f7779618e9b0e27bd1619025dcbb617">st_ino</a> () const noexcept</td></tr>
<tr class="memdesc:a1f7779618e9b0e27bd1619025dcbb617"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unless <code>flag::disable_safety_unlinks</code> is set, the inode of the file when opened. When combined with st_dev(), forms a unique identifer on this system. <br /></td></tr>
<tr class="separator:a1f7779618e9b0e27bd1619025dcbb617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a5244ab1a15053aefe93f2c253db5b3"><td class="memItemLeft" align="right" valign="top"><a id="a5a5244ab1a15053aefe93f2c253db5b3"></a>
<a class="el" href="classafio__v2__xxx_1_1fs__handle.html#a0344f48ef10fa2b94199d5566aedd879">unique_id_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classafio__v2__xxx_1_1fs__handle.html#a5a5244ab1a15053aefe93f2c253db5b3">unique_id</a> () const noexcept</td></tr>
<tr class="memdesc:a5a5244ab1a15053aefe93f2c253db5b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A unique identifier for this handle across the entire system. Can be used in hash tables etc. <br /></td></tr>
<tr class="separator:a5a5244ab1a15053aefe93f2c253db5b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaacc27a62ce0859506d7443f0d0e7adf"><td class="memItemLeft" align="right" valign="top">virtual result&lt; <a class="el" href="classafio__v2__xxx_1_1path__handle.html">path_handle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classafio__v2__xxx_1_1fs__handle.html#aaacc27a62ce0859506d7443f0d0e7adf">parent_path_handle</a> (<a class="el" href="structafio__v2__xxx_1_1deadline.html">deadline</a> d=std::chrono::seconds(30)) const noexcept</td></tr>
<tr class="separator:aaacc27a62ce0859506d7443f0d0e7adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a747962d0776c0fa9e79c9aa9b86da1c0"><td class="memItemLeft" align="right" valign="top">virtual result&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classafio__v2__xxx_1_1fs__handle.html#a747962d0776c0fa9e79c9aa9b86da1c0">relink</a> (const <a class="el" href="classafio__v2__xxx_1_1path__handle.html">path_handle</a> &amp;base, <a class="el" href="classafio__v2__xxx_1_1fs__handle.html#ac25247b15af82faf1db557b3e45e13d7">path_view_type</a> <a class="el" href="namespaceafio__v2__xxx.html#a7a98882ead35ebd6bd0700fdf571c44a">path</a>, bool atomic_replace=true, <a class="el" href="structafio__v2__xxx_1_1deadline.html">deadline</a> d=std::chrono::seconds(30)) noexcept</td></tr>
<tr class="separator:a747962d0776c0fa9e79c9aa9b86da1c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6860b9626adc4d8e6db3ebb92974c054"><td class="memItemLeft" align="right" valign="top">virtual result&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classafio__v2__xxx_1_1fs__handle.html#a6860b9626adc4d8e6db3ebb92974c054">unlink</a> (<a class="el" href="structafio__v2__xxx_1_1deadline.html">deadline</a> d=std::chrono::seconds(30)) noexcept</td></tr>
<tr class="separator:a6860b9626adc4d8e6db3ebb92974c054"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:af3d9e428b4455c34285de06387b8ee14"><td class="memItemLeft" align="right" valign="top"><a id="af3d9e428b4455c34285de06387b8ee14"></a>
result&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classafio__v2__xxx_1_1fs__handle.html#af3d9e428b4455c34285de06387b8ee14">_fetch_inode</a> () const noexcept</td></tr>
<tr class="memdesc:af3d9e428b4455c34285de06387b8ee14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill in _devid and _inode from the handle via fstat() <br /></td></tr>
<tr class="separator:af3d9e428b4455c34285de06387b8ee14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1c6b569d96ce4bd7e13ae451641e628"><td class="memItemLeft" align="right" valign="top"><a id="af1c6b569d96ce4bd7e13ae451641e628"></a>
virtual const <a class="el" href="classafio__v2__xxx_1_1handle.html">handle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>_get_handle</b> () const noexcept=0</td></tr>
<tr class="separator:af1c6b569d96ce4bd7e13ae451641e628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73339904321a53bf0ef493ecf2927d44"><td class="memItemLeft" align="right" valign="top"><a id="a73339904321a53bf0ef493ecf2927d44"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classafio__v2__xxx_1_1fs__handle.html#a73339904321a53bf0ef493ecf2927d44">fs_handle</a> ()</td></tr>
<tr class="memdesc:a73339904321a53bf0ef493ecf2927d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:a73339904321a53bf0ef493ecf2927d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45eb2220cdefa846fdb103d12a5ce485"><td class="memItemLeft" align="right" valign="top"><a id="a45eb2220cdefa846fdb103d12a5ce485"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classafio__v2__xxx_1_1fs__handle.html#a45eb2220cdefa846fdb103d12a5ce485">fs_handle</a> (dev_t devid, ino_t inode)</td></tr>
<tr class="memdesc:a45eb2220cdefa846fdb103d12a5ce485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a handle. <br /></td></tr>
<tr class="separator:a45eb2220cdefa846fdb103d12a5ce485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d68d2506b9d587e7cad8485fef9637"><td class="memItemLeft" align="right" valign="top"><a id="a10d68d2506b9d587e7cad8485fef9637"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classafio__v2__xxx_1_1fs__handle.html#a10d68d2506b9d587e7cad8485fef9637">fs_handle</a> (<a class="el" href="classafio__v2__xxx_1_1fs__handle.html">fs_handle</a> &amp;&amp;o) noexcept</td></tr>
<tr class="memdesc:a10d68d2506b9d587e7cad8485fef9637"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implicit move construction of fs_handle permitted. <br /></td></tr>
<tr class="separator:a10d68d2506b9d587e7cad8485fef9637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57612714e944a93f6e26ec66b91ffd6e"><td class="memItemLeft" align="right" valign="top"><a id="a57612714e944a93f6e26ec66b91ffd6e"></a>
<a class="el" href="classafio__v2__xxx_1_1fs__handle.html">fs_handle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classafio__v2__xxx_1_1fs__handle.html#a57612714e944a93f6e26ec66b91ffd6e">operator=</a> (<a class="el" href="classafio__v2__xxx_1_1fs__handle.html">fs_handle</a> &amp;&amp;o) noexcept</td></tr>
<tr class="memdesc:a57612714e944a93f6e26ec66b91ffd6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment of fs_handle permitted. <br /></td></tr>
<tr class="separator:a57612714e944a93f6e26ec66b91ffd6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a03d2084c14493ccb95b19503df109bba"><td class="memItemLeft" align="right" valign="top"><a id="a03d2084c14493ccb95b19503df109bba"></a>
dev_t&#160;</td><td class="memItemRight" valign="bottom"><b>_devid</b> {0}</td></tr>
<tr class="separator:a03d2084c14493ccb95b19503df109bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3620b3c68611c77dd3cd98d77c073bd2"><td class="memItemLeft" align="right" valign="top"><a id="a3620b3c68611c77dd3cd98d77c073bd2"></a>
ino_t&#160;</td><td class="memItemRight" valign="bottom"><b>_inode</b> {0}</td></tr>
<tr class="separator:a3620b3c68611c77dd3cd98d77c073bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A handle to something with a device and inode number. </p>
<dl class="section see"><dt>See also</dt><dd><code>algorithm::cached_parent_handle_adapter&lt;T&gt;</code> </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="aaacc27a62ce0859506d7443f0d0e7adf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaacc27a62ce0859506d7443f0d0e7adf">&#9670;&nbsp;</a></span>parent_path_handle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual result&lt;<a class="el" href="classafio__v2__xxx_1_1path__handle.html">path_handle</a>&gt; afio_v2_xxx::fs_handle::parent_path_handle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structafio__v2__xxx_1_1deadline.html">deadline</a>&#160;</td>
          <td class="paramname"><em>d</em> = <code>std::chrono::seconds(30)</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Obtain a handle to the path <b>currently</b> containing this handle's file entry.</p>
<dl class="section warning"><dt>Warning</dt><dd>This call is <b>racy</b> and can result in the wrong path handle being returned. Note that unless <code>flag::disable_safety_unlinks</code> is set, this implementation opens a <code>path_handle</code> to the source containing directory, then checks if the file entry within has the same inode as the open file handle. It will retry this matching until success until the deadline given.</dd></dl>
<dl class="section user"><dt>Memory Allocations</dt><dd>Calls <code>current_path()</code> and thus is both expensive and calls malloc many times.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>algorithm::cached_parent_handle_adapter&lt;T&gt;</code> which overrides this with a zero cost implementation, thus making unlinking and relinking very considerably quicker. </dd></dl>

</div>
</div>
<a id="a747962d0776c0fa9e79c9aa9b86da1c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a747962d0776c0fa9e79c9aa9b86da1c0">&#9670;&nbsp;</a></span>relink()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual result&lt;void&gt; afio_v2_xxx::fs_handle::relink </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classafio__v2__xxx_1_1path__handle.html">path_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classafio__v2__xxx_1_1fs__handle.html#ac25247b15af82faf1db557b3e45e13d7">path_view_type</a>&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>atomic_replace</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structafio__v2__xxx_1_1deadline.html">deadline</a>&#160;</td>
          <td class="paramname"><em>d</em> = <code>std::chrono::seconds(30)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Relinks the current path of this open handle to the new path specified. If <code>atomic_replace</code> is true, the relink <b>atomically</b> and silently replaces any item at the new path specified. This operation is both atomic and silent matching POSIX behaviour even on Microsoft Windows where no Win32 API can match POSIX semantics.</p>
<dl class="section warning"><dt>Warning</dt><dd>Some operating systems provide a race free syscall for renaming an open handle (Windows). On all other operating systems this call is <b>racy</b> and can result in the wrong file entry being relinked. Note that unless <code>flag::disable_safety_unlinks</code> is set, this implementation opens a <code>path_handle</code> to the source containing directory first, then checks before relinking that the item about to be relinked has the same inode as the open file handle. It will retry this matching until success until the deadline given. This should prevent most unmalicious accidental loss of data.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Base for any relative path. </td></tr>
    <tr><td class="paramname">path</td><td>The relative or absolute new path to relink to. </td></tr>
    <tr><td class="paramname">atomic_replace</td><td>Atomically replace the destination if a file entry already is present there. Choosing false for this will fail if a file entry is already present at the destination, and may not be an atomic operation on some platforms (i.e. both the old and new names may be linked to the same inode for a very short period of time). Windows and recent Linuxes are always atomic. </td></tr>
    <tr><td class="paramname">d</td><td>The deadline by which the matching of the containing directory to the open handle's inode must succeed, else <code>errc::timed_out</code> will be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Memory Allocations</dt><dd>Except on platforms with race free syscalls for renaming open handles (Windows), calls <code>current_path()</code> via <code>parent_path_handle()</code> and thus is both expensive and calls malloc many times. </dd></dl>

</div>
</div>
<a id="a6860b9626adc4d8e6db3ebb92974c054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6860b9626adc4d8e6db3ebb92974c054">&#9670;&nbsp;</a></span>unlink()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual result&lt;void&gt; afio_v2_xxx::fs_handle::unlink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structafio__v2__xxx_1_1deadline.html">deadline</a>&#160;</td>
          <td class="paramname"><em>d</em> = <code>std::chrono::seconds(30)</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unlinks the current path of this open handle, causing its entry to immediately disappear from the filing system. On Windows before Windows 10 1709 unless <code>flag::win_disable_unlink_emulation</code> is set, this behaviour is simulated by renaming the file to something random and setting its delete-on-last-close flag. Note that Windows may prevent the renaming of a file in use by another process, if so it will NOT be renamed. After the next handle to that file closes, it will become permanently unopenable by anyone else until the last handle is closed, whereupon the entry will be eventually removed by the operating system.</p>
<dl class="section warning"><dt>Warning</dt><dd>Some operating systems provide a race free syscall for unlinking an open handle (Windows). On all other operating systems this call is <b>racy</b> and can result in the wrong file entry being unlinked. Note that unless <code>flag::disable_safety_unlinks</code> is set, this implementation opens a <code>path_handle</code> to the containing directory first, then checks that the item about to be unlinked has the same inode as the open file handle. It will retry this matching until success until the deadline given. This should prevent most unmalicious accidental loss of data.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The deadline by which the matching of the containing directory to the open handle's inode must succeed, else <code>errc::timed_out</code> will be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Memory Allocations</dt><dd>Except on platforms with race free syscalls for unlinking open handles (Windows), calls <code>current_path()</code> and thus is both expensive and calls malloc many times. On Windows, also calls <code>current_path()</code> if <code>flag::disable_safety_unlinks</code> is not set. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/afio/v2.0/<a class="el" href="fs__handle_8hpp.html">fs_handle.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceafio__v2__xxx.html">afio_v2_xxx</a></li><li class="navelem"><a class="el" href="classafio__v2__xxx_1_1fs__handle.html">fs_handle</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
