<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LLFIO: llfio_v2_xxx::algorithm::shared_fs_mutex::memory_map&lt; Hasher, HashIndexSize, SpinlockType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LLFIO
   &#160;<span id="projectnumber">v2.00 late beta</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classllfio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="classllfio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">llfio_v2_xxx::algorithm::shared_fs_mutex::memory_map&lt; Hasher, HashIndexSize, SpinlockType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Many entity memory mapped shared/exclusive file system based lock.  
 <a href="classllfio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html#details">More...</a></p>

<p><code>#include &quot;memory_map.hpp&quot;</code></p>
<div class="dynheader">
Inheritance diagram for llfio_v2_xxx::algorithm::shared_fs_mutex::memory_map&lt; Hasher, HashIndexSize, SpinlockType &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classllfio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.png" usemap="#llfio_5Fv2_5Fxxx::algorithm::shared_5Ffs_5Fmutex::memory_5Fmap_3C_20Hasher_2C_20HashIndexSize_2C_20SpinlockType_20_3E_map" alt=""/>
  <map id="llfio_5Fv2_5Fxxx::algorithm::shared_5Ffs_5Fmutex::memory_5Fmap_3C_20Hasher_2C_20HashIndexSize_2C_20SpinlockType_20_3E_map" name="llfio_5Fv2_5Fxxx::algorithm::shared_5Ffs_5Fmutex::memory_5Fmap_3C_20Hasher_2C_20HashIndexSize_2C_20SpinlockType_20_3E_map">
<area href="classllfio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html" title="Abstract base class for an object which protects shared filing system resources." alt="llfio_v2_xxx::algorithm::shared_fs_mutex::shared_fs_mutex" shape="rect" coords="0,0,558,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllfio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map_1_1__entity__idx.html">_entity_idx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a578299b4449875303911db495a9a81ed"><td class="memItemLeft" align="right" valign="top"><a id="a578299b4449875303911db495a9a81ed"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html#a578299b4449875303911db495a9a81ed">entity_type</a> = <a class="el" href="structllfio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex_1_1entity__type.html">shared_fs_mutex::entity_type</a></td></tr>
<tr class="memdesc:a578299b4449875303911db495a9a81ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of an entity id. <br /></td></tr>
<tr class="separator:a578299b4449875303911db495a9a81ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2b0ba067395f1d7588e301f07110b8a"><td class="memItemLeft" align="right" valign="top"><a id="ae2b0ba067395f1d7588e301f07110b8a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html#ae2b0ba067395f1d7588e301f07110b8a">entities_type</a> = <a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html#aec91125605e5a8379b7616b7f90d1232">shared_fs_mutex::entities_type</a></td></tr>
<tr class="memdesc:ae2b0ba067395f1d7588e301f07110b8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a sequence of entities. <br /></td></tr>
<tr class="separator:ae2b0ba067395f1d7588e301f07110b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa93c292c86b6447bafd9849ad03cfe78"><td class="memItemLeft" align="right" valign="top"><a id="aa93c292c86b6447bafd9849ad03cfe78"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html#aa93c292c86b6447bafd9849ad03cfe78">hasher_type</a> = Hasher&lt; <a class="el" href="structllfio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex_1_1entity__type.html#adfb9e2612d4f570f0d3eb043bbb05d81">entity_type::value_type</a> &gt;</td></tr>
<tr class="memdesc:aa93c292c86b6447bafd9849ad03cfe78"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the hasher being used. <br /></td></tr>
<tr class="separator:aa93c292c86b6447bafd9849ad03cfe78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae61aba70c59a38a264ae2b643b791a17"><td class="memItemLeft" align="right" valign="top"><a id="ae61aba70c59a38a264ae2b643b791a17"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html#ae61aba70c59a38a264ae2b643b791a17">spinlock_type</a> = SpinlockType</td></tr>
<tr class="memdesc:ae61aba70c59a38a264ae2b643b791a17"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the spinlock being used. <br /></td></tr>
<tr class="separator:ae61aba70c59a38a264ae2b643b791a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a60b0c32576780e9588b6b58770bc849d"><td class="memItemLeft" align="right" valign="top"><a id="a60b0c32576780e9588b6b58770bc849d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html#a60b0c32576780e9588b6b58770bc849d">memory_map</a> (const <a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html">memory_map</a> &amp;)=delete</td></tr>
<tr class="memdesc:a60b0c32576780e9588b6b58770bc849d"><td class="mdescLeft">&#160;</td><td class="mdescRight">No copy construction. <br /></td></tr>
<tr class="separator:a60b0c32576780e9588b6b58770bc849d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac63248b0a6e01753c3433788c99d161c"><td class="memItemLeft" align="right" valign="top"><a id="ac63248b0a6e01753c3433788c99d161c"></a>
<a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html">memory_map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html#ac63248b0a6e01753c3433788c99d161c">operator=</a> (const <a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html">memory_map</a> &amp;)=delete</td></tr>
<tr class="memdesc:ac63248b0a6e01753c3433788c99d161c"><td class="mdescLeft">&#160;</td><td class="mdescRight">No copy assignment. <br /></td></tr>
<tr class="separator:ac63248b0a6e01753c3433788c99d161c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70d275a5256eec64030bfffa87acdb87"><td class="memItemLeft" align="right" valign="top"><a id="a70d275a5256eec64030bfffa87acdb87"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html#a70d275a5256eec64030bfffa87acdb87">memory_map</a> (<a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html">memory_map</a> &amp;&amp;o) noexcept</td></tr>
<tr class="memdesc:a70d275a5256eec64030bfffa87acdb87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. <br /></td></tr>
<tr class="separator:a70d275a5256eec64030bfffa87acdb87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96d76c6dae1f2e5c3dd4628f0a3f722f"><td class="memItemLeft" align="right" valign="top"><a id="a96d76c6dae1f2e5c3dd4628f0a3f722f"></a>
<a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html">memory_map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html#a96d76c6dae1f2e5c3dd4628f0a3f722f">operator=</a> (<a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html">memory_map</a> &amp;&amp;o) noexcept</td></tr>
<tr class="memdesc:a96d76c6dae1f2e5c3dd4628f0a3f722f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assign. <br /></td></tr>
<tr class="separator:a96d76c6dae1f2e5c3dd4628f0a3f722f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa03fdedf4112f42482cf7bc24c4f3ad"><td class="memItemLeft" align="right" valign="top"><a id="aaa03fdedf4112f42482cf7bc24c4f3ad"></a>
const <a class="el" href="classllfio__v2__xxx_1_1file__handle.html">file_handle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html#aaa03fdedf4112f42482cf7bc24c4f3ad">handle</a> () const noexcept</td></tr>
<tr class="memdesc:aaa03fdedf4112f42482cf7bc24c4f3ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the handle to file being used for this lock. <br /></td></tr>
<tr class="separator:aaa03fdedf4112f42482cf7bc24c4f3ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f7f9ad579b9fb0d3700fd31472fb95a"><td class="memItemLeft" align="right" valign="top"><a id="a5f7f9ad579b9fb0d3700fd31472fb95a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html#a5f7f9ad579b9fb0d3700fd31472fb95a">unlock</a> (<a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html#aec91125605e5a8379b7616b7f90d1232">entities_type</a> entities, unsigned long long) noexcept final</td></tr>
<tr class="memdesc:a5f7f9ad579b9fb0d3700fd31472fb95a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock a previously locked sequence of entities. <br /></td></tr>
<tr class="separator:a5f7f9ad579b9fb0d3700fd31472fb95a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cdf15b69bf6f375ec7083d639f76358"><td class="memItemLeft" align="right" valign="top"><a id="a4cdf15b69bf6f375ec7083d639f76358"></a>
<a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html#a578299b4449875303911db495a9a81ed">entity_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html#a4cdf15b69bf6f375ec7083d639f76358">entity_from_buffer</a> (const char *buffer, size_t bytes, bool exclusive=true) noexcept</td></tr>
<tr class="memdesc:a4cdf15b69bf6f375ec7083d639f76358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates an entity id from a sequence of bytes. <br /></td></tr>
<tr class="separator:a4cdf15b69bf6f375ec7083d639f76358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb28aedaf5caa53e851165a4f1927207"><td class="memTemplParams" colspan="2"><a id="afb28aedaf5caa53e851165a4f1927207"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:afb28aedaf5caa53e851165a4f1927207"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html#a578299b4449875303911db495a9a81ed">entity_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html#afb28aedaf5caa53e851165a4f1927207">entity_from_string</a> (const std::basic_string&lt; T &gt; &amp;str, bool exclusive=true) noexcept</td></tr>
<tr class="memdesc:afb28aedaf5caa53e851165a4f1927207"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates an entity id from a string. <br /></td></tr>
<tr class="separator:afb28aedaf5caa53e851165a4f1927207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d62fe0c18bcfb1ade9ff9c7bb00e70b"><td class="memItemLeft" align="right" valign="top"><a id="a8d62fe0c18bcfb1ade9ff9c7bb00e70b"></a>
<a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html#a578299b4449875303911db495a9a81ed">entity_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html#a8d62fe0c18bcfb1ade9ff9c7bb00e70b">random_entity</a> (bool exclusive=true) noexcept</td></tr>
<tr class="memdesc:a8d62fe0c18bcfb1ade9ff9c7bb00e70b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a cryptographically random entity id. <br /></td></tr>
<tr class="separator:a8d62fe0c18bcfb1ade9ff9c7bb00e70b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab33ccb32052633a55cb3bb5d1bbdf52b"><td class="memItemLeft" align="right" valign="top"><a id="ab33ccb32052633a55cb3bb5d1bbdf52b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html#ab33ccb32052633a55cb3bb5d1bbdf52b">fill_random_entities</a> (span&lt; <a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html#a578299b4449875303911db495a9a81ed">entity_type</a> &gt; seq, bool exclusive=true) noexcept</td></tr>
<tr class="memdesc:ab33ccb32052633a55cb3bb5d1bbdf52b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a sequence of entity ids with cryptographic randomness. Much faster than calling random_entity() individually. <br /></td></tr>
<tr class="separator:ab33ccb32052633a55cb3bb5d1bbdf52b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc6284803080e42505ba812d4711bb74"><td class="memItemLeft" align="right" valign="top"><a id="adc6284803080e42505ba812d4711bb74"></a>
result&lt; <a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex_1_1entities__guard.html">entities_guard</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html#adc6284803080e42505ba812d4711bb74">lock</a> (<a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html#aec91125605e5a8379b7616b7f90d1232">entities_type</a> entities, <a class="el" href="structllfio__v2__xxx_1_1deadline.html">deadline</a> d=<a class="el" href="structllfio__v2__xxx_1_1deadline.html">deadline</a>(), bool spin_not_sleep=false) noexcept</td></tr>
<tr class="memdesc:adc6284803080e42505ba812d4711bb74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock all of a sequence of entities for exclusive or shared access. <br /></td></tr>
<tr class="separator:adc6284803080e42505ba812d4711bb74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33dcc1d37df90ac5dd85a754f9ffce04"><td class="memItemLeft" align="right" valign="top"><a id="a33dcc1d37df90ac5dd85a754f9ffce04"></a>
result&lt; <a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex_1_1entities__guard.html">entities_guard</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html#a33dcc1d37df90ac5dd85a754f9ffce04">lock</a> (<a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html#a578299b4449875303911db495a9a81ed">entity_type</a> entity, <a class="el" href="structllfio__v2__xxx_1_1deadline.html">deadline</a> d=<a class="el" href="structllfio__v2__xxx_1_1deadline.html">deadline</a>(), bool spin_not_sleep=false) noexcept</td></tr>
<tr class="memdesc:a33dcc1d37df90ac5dd85a754f9ffce04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock a single entity for exclusive or shared access. <br /></td></tr>
<tr class="separator:a33dcc1d37df90ac5dd85a754f9ffce04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a051822a4942c7f45b0491ab4385aacd3"><td class="memItemLeft" align="right" valign="top"><a id="a051822a4942c7f45b0491ab4385aacd3"></a>
result&lt; <a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex_1_1entities__guard.html">entities_guard</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html#a051822a4942c7f45b0491ab4385aacd3">try_lock</a> (<a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html#aec91125605e5a8379b7616b7f90d1232">entities_type</a> entities) noexcept</td></tr>
<tr class="memdesc:a051822a4942c7f45b0491ab4385aacd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to lock all of a sequence of entities for exclusive or shared access. <br /></td></tr>
<tr class="separator:a051822a4942c7f45b0491ab4385aacd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a7f463e9235bb95ddd84b69e2642613"><td class="memItemLeft" align="right" valign="top"><a id="a5a7f463e9235bb95ddd84b69e2642613"></a>
result&lt; <a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex_1_1entities__guard.html">entities_guard</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html#a5a7f463e9235bb95ddd84b69e2642613">try_lock</a> (<a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html#a578299b4449875303911db495a9a81ed">entity_type</a> entity) noexcept</td></tr>
<tr class="memdesc:a5a7f463e9235bb95ddd84b69e2642613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to lock a single entity for exclusive or shared access. <br /></td></tr>
<tr class="separator:a5a7f463e9235bb95ddd84b69e2642613"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a23750199fded35429d27ec4824b65c18"><td class="memItemLeft" align="right" valign="top">static result&lt; <a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html">memory_map</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html#a23750199fded35429d27ec4824b65c18">fs_mutex_map</a> (const <a class="el" href="classllfio__v2__xxx_1_1path__handle.html">path_handle</a> &amp;base, <a class="el" href="classllfio__v2__xxx_1_1path__view.html">path_view</a> lockfile) noexcept</td></tr>
<tr class="separator:a23750199fded35429d27ec4824b65c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a05966ced636721856e75ed8956297113"><td class="memItemLeft" align="right" valign="top"><a id="a05966ced636721856e75ed8956297113"></a>
virtual result&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_lock</b> (<a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex_1_1entities__guard.html">entities_guard</a> &amp;out, <a class="el" href="structllfio__v2__xxx_1_1deadline.html">deadline</a> d, bool spin_not_sleep) noexcept final</td></tr>
<tr class="separator:a05966ced636721856e75ed8956297113"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a06b050e4190b765130522ebc0ab1c2e7"><td class="memItemLeft" align="right" valign="top"><a id="a06b050e4190b765130522ebc0ab1c2e7"></a>
static span&lt; <a class="el" href="structllfio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map_1_1__entity__idx.html">_entity_idx</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_hash_entities</b> (<a class="el" href="structllfio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map_1_1__entity__idx.html">_entity_idx</a> *entity_to_idx, <a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1shared__fs__mutex.html#aec91125605e5a8379b7616b7f90d1232">entities_type</a> &amp;entities)</td></tr>
<tr class="separator:a06b050e4190b765130522ebc0ab1c2e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;template&lt; class &gt; class Hasher = QUICKCPPLIB_NAMESPACE::algorithm::hash::fnv1a_hash, size_t HashIndexSize = 4096, class SpinlockType = QUICKCPPLIB_NAMESPACE::configurable_spinlock::shared_spinlock&lt;&gt;&gt;<br />
class llfio_v2_xxx::algorithm::shared_fs_mutex::memory_map&lt; Hasher, HashIndexSize, SpinlockType &gt;</h3>

<p>Many entity memory mapped shared/exclusive file system based lock. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Hasher</td><td>A STL compatible hash algorithm to use (defaults to <code>fnv1a_hash</code>) </td></tr>
    <tr><td class="paramname">HashIndexSize</td><td>The size in bytes of the hash index to use (defaults to 4Kb) </td></tr>
    <tr><td class="paramname">SpinlockType</td><td>The type of spinlock to use (defaults to a <code>SharedMutex</code> concept spinlock)</td></tr>
  </table>
  </dd>
</dl>
<p>This is the highest performing filing system mutex in LLFIO, but it comes with a long list of potential gotchas. It works by creating a random temporary file somewhere on the system and placing its path in a file at the lock file location. The random temporary file is mapped into memory by all processes using the lock where an open addressed hash table is kept. Each entity is hashed into somewhere in the hash table and its individual spin lock is used to implement the exclusion. As with <code>byte_ranges</code>, each entity is locked individually in sequence but if a particular lock fails, all are unlocked and the list is randomised before trying again. Because this locking implementation is entirely implemented in userspace using shared memory without any kernel syscalls, performance is probably as fast as any many-arbitrary-entity shared locking system could be.</p>
<p>As it uses shared memory, this implementation of <code>shared_fs_mutex</code> cannot work over a networked drive. If you attempt to open this lock on a network drive and the first user of the lock is not on this local machine, <code>errc::no_lock_available</code> will be returned from the constructor.</p>
<ul>
<li>Linear complexity to number of concurrent users up until hash table starts to get full or hashed entries collide.</li>
<li>Sudden power loss during use is recovered from.</li>
<li>Safe for multithreaded usage of the same instance.</li>
<li>In the lightly contended case, an order of magnitude faster than any other <code>shared_fs_mutex</code> algorithm.</li>
</ul>
<p>Caveats:</p><ul>
<li>No ability to sleep until a lock becomes free, so CPUs are spun at 100%.</li>
<li>Sudden process exit with locks held will deadlock all other users.</li>
<li>Exponential complexity to number of entities being concurrently locked.</li>
<li>Exponential complexity to concurrency if entities hash to the same cache line. Most SMP and especially NUMA systems have a finite bandwidth for atomic compare and swap operations, and every attempt to lock or unlock an entity under this implementation is several of those operations. Under heavy contention, whole system performance very noticeably nose dives from excessive atomic operations, things like audio and the mouse pointer will stutter.</li>
<li>Sometimes different entities hash to the same offset and collide with one another, causing very poor performance.</li>
<li>Memory mapped files need to be cache unified with normal i/o in your OS kernel. Known OSs which don't use a unified cache for memory mapped and normal i/o are QNX, OpenBSD. Furthermore, doing normal i/o and memory mapped i/o to the same file needs to not corrupt the file. In the past, there have been editions of the Linux kernel and the OS X kernel which did this.</li>
<li>If your OS doesn't have sane byte range locks (OS X, BSD, older Linuxes) and multiple objects in your process use the same lock file, misoperation will occur.</li>
<li><p class="startli">Requires <code>handle::current_path()</code> to be working.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000009">Todo:</a></b></dt><dd>memory_map::_hash_entities needs to hash x16, x8 and x4 at a time to encourage auto vectorisation </dd></dl>
</li>
</ul>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a23750199fded35429d27ec4824b65c18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23750199fded35429d27ec4824b65c18">&#9670;&nbsp;</a></span>fs_mutex_map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class &gt; class Hasher = QUICKCPPLIB_NAMESPACE::algorithm::hash::fnv1a_hash, size_t HashIndexSize = 4096, class SpinlockType  = QUICKCPPLIB_NAMESPACE::configurable_spinlock::shared_spinlock&lt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static result&lt;<a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html">memory_map</a>&gt; <a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html">llfio_v2_xxx::algorithm::shared_fs_mutex::memory_map</a>&lt; Hasher, HashIndexSize, SpinlockType &gt;::fs_mutex_map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllfio__v2__xxx_1_1path__handle.html">path_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1path__view.html">path_view</a>&#160;</td>
          <td class="paramname"><em>lockfile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialises a shared filing system mutex using the file at <em>lockfile</em>. </p><dl class="section user"><dt>Errors returnable\n Awaiting the clang result&lt;&gt; AST parser which auto generates all the error codes which could occur,</dt><dd>but a particularly important one is <code>errc::no_lock_available</code> which will be returned if the lock is in use by another computer on a network. </dd></dl>
<div class="fragment"><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;      {</div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;        LLFIO_LOG_FUNCTION_CALL(0);</div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;        <span class="keywordflow">try</span></div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;        {</div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;          OUTCOME_TRY(<span class="keyword">auto</span> &amp;&amp;ret, <a class="code" href="classllfio__v2__xxx_1_1file__handle.html#a09e6b3e9806b328a687a55e955b885a3">file_handle::file</a>(base, lockfile, <a class="code" href="classllfio__v2__xxx_1_1handle.html#aa3930273a2d4cabbac309e0b75701dcaaefb2a684e4afb7d55e6147fbe5a332ee">file_handle::mode::write</a>, <a class="code" href="classllfio__v2__xxx_1_1handle.html#af0b352d0f273ba6fa70c178b2c2fee42a8f0339e854eb5321306a443ce9199e1d">file_handle::creation::if_needed</a>, <a class="code" href="classllfio__v2__xxx_1_1handle.html#aecd3a7db6cee3aec07d32fe6f99e6852a0fb9cf5f04f61bb6f1151da57ceb1ca1">file_handle::caching::reads</a>));</div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;          file_handle temph;</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;          <span class="comment">// Am I the first person to this file? Lock everything exclusively</span></div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;          <span class="keyword">auto</span> lockinuse = ret.lock_file_range(_initialisingoffset, 2, <a class="code" href="namespacellfio__v2__xxx.html#ae79486289ff1386b26d1ce60bb797d33aa4293995cfbfa9ce60ce71ade2ff75f7">lock_kind::exclusive</a>, std::chrono::seconds(0));</div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;          <span class="keywordflow">if</span>(lockinuse.has_error())</div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;          {</div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;            <span class="keywordflow">if</span>(lockinuse.error() != errc::timed_out)</div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;            {</div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;              <span class="keywordflow">return</span> std::move(lockinuse).error();</div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;            }</div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;            <span class="comment">// Somebody else is also using this file, so try to read the hash index file I ought to use</span></div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;            lockinuse = ret.lock_file_range(_lockinuseoffset, 1, <a class="code" href="namespacellfio__v2__xxx.html#ae79486289ff1386b26d1ce60bb797d33a9e81e7b963c71363e2fb3eefcfecfc0e">lock_kind::shared</a>);  <span class="comment">// inuse shared access, blocking</span></div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;            <span class="keywordflow">if</span>(!lockinuse)</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;            {</div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;              <span class="keywordflow">return</span> std::move(lockinuse).error();</div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;            }</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;            <span class="keywordtype">byte</span> buffer[65536];</div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;            memset(buffer, 0, <span class="keyword">sizeof</span>(buffer));</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;            OUTCOME_TRYV(ret.read(0, {{buffer, 65535}}));</div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;            path_view temphpath(<span class="keyword">reinterpret_cast&lt;</span>filesystem::path::value_type *<span class="keyword">&gt;</span>(buffer));</div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;            result&lt;file_handle&gt; _temph(in_place_type&lt;file_handle&gt;);</div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;            _temph = <a class="code" href="classllfio__v2__xxx_1_1file__handle.html#a09e6b3e9806b328a687a55e955b885a3">file_handle::file</a>({}, temphpath, <a class="code" href="classllfio__v2__xxx_1_1handle.html#aa3930273a2d4cabbac309e0b75701dcaaefb2a684e4afb7d55e6147fbe5a332ee">file_handle::mode::write</a>, <a class="code" href="classllfio__v2__xxx_1_1handle.html#af0b352d0f273ba6fa70c178b2c2fee42aa200dcd6176417e93be2405188ae7cc9">file_handle::creation::open_existing</a>, <a class="code" href="classllfio__v2__xxx_1_1handle.html#aecd3a7db6cee3aec07d32fe6f99e6852ad5197d93c063a2b1e22d1630a39b7aef">file_handle::caching::temporary</a>);</div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;            <span class="comment">// If temp file doesn&#39;t exist, I am on a different machine</span></div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;            <span class="keywordflow">if</span>(!_temph)</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;            {</div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;              <span class="comment">// Release the exclusive lock and tell caller that this lock is not available</span></div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;              <span class="keywordflow">return</span> errc::no_lock_available;</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;            }</div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;            temph = std::move(_temph.value());</div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;            <span class="comment">// Map the hash index file into memory for read/write access</span></div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;            OUTCOME_TRY(<span class="keyword">auto</span> &amp;&amp;temphsection, <a class="code" href="classllfio__v2__xxx_1_1section__handle.html#a00db3d1bbffbdb4237401568c441da21">section_handle::section</a>(temph, HashIndexSize));</div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;            OUTCOME_TRY(<span class="keyword">auto</span> &amp;&amp;temphmap, <a class="code" href="classllfio__v2__xxx_1_1map__handle.html#adf0cad925c9d6accd5bd7fc3aa49884c">map_handle::map</a>(temphsection, HashIndexSize));</div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;            <span class="comment">// Map the path file into memory with its maximum possible size, read only</span></div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;            OUTCOME_TRY(<span class="keyword">auto</span> &amp;&amp;hsection, <a class="code" href="classllfio__v2__xxx_1_1section__handle.html#a00db3d1bbffbdb4237401568c441da21">section_handle::section</a>(ret, 65536, <a class="code" href="namespacellfio__v2__xxx.html#af678f58d20e1f0962ff0744150342683">section_handle::flag::read</a>));</div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;            OUTCOME_TRY(<span class="keyword">auto</span> &amp;&amp;hmap, <a class="code" href="classllfio__v2__xxx_1_1map__handle.html#adf0cad925c9d6accd5bd7fc3aa49884c">map_handle::map</a>(hsection, 0, 0, <a class="code" href="namespacellfio__v2__xxx.html#af678f58d20e1f0962ff0744150342683">section_handle::flag::read</a>));</div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;            <span class="keywordflow">return</span> memory_map(std::move(ret), std::move(temph), std::move(lockinuse.value()), std::move(hmap), std::move(temphmap));</div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;          }</div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160; </div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;          <span class="comment">// I am the first person to be using this (stale?) file, so create a new hash index file in /tmp</span></div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;          <span class="keyword">auto</span> &amp;tempdirh = <a class="code" href="namespacellfio__v2__xxx_1_1path__discovery.html#ade18f14d3ef37488e8967c87faa04d29">path_discovery::memory_backed_temporary_files_directory</a>().<a class="code" href="classllfio__v2__xxx_1_1handle.html#a5c7f6a0a8ffdea22763c75a9319ba0c2">is_valid</a>() ? <a class="code" href="namespacellfio__v2__xxx_1_1path__discovery.html#ade18f14d3ef37488e8967c87faa04d29">path_discovery::memory_backed_temporary_files_directory</a>() : path_discovery::<a class="code" href="namespacellfio__v2__xxx_1_1path__discovery.html#a2dd74ea752f3f511d58ccccdcac7f4fd">storage_backed_temporary_files_directory</a>();</div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;          OUTCOME_TRY(<span class="keyword">auto</span> &amp;&amp;_temph, <a class="code" href="classllfio__v2__xxx_1_1file__handle.html#a8b7aa986243527fe224425f61c179709">file_handle::uniquely_named_file</a>(tempdirh));</div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;          temph = std::move(_temph);</div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;          <span class="comment">// Truncate it out to the hash index size, and map it into memory for read/write access</span></div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;          OUTCOME_TRYV(temph.truncate(HashIndexSize));</div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;          OUTCOME_TRY(<span class="keyword">auto</span> &amp;&amp;temphsection, <a class="code" href="classllfio__v2__xxx_1_1section__handle.html#a00db3d1bbffbdb4237401568c441da21">section_handle::section</a>(temph, HashIndexSize));</div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;          OUTCOME_TRY(<span class="keyword">auto</span> &amp;&amp;temphmap, <a class="code" href="classllfio__v2__xxx_1_1map__handle.html#adf0cad925c9d6accd5bd7fc3aa49884c">map_handle::map</a>(temphsection, HashIndexSize));</div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;          <span class="comment">// Write the path of my new hash index file, padding zeros to the nearest page size</span></div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;          <span class="comment">// multiple to work around a race condition in the Linux kernel</span></div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;          OUTCOME_TRY(<span class="keyword">auto</span> &amp;&amp;temppath, temph.current_path());</div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;          <span class="keywordtype">char</span> buffer[4096];</div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;          memset(buffer, 0, <span class="keyword">sizeof</span>(buffer));</div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;          <span class="keywordtype">size_t</span> bytes = temppath.native().size() * <span class="keyword">sizeof</span>(*temppath.c_str());</div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;          file_handle::const_buffer_type buffers[] = {{<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">byte</span> *<span class="keyword">&gt;</span>(temppath.c_str()), bytes}, {<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">byte</span> *<span class="keyword">&gt;</span>(buffer), 4096 - (bytes % 4096)}};</div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;          OUTCOME_TRYV(ret.truncate(65536));</div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;          OUTCOME_TRYV(ret.write({buffers, 0}));</div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;          <span class="comment">// Map for read the maximum possible path file size, again to avoid race problems</span></div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;          OUTCOME_TRY(<span class="keyword">auto</span> &amp;&amp;hsection, <a class="code" href="classllfio__v2__xxx_1_1section__handle.html#a00db3d1bbffbdb4237401568c441da21">section_handle::section</a>(ret, 65536, <a class="code" href="namespacellfio__v2__xxx.html#af678f58d20e1f0962ff0744150342683">section_handle::flag::read</a>));</div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;          OUTCOME_TRY(<span class="keyword">auto</span> &amp;&amp;hmap, <a class="code" href="classllfio__v2__xxx_1_1map__handle.html#adf0cad925c9d6accd5bd7fc3aa49884c">map_handle::map</a>(hsection, 0, 0, <a class="code" href="namespacellfio__v2__xxx.html#af678f58d20e1f0962ff0744150342683">section_handle::flag::read</a>));</div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;          <span class="comment">/* Take shared locks on inuse. Even if this implementation doesn&#39;t implement</span></div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;<span class="comment">          atomic downgrade of exclusive range to shared range, we&#39;re fully prepared for other users</span></div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;<span class="comment">          now. The _initialisingoffset remains exclusive to prevent double entry into this init routine.</span></div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;<span class="comment">          */</span></div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;          OUTCOME_TRY(<span class="keyword">auto</span> &amp;&amp;lockinuse2, ret.lock_file_range(_lockinuseoffset, 1, <a class="code" href="namespacellfio__v2__xxx.html#ae79486289ff1386b26d1ce60bb797d33a9e81e7b963c71363e2fb3eefcfecfc0e">lock_kind::shared</a>));</div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;          lockinuse = std::move(lockinuse2);  <span class="comment">// releases exclusive lock on all three offsets</span></div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;          <span class="keywordflow">return</span> memory_map(std::move(ret), std::move(temph), std::move(lockinuse.value()), std::move(hmap), std::move(temphmap));</div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;        }</div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;        <span class="keywordflow">catch</span>(...)</div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;        {</div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;          <span class="keywordflow">return</span> error_from_exception();</div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;        }</div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;      }</div>
</div><!-- fragment -->
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/llfio/v2.0/algorithm/shared_fs_mutex/<a class="el" href="memory__map_8hpp.html">memory_map.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="anamespacellfio__v2__xxx_html_ae79486289ff1386b26d1ce60bb797d33aa4293995cfbfa9ce60ce71ade2ff75f7"><div class="ttname"><a href="namespacellfio__v2__xxx.html#ae79486289ff1386b26d1ce60bb797d33aa4293995cfbfa9ce60ce71ade2ff75f7">llfio_v2_xxx::lock_kind::exclusive</a></div><div class="ttdeci">@ exclusive</div><div class="ttdoc">Exclude those requesting any kind of lock on the same inode.</div></div>
<div class="ttc" id="aclassllfio__v2__xxx_1_1section__handle_html_a00db3d1bbffbdb4237401568c441da21"><div class="ttname"><a href="classllfio__v2__xxx_1_1section__handle.html#a00db3d1bbffbdb4237401568c441da21">llfio_v2_xxx::section_handle::section</a></div><div class="ttdeci">static result&lt; section_handle &gt; section(file_handle &amp;backing, extent_type maximum_size, flag _flag) noexcept</div><div class="ttdoc">Create a memory section backed by a file.</div></div>
<div class="ttc" id="aclassllfio__v2__xxx_1_1handle_html_af0b352d0f273ba6fa70c178b2c2fee42a8f0339e854eb5321306a443ce9199e1d"><div class="ttname"><a href="classllfio__v2__xxx_1_1handle.html#af0b352d0f273ba6fa70c178b2c2fee42a8f0339e854eb5321306a443ce9199e1d">llfio_v2_xxx::handle::creation::if_needed</a></div><div class="ttdeci">@ if_needed</div><div class="ttdoc">If filesystem entry exists that is used, else one is created.</div></div>
<div class="ttc" id="aclassllfio__v2__xxx_1_1map__handle_html_adf0cad925c9d6accd5bd7fc3aa49884c"><div class="ttname"><a href="classllfio__v2__xxx_1_1map__handle.html#adf0cad925c9d6accd5bd7fc3aa49884c">llfio_v2_xxx::map_handle::map</a></div><div class="ttdeci">static result&lt; map_handle &gt; map(size_type bytes, bool zeroed=false, section_handle::flag _flag=section_handle::flag::readwrite) noexcept</div></div>
<div class="ttc" id="anamespacellfio__v2__xxx_html_ae79486289ff1386b26d1ce60bb797d33a9e81e7b963c71363e2fb3eefcfecfc0e"><div class="ttname"><a href="namespacellfio__v2__xxx.html#ae79486289ff1386b26d1ce60bb797d33a9e81e7b963c71363e2fb3eefcfecfc0e">llfio_v2_xxx::lock_kind::shared</a></div><div class="ttdeci">@ shared</div><div class="ttdoc">Exclude only those requesting an exclusive lock on the same inode.</div></div>
<div class="ttc" id="aclassllfio__v2__xxx_1_1file__handle_html_a8b7aa986243527fe224425f61c179709"><div class="ttname"><a href="classllfio__v2__xxx_1_1file__handle.html#a8b7aa986243527fe224425f61c179709">llfio_v2_xxx::file_handle::uniquely_named_file</a></div><div class="ttdeci">static result&lt; file_handle &gt; uniquely_named_file(const path_handle &amp;dirpath, mode _mode=mode::write, caching _caching=caching::temporary, flag flags=flag::none) noexcept</div><div class="ttdef"><b>Definition:</b> file_handle.hpp:163</div></div>
<div class="ttc" id="aclassllfio__v2__xxx_1_1handle_html_a5c7f6a0a8ffdea22763c75a9319ba0c2"><div class="ttname"><a href="classllfio__v2__xxx_1_1handle.html#a5c7f6a0a8ffdea22763c75a9319ba0c2">llfio_v2_xxx::handle::is_valid</a></div><div class="ttdeci">bool is_valid() const noexcept</div><div class="ttdoc">True if the handle is valid (and usually open)</div><div class="ttdef"><b>Definition:</b> handle.hpp:337</div></div>
<div class="ttc" id="aclassllfio__v2__xxx_1_1file__handle_html_a09e6b3e9806b328a687a55e955b885a3"><div class="ttname"><a href="classllfio__v2__xxx_1_1file__handle.html#a09e6b3e9806b328a687a55e955b885a3">llfio_v2_xxx::file_handle::file</a></div><div class="ttdeci">static result&lt; file_handle &gt; file(const path_handle &amp;base, path_view_type path, mode _mode=mode::read, creation _creation=creation::open_existing, caching _caching=caching::all, flag flags=flag::none) noexcept</div></div>
<div class="ttc" id="aclassllfio__v2__xxx_1_1handle_html_aecd3a7db6cee3aec07d32fe6f99e6852a0fb9cf5f04f61bb6f1151da57ceb1ca1"><div class="ttname"><a href="classllfio__v2__xxx_1_1handle.html#aecd3a7db6cee3aec07d32fe6f99e6852a0fb9cf5f04f61bb6f1151da57ceb1ca1">llfio_v2_xxx::handle::caching::reads</a></div><div class="ttdeci">@ reads</div><div class="ttdoc">Cache reads only. Writes of data and metadata do not complete until reaching storage (O_SYNC)....</div></div>
<div class="ttc" id="anamespacellfio__v2__xxx_1_1path__discovery_html_a2dd74ea752f3f511d58ccccdcac7f4fd"><div class="ttname"><a href="namespacellfio__v2__xxx_1_1path__discovery.html#a2dd74ea752f3f511d58ccccdcac7f4fd">llfio_v2_xxx::path_discovery::storage_backed_temporary_files_directory</a></div><div class="ttdeci">const path_handle &amp; storage_backed_temporary_files_directory() noexcept</div><div class="ttdoc">Returns a reference to an open handle to a verified temporary directory where files created are store...</div></div>
<div class="ttc" id="anamespacellfio__v2__xxx_1_1path__discovery_html_ade18f14d3ef37488e8967c87faa04d29"><div class="ttname"><a href="namespacellfio__v2__xxx_1_1path__discovery.html#ade18f14d3ef37488e8967c87faa04d29">llfio_v2_xxx::path_discovery::memory_backed_temporary_files_directory</a></div><div class="ttdeci">const path_handle &amp; memory_backed_temporary_files_directory() noexcept</div><div class="ttdoc">Returns a reference to an open handle to a verified temporary directory where files created are store...</div></div>
<div class="ttc" id="aclassllfio__v2__xxx_1_1handle_html_aecd3a7db6cee3aec07d32fe6f99e6852ad5197d93c063a2b1e22d1630a39b7aef"><div class="ttname"><a href="classllfio__v2__xxx_1_1handle.html#aecd3a7db6cee3aec07d32fe6f99e6852ad5197d93c063a2b1e22d1630a39b7aef">llfio_v2_xxx::handle::caching::temporary</a></div><div class="ttdeci">@ temporary</div><div class="ttdoc">Cache reads and writes of data and metadata so they complete immediately, only sending any updates to...</div></div>
<div class="ttc" id="aclassllfio__v2__xxx_1_1handle_html_af0b352d0f273ba6fa70c178b2c2fee42aa200dcd6176417e93be2405188ae7cc9"><div class="ttname"><a href="classllfio__v2__xxx_1_1handle.html#af0b352d0f273ba6fa70c178b2c2fee42aa200dcd6176417e93be2405188ae7cc9">llfio_v2_xxx::handle::creation::open_existing</a></div><div class="ttdeci">@ open_existing</div><div class="ttdoc">Filesystem entry must already exist.</div></div>
<div class="ttc" id="aclassllfio__v2__xxx_1_1handle_html_aa3930273a2d4cabbac309e0b75701dcaaefb2a684e4afb7d55e6147fbe5a332ee"><div class="ttname"><a href="classllfio__v2__xxx_1_1handle.html#aa3930273a2d4cabbac309e0b75701dcaaefb2a684e4afb7d55e6147fbe5a332ee">llfio_v2_xxx::handle::mode::write</a></div><div class="ttdeci">@ write</div><div class="ttdoc">Ability to read and write (READ_CONTROL|FILE_READ_DATA|FILE_READ_ATTRIBUTES|FILE_READ_EA|FILE_WRITE_D...</div></div>
<div class="ttc" id="anamespacellfio__v2__xxx_html_af678f58d20e1f0962ff0744150342683"><div class="ttname"><a href="namespacellfio__v2__xxx.html#af678f58d20e1f0962ff0744150342683">llfio_v2_xxx::read</a></div><div class="ttdeci">file_handle::io_result&lt; file_handle::size_type &gt; read(file_handle &amp;self, file_handle::extent_type offset, std::initializer_list&lt; file_handle::buffer_type &gt; lst, deadline d=deadline()) noexcept</div><div class="ttdoc">This is an overloaded member function, provided for convenience. It differs from the above function o...</div><div class="ttdef"><b>Definition:</b> file_handle.hpp:479</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacellfio__v2__xxx.html">llfio_v2_xxx</a></li><li class="navelem"><a class="el" href="namespacellfio__v2__xxx_1_1algorithm.html">algorithm</a></li><li class="navelem"><a class="el" href="namespacellfio__v2__xxx_1_1algorithm_1_1shared__fs__mutex.html">shared_fs_mutex</a></li><li class="navelem"><a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1shared__fs__mutex_1_1memory__map.html">memory_map</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
