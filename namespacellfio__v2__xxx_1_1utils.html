<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LLFIO: llfio_v2_xxx::utils Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LLFIO<span id="projectnumber">&#160;v2.00</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespacellfio__v2__xxx_1_1utils.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">llfio_v2_xxx::utils Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Utility routines often useful when using LLFIO.  
<a href="namespacellfio__v2__xxx_1_1utils.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1utils_1_1page__allocator.html">page_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An STL allocator which allocates large TLB page memory.  <a href="classllfio__v2__xxx_1_1utils_1_1page__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1utils_1_1page__allocator_3_01void_01_4.html">page_allocator&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllfio__v2__xxx_1_1utils_1_1process__cpu__usage.html">process_cpu_usage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPU usage statistics for a process.  <a href="structllfio__v2__xxx_1_1utils_1_1process__cpu__usage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllfio__v2__xxx_1_1utils_1_1process__memory__usage.html">process_memory_usage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory usage statistics for a process.  <a href="structllfio__v2__xxx_1_1utils_1_1process__memory__usage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a42fc69cae3dbbf66498545cbe358e2ba" id="r_a42fc69cae3dbbf66498545cbe358e2ba"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx_1_1utils.html#a42fc69cae3dbbf66498545cbe358e2ba">page_size</a> () noexcept</td></tr>
<tr class="memdesc:a42fc69cae3dbbf66498545cbe358e2ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smallest page size of this architecture which is useful for calculating direct i/o multiples.  <br /></td></tr>
<tr class="separator:a42fc69cae3dbbf66498545cbe358e2ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5499feaf6b774e774a26e7decd11e3fa" id="r_a5499feaf6b774e774a26e7decd11e3fa"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5499feaf6b774e774a26e7decd11e3fa"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx_1_1utils.html#a5499feaf6b774e774a26e7decd11e3fa">round_down_to_page_size</a> (T i, size_t pagesize) noexcept</td></tr>
<tr class="memdesc:a5499feaf6b774e774a26e7decd11e3fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round a value to its next lowest page size multiple.  <br /></td></tr>
<tr class="separator:a5499feaf6b774e774a26e7decd11e3fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f8f31f6b93293a22a4b30d686eb3af" id="r_a67f8f31f6b93293a22a4b30d686eb3af"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a67f8f31f6b93293a22a4b30d686eb3af"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx_1_1utils.html#a67f8f31f6b93293a22a4b30d686eb3af">round_up_to_page_size</a> (T i, size_t pagesize) noexcept</td></tr>
<tr class="memdesc:a67f8f31f6b93293a22a4b30d686eb3af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round a value to its next highest page size multiple.  <br /></td></tr>
<tr class="separator:a67f8f31f6b93293a22a4b30d686eb3af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9604125bed1c88ba929da90c2e22d0b" id="r_ab9604125bed1c88ba929da90c2e22d0b"><td class="memTemplParams" colspan="2">template&lt;class T , typename  = decltype(  std::declval&lt;T&gt;().data()  ), typename  = decltype(  std::declval&lt;T&gt;().size()  )&gt; </td></tr>
<tr class="memitem:ab9604125bed1c88ba929da90c2e22d0b"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx_1_1utils.html#ab9604125bed1c88ba929da90c2e22d0b">round_to_page_size_larger</a> (T i, size_t pagesize) noexcept</td></tr>
<tr class="memdesc:ab9604125bed1c88ba929da90c2e22d0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round a pair of a pointer and a size_t to their nearest page size multiples. The pointer will be rounded down, the size_t upwards.  <br /></td></tr>
<tr class="separator:ab9604125bed1c88ba929da90c2e22d0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b393e84ce0a5e3715c50017feebc28d" id="r_a8b393e84ce0a5e3715c50017feebc28d"><td class="memTemplParams" colspan="2">template&lt;class T , typename  = decltype(  std::declval&lt;T&gt;().data()  ), typename  = decltype(  std::declval&lt;T&gt;().size()  )&gt; </td></tr>
<tr class="memitem:a8b393e84ce0a5e3715c50017feebc28d"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx_1_1utils.html#a8b393e84ce0a5e3715c50017feebc28d">round_to_page_size_smaller</a> (T i, size_t pagesize) noexcept</td></tr>
<tr class="memdesc:a8b393e84ce0a5e3715c50017feebc28d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round a pair of a pointer and a size_t to their nearest page size multiples. The pointer will be rounded upwards, the size_t downwards.  <br /></td></tr>
<tr class="separator:a8b393e84ce0a5e3715c50017feebc28d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab393d62affdbf1fe3eef1f321dd6f29a" id="r_ab393d62affdbf1fe3eef1f321dd6f29a"><td class="memTemplParams" colspan="2">template&lt;class A , class B &gt; </td></tr>
<tr class="memitem:ab393d62affdbf1fe3eef1f321dd6f29a"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; A, B &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx_1_1utils.html#ab393d62affdbf1fe3eef1f321dd6f29a">round_to_page_size_larger</a> (std::pair&lt; A, B &gt; i, size_t pagesize) noexcept</td></tr>
<tr class="memdesc:ab393d62affdbf1fe3eef1f321dd6f29a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round a pair of values to their nearest page size multiples. The first will be rounded down, the second upwards.  <br /></td></tr>
<tr class="separator:ab393d62affdbf1fe3eef1f321dd6f29a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06dc4d96bd914f5ae3295eb516bb4d88" id="r_a06dc4d96bd914f5ae3295eb516bb4d88"><td class="memTemplParams" colspan="2">template&lt;class A , class B &gt; </td></tr>
<tr class="memitem:a06dc4d96bd914f5ae3295eb516bb4d88"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; A, B &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx_1_1utils.html#a06dc4d96bd914f5ae3295eb516bb4d88">round_to_page_size_smaller</a> (std::pair&lt; A, B &gt; i, size_t pagesize) noexcept</td></tr>
<tr class="memdesc:a06dc4d96bd914f5ae3295eb516bb4d88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round a pair of values to their nearest page size multiples. The first will be rounded upwards, the second downwards.  <br /></td></tr>
<tr class="separator:a06dc4d96bd914f5ae3295eb516bb4d88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a891615592bb7e147c70e4423d8dc1fdd" id="r_a891615592bb7e147c70e4423d8dc1fdd"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; size_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx_1_1utils.html#a891615592bb7e147c70e4423d8dc1fdd">page_sizes</a> (bool only_actually_available=true)</td></tr>
<tr class="memdesc:a891615592bb7e147c70e4423d8dc1fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the page sizes of this architecture which is useful for calculating direct i/o multiples.  <br /></td></tr>
<tr class="separator:a891615592bb7e147c70e4423d8dc1fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d8f94ddb6e026f931e86d0dc904778" id="r_a90d8f94ddb6e026f931e86d0dc904778"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx_1_1utils.html#a90d8f94ddb6e026f931e86d0dc904778">file_buffer_default_size</a> ()</td></tr>
<tr class="memdesc:a90d8f94ddb6e026f931e86d0dc904778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reasonable default size for page_allocator, typically the closest page size from page_sizes() to 1Mb.  <br /></td></tr>
<tr class="separator:a90d8f94ddb6e026f931e86d0dc904778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae61e2de30b06776a1c24643a1d1dc64e" id="r_ae61e2de30b06776a1c24643a1d1dc64e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx_1_1utils.html#ae61e2de30b06776a1c24643a1d1dc64e">random_fill</a> (char *buffer, size_t bytes) noexcept</td></tr>
<tr class="memdesc:ae61e2de30b06776a1c24643a1d1dc64e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the buffer supplied with cryptographically strong randomness. Uses the OS kernel API.  <br /></td></tr>
<tr class="separator:ae61e2de30b06776a1c24643a1d1dc64e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a29cf29a4b097411f6c1e5274bfb417" id="r_a6a29cf29a4b097411f6c1e5274bfb417"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx_1_1utils.html#a6a29cf29a4b097411f6c1e5274bfb417">random_string</a> (size_t randomlen)</td></tr>
<tr class="memdesc:a6a29cf29a4b097411f6c1e5274bfb417"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a cryptographically random string capable of being used as a filename. Essentially random_fill() + to_hex_string().  <br /></td></tr>
<tr class="separator:a6a29cf29a4b097411f6c1e5274bfb417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8162b6f1b3d45fe6ece3a7d52fb434c6" id="r_a8162b6f1b3d45fe6ece3a7d52fb434c6"><td class="memItemLeft" align="right" valign="top"><a id="a8162b6f1b3d45fe6ece3a7d52fb434c6" name="a8162b6f1b3d45fe6ece3a7d52fb434c6"></a>
result&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>flush_modified_data</b> () noexcept</td></tr>
<tr class="memdesc:a8162b6f1b3d45fe6ece3a7d52fb434c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to flush all modified data to the physical device. <br /></td></tr>
<tr class="separator:a8162b6f1b3d45fe6ece3a7d52fb434c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ecc4e275899e7f2462aaa8fd928b8f8" id="r_a6ecc4e275899e7f2462aaa8fd928b8f8"><td class="memItemLeft" align="right" valign="top">result&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx_1_1utils.html#a6ecc4e275899e7f2462aaa8fd928b8f8">drop_filesystem_cache</a> () noexcept</td></tr>
<tr class="memdesc:a6ecc4e275899e7f2462aaa8fd928b8f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to flush all modified data to the physical device, and then drop the OS filesystem cache, thus making all future reads come from the physical device. Currently only implemented for Microsoft Windows and Linux.  <br /></td></tr>
<tr class="separator:a6ecc4e275899e7f2462aaa8fd928b8f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aae80908cc5521ef67234152c5c5044" id="r_a7aae80908cc5521ef67234152c5c5044"><td class="memItemLeft" align="right" valign="top"><a id="a7aae80908cc5521ef67234152c5c5044" name="a7aae80908cc5521ef67234152c5c5044"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>running_under_wsl</b> () noexcept</td></tr>
<tr class="memdesc:a7aae80908cc5521ef67234152c5c5044"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this POSIX is running under Microsoft's Subsystem for Linux. <br /></td></tr>
<tr class="separator:a7aae80908cc5521ef67234152c5c5044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b13160cf9403f9d2ed9dd80b329cb0" id="r_ae4b13160cf9403f9d2ed9dd80b329cb0"><td class="memItemLeft" align="right" valign="top">result&lt; <a class="el" href="structllfio__v2__xxx_1_1utils_1_1process__memory__usage.html">process_memory_usage</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx_1_1utils.html#ae4b13160cf9403f9d2ed9dd80b329cb0">current_process_memory_usage</a> (process_memory_usage::want want=process_memory_usage::want::this_process) noexcept</td></tr>
<tr class="memdesc:ae4b13160cf9403f9d2ed9dd80b329cb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the current memory usage statistics for this process.  <br /></td></tr>
<tr class="separator:ae4b13160cf9403f9d2ed9dd80b329cb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07697dcb1fbe4a8757d7d1952efbe294" id="r_a07697dcb1fbe4a8757d7d1952efbe294"><td class="memItemLeft" align="right" valign="top">result&lt; <a class="el" href="structllfio__v2__xxx_1_1utils_1_1process__cpu__usage.html">process_cpu_usage</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx_1_1utils.html#a07697dcb1fbe4a8757d7d1952efbe294">current_process_cpu_usage</a> () noexcept</td></tr>
<tr class="memdesc:a07697dcb1fbe4a8757d7d1952efbe294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the current CPU usage statistics for this system and this process. These are unsigned counters which always increment, and so may eventually wrap.  <br /></td></tr>
<tr class="separator:a07697dcb1fbe4a8757d7d1952efbe294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae880ebd5681dcf6b700d67fb10b4547e" id="r_ae880ebd5681dcf6b700d67fb10b4547e"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ae880ebd5681dcf6b700d67fb10b4547e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx_1_1utils.html#ae880ebd5681dcf6b700d67fb10b4547e">operator==</a> (const <a class="el" href="classllfio__v2__xxx_1_1utils_1_1page__allocator.html">page_allocator</a>&lt; T &gt; &amp;, const <a class="el" href="classllfio__v2__xxx_1_1utils_1_1page__allocator.html">page_allocator</a>&lt; U &gt; &amp;) noexcept</td></tr>
<tr class="separator:ae880ebd5681dcf6b700d67fb10b4547e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Utility routines often useful when using LLFIO. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a07697dcb1fbe4a8757d7d1952efbe294" name="a07697dcb1fbe4a8757d7d1952efbe294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07697dcb1fbe4a8757d7d1952efbe294">&#9670;&#160;</a></span>current_process_cpu_usage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result&lt; <a class="el" href="structllfio__v2__xxx_1_1utils_1_1process__cpu__usage.html">process_cpu_usage</a> &gt; llfio_v2_xxx::utils::current_process_cpu_usage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the current CPU usage statistics for this system and this process. These are unsigned counters which always increment, and so may eventually wrap. </p>
<p>The simplest way to use this API is to call it whilst also taking the current monotonic clock/CPU TSC and then calculating the delta change over that period of time.</p>
<dl class="section note"><dt>Note</dt><dd>The returned values may not be a snapshot accurate against one another as they may get derived from multiple sources. Also, granularity is probably either a lot more than one nanosecond on most platforms, but may be CPU TSC based on others (you can test it to be sure).</dd>
<dd>
Within some versions of Docker, the per-process counters are not available. </dd></dl>

</div>
</div>
<a id="ae4b13160cf9403f9d2ed9dd80b329cb0" name="ae4b13160cf9403f9d2ed9dd80b329cb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4b13160cf9403f9d2ed9dd80b329cb0">&#9670;&#160;</a></span>current_process_memory_usage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result&lt; <a class="el" href="structllfio__v2__xxx_1_1utils_1_1process__memory__usage.html">process_memory_usage</a> &gt; llfio_v2_xxx::utils::current_process_memory_usage </td>
          <td>(</td>
          <td class="paramtype">process_memory_usage::want&#160;</td>
          <td class="paramname"><em>want</em> = <code>process_memory_usage::want::this_process</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the current memory usage statistics for this process. </p>
<p>Be aware that because Linux provides no summary counter for <code>private_committed</code>, we have to manually parse through <code>/proc/pid/smaps</code> to calculate it. This can start to take seconds for a process with a complex virtual memory space. If you are sure that you never use <code>section_handle::flag::nocommit</code> without <code>section_handle::flag::none</code> (i.e. you don't nocommit accessible memory), then specifying the flag <code>process_memory_usage::want::private_committed_inaccurate</code> can yield significant performance gains. If you set <code>process_memory_usage::want::private_committed_inaccurate</code>, we use <code>/proc/pid/smaps_rollup</code> and <code>/proc/pid/maps</code> to calculate the results. This cannot distinguish between regions with the accounted flag enabled or disabled, and be aware that glibc's <code>malloc()</code> for some inexplicable reason doesn't set the accounted flag on regions it commits, so the inaccurate flag will always yield higher numbers for private commited on Linux. By default, this fast path is enabled.</p>
<dl class="section note"><dt>Note</dt><dd><code>/proc/pid/smaps_rollup</code> was added in Linux kernel 3.16, so the default specifying <code>process_memory_usage::want::private_committed_inaccurate</code> will always fail on Linux kernels preceding that with an error code comparing equal to <code>errc::operation_not_supported</code>. As one would assume users would prefer this operation to fail on older kernels rather than silently go slowly in complex memory spaces, it is left opt-in to request the accurate implementation which works on older Linux kernels. Or, just don't request <code>private_committed</code> at all, and pretend <code>private_paged_in</code> means the same thing.</dd>
<dd>
Mac OS provides no way of reading how much memory a process has committed. We therefore supply as <code>private_committed</code> the same value as <code>private_paged_in</code>. </dd></dl>

</div>
</div>
<a id="a6ecc4e275899e7f2462aaa8fd928b8f8" name="a6ecc4e275899e7f2462aaa8fd928b8f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ecc4e275899e7f2462aaa8fd928b8f8">&#9670;&#160;</a></span>drop_filesystem_cache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result&lt; void &gt; llfio_v2_xxx::utils::drop_filesystem_cache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to flush all modified data to the physical device, and then drop the OS filesystem cache, thus making all future reads come from the physical device. Currently only implemented for Microsoft Windows and Linux. </p>
<p>Note that the OS specific magic called by this routine generally requires elevated privileges for the calling process. For obvious reasons, calling this will have a severe negative impact on performance, but it's very useful for benchmarking cold cache vs warm cache performance. </p>

</div>
</div>
<a id="a90d8f94ddb6e026f931e86d0dc904778" name="a90d8f94ddb6e026f931e86d0dc904778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90d8f94ddb6e026f931e86d0dc904778">&#9670;&#160;</a></span>file_buffer_default_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t llfio_v2_xxx::utils::file_buffer_default_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reasonable default size for page_allocator, typically the closest page size from page_sizes() to 1Mb. </p>
<dl class="section return"><dt>Returns</dt><dd>A value of a TLB large page size close to 1Mb.</dd></dl>
<dl class="section user"><dt>Complexity\nWhatever the system API takes (one would hope constant time).</dt><dd></dd></dl>
<dl class="section user"><dt>Errors returnable\nThrows any error from the operating system or std::bad_alloc.</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  131</span>  {</div>
<div class="line"><span class="lineno">  132</span>    <span class="keyword">static</span> <span class="keywordtype">size_t</span> size;</div>
<div class="line"><span class="lineno">  133</span>    <span class="keywordflow">if</span>(size == 0u)</div>
<div class="line"><span class="lineno">  134</span>    {</div>
<div class="line"><span class="lineno">  135</span>      <span class="keyword">const</span> std::vector&lt;size_t&gt; &amp;sizes = <a class="code hl_function" href="namespacellfio__v2__xxx_1_1utils.html#a891615592bb7e147c70e4423d8dc1fdd">page_sizes</a>(<span class="keyword">true</span>);</div>
<div class="line"><span class="lineno">  136</span>      <span class="keywordflow">for</span>(<span class="keyword">auto</span> &amp;i : sizes)</div>
<div class="line"><span class="lineno">  137</span>      {</div>
<div class="line"><span class="lineno">  138</span>        <span class="keywordflow">if</span>(i &gt;= 1024 * 1024)</div>
<div class="line"><span class="lineno">  139</span>        {</div>
<div class="line"><span class="lineno">  140</span>          size = i;</div>
<div class="line"><span class="lineno">  141</span>          <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  142</span>        }</div>
<div class="line"><span class="lineno">  143</span>      }</div>
<div class="line"><span class="lineno">  144</span>      <span class="keywordflow">if</span>(size == 0u)</div>
<div class="line"><span class="lineno">  145</span>      {</div>
<div class="line"><span class="lineno">  146</span>        size = 1024 * 1024;</div>
<div class="line"><span class="lineno">  147</span>      }</div>
<div class="line"><span class="lineno">  148</span>    }</div>
<div class="line"><span class="lineno">  149</span>    <span class="keywordflow">return</span> size;</div>
<div class="line"><span class="lineno">  150</span>  }</div>
<div class="ttc" id="anamespacellfio__v2__xxx_1_1utils_html_a891615592bb7e147c70e4423d8dc1fdd"><div class="ttname"><a href="namespacellfio__v2__xxx_1_1utils.html#a891615592bb7e147c70e4423d8dc1fdd">llfio_v2_xxx::utils::page_sizes</a></div><div class="ttdeci">const std::vector&lt; size_t &gt; &amp; page_sizes(bool only_actually_available=true)</div><div class="ttdoc">Returns the page sizes of this architecture which is useful for calculating direct i/o multiples.</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae880ebd5681dcf6b700d67fb10b4547e" name="ae880ebd5681dcf6b700d67fb10b4547e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae880ebd5681dcf6b700d67fb10b4547e">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool llfio_v2_xxx::utils::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllfio__v2__xxx_1_1utils_1_1page__allocator.html">page_allocator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllfio__v2__xxx_1_1utils_1_1page__allocator.html">page_allocator</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  449</span>{ <span class="keywordflow">return</span> <span class="keyword">true</span>; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a42fc69cae3dbbf66498545cbe358e2ba" name="a42fc69cae3dbbf66498545cbe358e2ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42fc69cae3dbbf66498545cbe358e2ba">&#9670;&#160;</a></span>page_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t llfio_v2_xxx::utils::page_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the smallest page size of this architecture which is useful for calculating direct i/o multiples. </p>
<dl class="section return"><dt>Returns</dt><dd>The page size of this architecture.</dd></dl>
<dl class="section user"><dt>Complexity\nWhatever the system API takes (one would hope constant time).</dt><dd></dd></dl>

</div>
</div>
<a id="a891615592bb7e147c70e4423d8dc1fdd" name="a891615592bb7e147c70e4423d8dc1fdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a891615592bb7e147c70e4423d8dc1fdd">&#9670;&#160;</a></span>page_sizes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; size_t &gt; &amp; llfio_v2_xxx::utils::page_sizes </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>only_actually_available</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the page sizes of this architecture which is useful for calculating direct i/o multiples. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">only_actually_available</td><td>Only return page sizes actually available to the user running this process </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The page sizes of this architecture.</dd></dl>
<dl class="section user"><dt>Complexity\nFirst call performs multiple memory allocations, mutex locks and system calls. Subsequent calls</dt><dd>lock mutexes. </dd></dl>
<dl class="section user"><dt>Errors returnable\nThrows any error from the operating system or std::bad_alloc.</dt><dd></dd></dl>

</div>
</div>
<a id="ae61e2de30b06776a1c24643a1d1dc64e" name="ae61e2de30b06776a1c24643a1d1dc64e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae61e2de30b06776a1c24643a1d1dc64e">&#9670;&#160;</a></span>random_fill()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void llfio_v2_xxx::utils::random_fill </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills the buffer supplied with cryptographically strong randomness. Uses the OS kernel API. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>A buffer to fill </td></tr>
    <tr><td class="paramname">bytes</td><td>How many bytes to fill</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity\nWhatever the system API takes.</dt><dd></dd></dl>
<dl class="section user"><dt>Errors returnable\nAny error from the operating system.</dt><dd></dd></dl>

</div>
</div>
<a id="a6a29cf29a4b097411f6c1e5274bfb417" name="a6a29cf29a4b097411f6c1e5274bfb417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a29cf29a4b097411f6c1e5274bfb417">&#9670;&#160;</a></span>random_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string llfio_v2_xxx::utils::random_string </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>randomlen</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a cryptographically random string capable of being used as a filename. Essentially random_fill() + to_hex_string(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">randomlen</td><td>The number of bytes of randomness to use for the string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string representing the randomness at a 2x ratio, so if 32 bytes were requested, this string would be 64 bytes long.</dd></dl>
<dl class="section user"><dt>Complexity\nWhatever the system API takes.</dt><dd></dd></dl>
<dl class="section user"><dt>Errors returnable\nAny error from the operating system.</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  171</span>  {</div>
<div class="line"><span class="lineno">  172</span>    <span class="keywordtype">size_t</span> outlen = randomlen * 2;</div>
<div class="line"><span class="lineno">  173</span>    std::string ret(outlen, 0);</div>
<div class="line"><span class="lineno">  174</span>    <a class="code hl_function" href="namespacellfio__v2__xxx_1_1utils.html#ae61e2de30b06776a1c24643a1d1dc64e">random_fill</a>(<span class="keyword">const_cast&lt;</span><span class="keywordtype">char</span> *<span class="keyword">&gt;</span>(ret.data()), randomlen);</div>
<div class="line"><span class="lineno">  175</span>    QUICKCPPLIB_NAMESPACE::algorithm::string::to_hex_string(<span class="keyword">const_cast&lt;</span><span class="keywordtype">char</span> *<span class="keyword">&gt;</span>(ret.data()), outlen, ret.data(), randomlen);</div>
<div class="line"><span class="lineno">  176</span>    <span class="keywordflow">return</span> ret;</div>
<div class="line"><span class="lineno">  177</span>  }</div>
<div class="ttc" id="anamespacellfio__v2__xxx_1_1utils_html_ae61e2de30b06776a1c24643a1d1dc64e"><div class="ttname"><a href="namespacellfio__v2__xxx_1_1utils.html#ae61e2de30b06776a1c24643a1d1dc64e">llfio_v2_xxx::utils::random_fill</a></div><div class="ttdeci">void random_fill(char *buffer, size_t bytes) noexcept</div><div class="ttdoc">Fills the buffer supplied with cryptographically strong randomness. Uses the OS kernel API.</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a5499feaf6b774e774a26e7decd11e3fa" name="a5499feaf6b774e774a26e7decd11e3fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5499feaf6b774e774a26e7decd11e3fa">&#9670;&#160;</a></span>round_down_to_page_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T llfio_v2_xxx::utils::round_down_to_page_size </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pagesize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Round a value to its next lowest page size multiple. </p>
<div class="fragment"><div class="line"><span class="lineno">   52</span>  {</div>
<div class="line"><span class="lineno">   53</span>    assert(pagesize &gt; 0);</div>
<div class="line"><span class="lineno">   54</span>    i = (T)(LLFIO_V2_NAMESPACE::detail::unsigned_integer_cast&lt;uintptr_t&gt;(i) &amp; ~(pagesize - 1));  <span class="comment">// NOLINT</span></div>
<div class="line"><span class="lineno">   55</span>    <span class="keywordflow">return</span> i;</div>
<div class="line"><span class="lineno">   56</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab393d62affdbf1fe3eef1f321dd6f29a" name="ab393d62affdbf1fe3eef1f321dd6f29a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab393d62affdbf1fe3eef1f321dd6f29a">&#9670;&#160;</a></span>round_to_page_size_larger() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; A, B &gt; llfio_v2_xxx::utils::round_to_page_size_larger </td>
          <td>(</td>
          <td class="paramtype">std::pair&lt; A, B &gt;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pagesize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Round a pair of values to their nearest page size multiples. The first will be rounded down, the second upwards. </p>
<div class="fragment"><div class="line"><span class="lineno">   93</span>  {</div>
<div class="line"><span class="lineno">   94</span>    assert(pagesize &gt; 0);</div>
<div class="line"><span class="lineno">   95</span>    <span class="keyword">const</span> <span class="keyword">auto</span> base = LLFIO_V2_NAMESPACE::detail::unsigned_integer_cast&lt;uintptr_t&gt;(i.first);</div>
<div class="line"><span class="lineno">   96</span>    i = {<span class="keyword">static_cast&lt;</span>A<span class="keyword">&gt;</span>(base &amp; ~(pagesize - 1)), <span class="keyword">static_cast&lt;</span>B<span class="keyword">&gt;</span>(((base + i.second + pagesize - 1) &amp; ~(pagesize - 1)) - (base &amp; ~(pagesize - 1)))};</div>
<div class="line"><span class="lineno">   97</span>    <span class="keywordflow">return</span> i;</div>
<div class="line"><span class="lineno">   98</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab9604125bed1c88ba929da90c2e22d0b" name="ab9604125bed1c88ba929da90c2e22d0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9604125bed1c88ba929da90c2e22d0b">&#9670;&#160;</a></span>round_to_page_size_larger() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename  = decltype(  std::declval&lt;T&gt;().data()  ), typename  = decltype(  std::declval&lt;T&gt;().size()  )&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T llfio_v2_xxx::utils::round_to_page_size_larger </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pagesize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Round a pair of a pointer and a size_t to their nearest page size multiples. The pointer will be rounded down, the size_t upwards. </p>
<div class="fragment"><div class="line"><span class="lineno">   71</span>  {</div>
<div class="line"><span class="lineno">   72</span>    assert(pagesize &gt; 0);</div>
<div class="line"><span class="lineno">   73</span>    <span class="keyword">const</span> <span class="keyword">auto</span> base = LLFIO_V2_NAMESPACE::detail::unsigned_integer_cast&lt;uintptr_t&gt;(i.data());</div>
<div class="line"><span class="lineno">   74</span>    i = {<span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">byte</span> *<span class="keyword">&gt;</span>(base &amp; ~(pagesize - 1)), ((base + i.size() + pagesize - 1) &amp; ~(pagesize - 1)) - (base &amp; ~(pagesize - 1))};</div>
<div class="line"><span class="lineno">   75</span>    <span class="keywordflow">return</span> i;</div>
<div class="line"><span class="lineno">   76</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a06dc4d96bd914f5ae3295eb516bb4d88" name="a06dc4d96bd914f5ae3295eb516bb4d88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06dc4d96bd914f5ae3295eb516bb4d88">&#9670;&#160;</a></span>round_to_page_size_smaller() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; A, B &gt; llfio_v2_xxx::utils::round_to_page_size_smaller </td>
          <td>(</td>
          <td class="paramtype">std::pair&lt; A, B &gt;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pagesize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Round a pair of values to their nearest page size multiples. The first will be rounded upwards, the second downwards. </p>
<div class="fragment"><div class="line"><span class="lineno">  103</span>  {</div>
<div class="line"><span class="lineno">  104</span>    assert(pagesize &gt; 0);</div>
<div class="line"><span class="lineno">  105</span>    <span class="keyword">const</span> <span class="keyword">auto</span> base = LLFIO_V2_NAMESPACE::detail::unsigned_integer_cast&lt;uintptr_t&gt;(i.first);</div>
<div class="line"><span class="lineno">  106</span>    i = {<span class="keyword">static_cast&lt;</span>A<span class="keyword">&gt;</span>((base + pagesize - 1) &amp; ~(pagesize - 1)),</div>
<div class="line"><span class="lineno">  107</span>         <span class="keyword">static_cast&lt;</span>B<span class="keyword">&gt;</span>(((base + i.second) &amp; ~(pagesize - 1)) - ((base + pagesize - 1) &amp; ~(pagesize - 1)))};</div>
<div class="line"><span class="lineno">  108</span>    <span class="keywordflow">return</span> i;</div>
<div class="line"><span class="lineno">  109</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8b393e84ce0a5e3715c50017feebc28d" name="a8b393e84ce0a5e3715c50017feebc28d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b393e84ce0a5e3715c50017feebc28d">&#9670;&#160;</a></span>round_to_page_size_smaller() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename  = decltype(  std::declval&lt;T&gt;().data()  ), typename  = decltype(  std::declval&lt;T&gt;().size()  )&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T llfio_v2_xxx::utils::round_to_page_size_smaller </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pagesize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Round a pair of a pointer and a size_t to their nearest page size multiples. The pointer will be rounded upwards, the size_t downwards. </p>
<div class="fragment"><div class="line"><span class="lineno">   83</span>  {</div>
<div class="line"><span class="lineno">   84</span>    assert(pagesize &gt; 0);</div>
<div class="line"><span class="lineno">   85</span>    <span class="keyword">const</span> <span class="keyword">auto</span> base = LLFIO_V2_NAMESPACE::detail::unsigned_integer_cast&lt;uintptr_t&gt;(i.data());</div>
<div class="line"><span class="lineno">   86</span>    i = {<span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">byte</span> *<span class="keyword">&gt;</span>((base + pagesize - 1) &amp; ~(pagesize - 1)), ((base + i.size()) &amp; ~(pagesize - 1)) - ((base + pagesize - 1) &amp; ~(pagesize - 1))};</div>
<div class="line"><span class="lineno">   87</span>    <span class="keywordflow">return</span> i;</div>
<div class="line"><span class="lineno">   88</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a67f8f31f6b93293a22a4b30d686eb3af" name="a67f8f31f6b93293a22a4b30d686eb3af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67f8f31f6b93293a22a4b30d686eb3af">&#9670;&#160;</a></span>round_up_to_page_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T llfio_v2_xxx::utils::round_up_to_page_size </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pagesize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Round a value to its next highest page size multiple. </p>
<div class="fragment"><div class="line"><span class="lineno">   60</span>  {</div>
<div class="line"><span class="lineno">   61</span>    assert(pagesize &gt; 0);</div>
<div class="line"><span class="lineno">   62</span>    i = (T)((LLFIO_V2_NAMESPACE::detail::unsigned_integer_cast&lt;uintptr_t&gt;(i) + pagesize - 1) &amp; ~(pagesize - 1));  <span class="comment">// NOLINT</span></div>
<div class="line"><span class="lineno">   63</span>    <span class="keywordflow">return</span> i;</div>
<div class="line"><span class="lineno">   64</span>  }</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacellfio__v2__xxx.html">llfio_v2_xxx</a></li><li class="navelem"><a class="el" href="namespacellfio__v2__xxx_1_1utils.html">utils</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
