<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LLFIO: llfio_v2_xxx::algorithm Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LLFIO<span id="projectnumber">&#160;v2.00</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespacellfio__v2__xxx_1_1algorithm.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">llfio_v2_xxx::algorithm Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Collection of file system based algorithms.  
<a href="namespacellfio__v2__xxx_1_1algorithm.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacellfio__v2__xxx_1_1algorithm_1_1impl" id="r_namespacellfio__v2__xxx_1_1algorithm_1_1impl"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx_1_1algorithm_1_1impl.html">impl</a></td></tr>
<tr class="memdesc:namespacellfio__v2__xxx_1_1algorithm_1_1impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does not exist in the actual source code, purely here to workaround doxygen limitations. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacellfio__v2__xxx_1_1algorithm_1_1shared__fs__mutex" id="r_namespacellfio__v2__xxx_1_1algorithm_1_1shared__fs__mutex"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx_1_1algorithm_1_1shared__fs__mutex.html">shared_fs_mutex</a></td></tr>
<tr class="memdesc:namespacellfio__v2__xxx_1_1algorithm_1_1shared__fs__mutex"><td class="mdescLeft">&#160;</td><td class="mdescRight">Algorithms for protecting a shared filing system resource from racy modification. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1cached__parent__handle__adapter.html">cached_parent_handle_adapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapts any <code>construct()</code>-able implementation to cache its parent directory handle in a process wide cache.  <a href="classllfio__v2__xxx_1_1algorithm_1_1cached__parent__handle__adapter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1combining__handle__adapter.html">combining_handle_adapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle combining the data from one or two other handles.  <a href="classllfio__v2__xxx_1_1algorithm_1_1combining__handle__adapter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllfio__v2__xxx_1_1algorithm_1_1compare__visitor.html">compare_visitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A visitor for the filesystem traversal and comparison algorithm.  <a href="structllfio__v2__xxx_1_1algorithm_1_1compare__visitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllfio__v2__xxx_1_1algorithm_1_1comparison__summary.html">comparison_summary</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllfio__v2__xxx_1_1algorithm_1_1contents__visitor.html">contents_visitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A visitor for the filesystem contents algorithm.  <a href="structllfio__v2__xxx_1_1algorithm_1_1contents__visitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllfio__v2__xxx_1_1algorithm_1_1reduce__visitor.html">reduce_visitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A visitor for the filesystem traversal and reduction algorithm.  <a href="structllfio__v2__xxx_1_1algorithm_1_1reduce__visitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllfio__v2__xxx_1_1algorithm_1_1summarize__visitor.html">summarize_visitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A visitor for the filesystem traversal and summary algorithm.  <a href="structllfio__v2__xxx_1_1algorithm_1_1summarize__visitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllfio__v2__xxx_1_1algorithm_1_1traversal__summary.html">traversal_summary</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A summary of a directory tree.  <a href="structllfio__v2__xxx_1_1algorithm_1_1traversal__summary.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllfio__v2__xxx_1_1algorithm_1_1traverse__visitor.html">traverse_visitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A visitor for the filesystem traversal algorithm.  <a href="structllfio__v2__xxx_1_1algorithm_1_1traverse__visitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1trivial__vector.html">trivial_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a constant time capacity expanding move-only STL vector. Requires <code>T</code> to be trivially copyable.  <a href="classllfio__v2__xxx_1_1algorithm_1_1trivial__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a27450e894b5dab6c18a01350670fa0dc" id="r_a27450e894b5dab6c18a01350670fa0dc"><td class="memTemplParams" colspan="2">template&lt;class Target , class Source &gt; </td></tr>
<tr class="memitem:a27450e894b5dab6c18a01350670fa0dc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx_1_1algorithm.html#a27450e894b5dab6c18a01350670fa0dc">xor_handle_adapter</a> = <a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1combining__handle__adapter.html">combining_handle_adapter</a>&lt; detail::xor_handle_adapter_op, Target, Source &gt;</td></tr>
<tr class="memdesc:a27450e894b5dab6c18a01350670fa0dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle combining the data from two other handles using XOR.  <br /></td></tr>
<tr class="separator:a27450e894b5dab6c18a01350670fa0dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0385b9ea365f4aa97dfa73aad2a4e656" id="r_a0385b9ea365f4aa97dfa73aad2a4e656"><td class="memItemLeft" align="right" valign="top">result&lt; file_handle::extent_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx_1_1algorithm.html#a0385b9ea365f4aa97dfa73aad2a4e656">clone_or_copy</a> (<a class="el" href="classllfio__v2__xxx_1_1file__handle.html">file_handle</a> &amp;src, const <a class="el" href="classllfio__v2__xxx_1_1path__handle.html">path_handle</a> &amp;destdir, <a class="el" href="classllfio__v2__xxx_1_1path__view.html">path_view</a> destleaf={}, bool preserve_timestamps=true, bool force_copy_now=false, <a class="el" href="classllfio__v2__xxx_1_1handle.html#af0b352d0f273ba6fa70c178b2c2fee42">file_handle::creation</a> creation=file_handle::creation::always_new, <a class="el" href="structllfio__v2__xxx_1_1deadline.html">deadline</a> d={}) noexcept</td></tr>
<tr class="memdesc:a0385b9ea365f4aa97dfa73aad2a4e656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone or copy the extents of the filesystem entity identified by <code>src</code> to <code>destdir</code> optionally renamed to <code>destleaf</code>.  <br /></td></tr>
<tr class="separator:a0385b9ea365f4aa97dfa73aad2a4e656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cd989e756e0f4a663ba6ab8fd398d42" id="r_a2cd989e756e0f4a663ba6ab8fd398d42"><td class="memItemLeft" align="right" valign="top">result&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx_1_1algorithm.html#a2cd989e756e0f4a663ba6ab8fd398d42">relink_or_clone_copy_unlink</a> (<a class="el" href="classllfio__v2__xxx_1_1file__handle.html">file_handle</a> &amp;src, const <a class="el" href="classllfio__v2__xxx_1_1path__handle.html">path_handle</a> &amp;destdir, <a class="el" href="classllfio__v2__xxx_1_1path__view.html">path_view</a> destleaf={}, bool atomic_replace=true, bool preserve_timestamps=true, bool force_copy_now=false, <a class="el" href="structllfio__v2__xxx_1_1deadline.html">deadline</a> d={}) noexcept</td></tr>
<tr class="memdesc:a2cd989e756e0f4a663ba6ab8fd398d42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relink or clone-unlink/copy-unlink the extents of the filesystem entity identified by <code>src</code> to <code>destdir</code> optionally renamed to <code>destleaf</code>. This lets you relink files across filing systems, with as close as possible matching of semantics to atomic relinking.  <br /></td></tr>
<tr class="separator:a2cd989e756e0f4a663ba6ab8fd398d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a887fc89f3b55416d6ce4ee69a3dc0146" id="r_a887fc89f3b55416d6ce4ee69a3dc0146"><td class="memItemLeft" align="right" valign="top">result&lt; <a class="el" href="structllfio__v2__xxx_1_1algorithm_1_1contents__visitor_1_1contents__type.html">contents_visitor::contents_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx_1_1algorithm.html#a887fc89f3b55416d6ce4ee69a3dc0146">contents</a> (const <a class="el" href="classllfio__v2__xxx_1_1path__handle.html">path_handle</a> &amp;dirh, <a class="el" href="structllfio__v2__xxx_1_1algorithm_1_1contents__visitor.html">contents_visitor</a> *visitor=nullptr, size_t threads=0, bool force_slow_path=false) noexcept</td></tr>
<tr class="memdesc:a887fc89f3b55416d6ce4ee69a3dc0146"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the contents of everything within and under <code>dirh</code>. What is returned is unordered.  <br /></td></tr>
<tr class="separator:a887fc89f3b55416d6ce4ee69a3dc0146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4ff38b8fe0f60babd46f652cedc376" id="r_a7b4ff38b8fe0f60babd46f652cedc376"><td class="memItemLeft" align="right" valign="top">result&lt; <a class="el" href="structllfio__v2__xxx_1_1algorithm_1_1comparison__summary.html">comparison_summary</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx_1_1algorithm.html#a7b4ff38b8fe0f60babd46f652cedc376">compare</a> (const <a class="el" href="classllfio__v2__xxx_1_1path__handle.html">path_handle</a> &amp;ldirh, const <a class="el" href="classllfio__v2__xxx_1_1path__handle.html">path_handle</a> &amp;rdirh, stat_t::want want=comparison_summary::default_metadata(), <a class="el" href="structllfio__v2__xxx_1_1algorithm_1_1compare__visitor.html">compare_visitor</a> *visitor=nullptr, size_t threads=0, bool force_slow_path=false) noexcept</td></tr>
<tr class="memdesc:a7b4ff38b8fe0f60babd46f652cedc376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the directories identified by <code>ldirh</code> and <code>rdirh</code>, and everything therein.  <br /></td></tr>
<tr class="separator:a7b4ff38b8fe0f60babd46f652cedc376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accaecb0cf0e0d0b04212a6c451aeb9b8" id="r_accaecb0cf0e0d0b04212a6c451aeb9b8"><td class="memItemLeft" align="right" valign="top">result&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx_1_1algorithm.html#accaecb0cf0e0d0b04212a6c451aeb9b8">reduce</a> (<a class="el" href="classllfio__v2__xxx_1_1directory__handle.html">directory_handle</a> &amp;&amp;dirh, <a class="el" href="structllfio__v2__xxx_1_1algorithm_1_1reduce__visitor.html">reduce_visitor</a> *visitor=nullptr, size_t threads=0, bool force_slow_path=false) noexcept</td></tr>
<tr class="memdesc:accaecb0cf0e0d0b04212a6c451aeb9b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce the directory identified <code>dirh</code>, and everything therein, to the null set.  <br /></td></tr>
<tr class="separator:accaecb0cf0e0d0b04212a6c451aeb9b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3adbc9371372a9771780ac143c3c63f7" id="r_a3adbc9371372a9771780ac143c3c63f7"><td class="memItemLeft" align="right" valign="top">result&lt; <a class="el" href="structllfio__v2__xxx_1_1algorithm_1_1traversal__summary.html">traversal_summary</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx_1_1algorithm.html#a3adbc9371372a9771780ac143c3c63f7">summarize</a> (const <a class="el" href="classllfio__v2__xxx_1_1path__handle.html">path_handle</a> &amp;topdirh, stat_t::want want=<a class="el" href="structllfio__v2__xxx_1_1algorithm_1_1traversal__summary.html#a8904eee9435edf3562642294046c634e">traversal_summary::default_metadata</a>(), <a class="el" href="structllfio__v2__xxx_1_1algorithm_1_1summarize__visitor.html">summarize_visitor</a> *visitor=nullptr, size_t threads=0, bool force_slow_path=false) noexcept</td></tr>
<tr class="memdesc:a3adbc9371372a9771780ac143c3c63f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Summarise the directory identified <code>topdirh</code>, and everything therein.  <br /></td></tr>
<tr class="separator:a3adbc9371372a9771780ac143c3c63f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8644948c9db24c787cd818e91c746a36" id="r_a8644948c9db24c787cd818e91c746a36"><td class="memItemLeft" align="right" valign="top">result&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx_1_1algorithm.html#a8644948c9db24c787cd818e91c746a36">traverse</a> (const <a class="el" href="classllfio__v2__xxx_1_1path__handle.html">path_handle</a> &amp;dirh, <a class="el" href="structllfio__v2__xxx_1_1algorithm_1_1traverse__visitor.html">traverse_visitor</a> *visitor, size_t threads=0, void *data=nullptr, bool force_slow_path=false) noexcept</td></tr>
<tr class="memdesc:a8644948c9db24c787cd818e91c746a36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse everything within and under <code>dirh</code>.  <br /></td></tr>
<tr class="separator:a8644948c9db24c787cd818e91c746a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e8566ac7a5eeb0c14cf2387dfb8c1a1" id="r_a6e8566ac7a5eeb0c14cf2387dfb8c1a1"><td class="memTemplParams" colspan="2"><a id="a6e8566ac7a5eeb0c14cf2387dfb8c1a1" name="a6e8566ac7a5eeb0c14cf2387dfb8c1a1"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a6e8566ac7a5eeb0c14cf2387dfb8c1a1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1trivial__vector.html">trivial_vector</a>&lt; T &gt; &amp;a, const <a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1trivial__vector.html">trivial_vector</a>&lt; T &gt; &amp;b)</td></tr>
<tr class="memdesc:a6e8566ac7a5eeb0c14cf2387dfb8c1a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare. <br /></td></tr>
<tr class="separator:a6e8566ac7a5eeb0c14cf2387dfb8c1a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef00d65394827ceb91597dda1f496f9" id="r_a7ef00d65394827ceb91597dda1f496f9"><td class="memTemplParams" colspan="2"><a id="a7ef00d65394827ceb91597dda1f496f9" name="a7ef00d65394827ceb91597dda1f496f9"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a7ef00d65394827ceb91597dda1f496f9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1trivial__vector.html">trivial_vector</a>&lt; T &gt; &amp;a, const <a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1trivial__vector.html">trivial_vector</a>&lt; T &gt; &amp;b)</td></tr>
<tr class="memdesc:a7ef00d65394827ceb91597dda1f496f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare. <br /></td></tr>
<tr class="separator:a7ef00d65394827ceb91597dda1f496f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48db273f73f86955938b99faeef6e113" id="r_a48db273f73f86955938b99faeef6e113"><td class="memTemplParams" colspan="2"><a id="a48db273f73f86955938b99faeef6e113" name="a48db273f73f86955938b99faeef6e113"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a48db273f73f86955938b99faeef6e113"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1trivial__vector.html">trivial_vector</a>&lt; T &gt; &amp;a, const <a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1trivial__vector.html">trivial_vector</a>&lt; T &gt; &amp;b)</td></tr>
<tr class="memdesc:a48db273f73f86955938b99faeef6e113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare. <br /></td></tr>
<tr class="separator:a48db273f73f86955938b99faeef6e113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a993ddc5c77998a907582247107f6e6c5" id="r_a993ddc5c77998a907582247107f6e6c5"><td class="memTemplParams" colspan="2"><a id="a993ddc5c77998a907582247107f6e6c5" name="a993ddc5c77998a907582247107f6e6c5"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a993ddc5c77998a907582247107f6e6c5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1trivial__vector.html">trivial_vector</a>&lt; T &gt; &amp;a, const <a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1trivial__vector.html">trivial_vector</a>&lt; T &gt; &amp;b)</td></tr>
<tr class="memdesc:a993ddc5c77998a907582247107f6e6c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare. <br /></td></tr>
<tr class="separator:a993ddc5c77998a907582247107f6e6c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba09ef10dc88c605edf40669322d8d4" id="r_a4ba09ef10dc88c605edf40669322d8d4"><td class="memTemplParams" colspan="2"><a id="a4ba09ef10dc88c605edf40669322d8d4" name="a4ba09ef10dc88c605edf40669322d8d4"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a4ba09ef10dc88c605edf40669322d8d4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1trivial__vector.html">trivial_vector</a>&lt; T &gt; &amp;a, const <a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1trivial__vector.html">trivial_vector</a>&lt; T &gt; &amp;b)</td></tr>
<tr class="memdesc:a4ba09ef10dc88c605edf40669322d8d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare. <br /></td></tr>
<tr class="separator:a4ba09ef10dc88c605edf40669322d8d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade7571062c3e19cb6622bd2e411130ab" id="r_ade7571062c3e19cb6622bd2e411130ab"><td class="memTemplParams" colspan="2"><a id="ade7571062c3e19cb6622bd2e411130ab" name="ade7571062c3e19cb6622bd2e411130ab"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ade7571062c3e19cb6622bd2e411130ab"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1trivial__vector.html">trivial_vector</a>&lt; T &gt; &amp;a, const <a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1trivial__vector.html">trivial_vector</a>&lt; T &gt; &amp;b)</td></tr>
<tr class="memdesc:ade7571062c3e19cb6622bd2e411130ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare. <br /></td></tr>
<tr class="separator:ade7571062c3e19cb6622bd2e411130ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0973243c4b58d53d6f11ce5a2535a8c" id="r_ae0973243c4b58d53d6f11ce5a2535a8c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae0973243c4b58d53d6f11ce5a2535a8c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx_1_1algorithm.html#ae0973243c4b58d53d6f11ce5a2535a8c">swap</a> (<a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1trivial__vector.html">trivial_vector</a>&lt; T &gt; &amp;a, <a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1trivial__vector.html">trivial_vector</a>&lt; T &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:ae0973243c4b58d53d6f11ce5a2535a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap.  <br /></td></tr>
<tr class="separator:ae0973243c4b58d53d6f11ce5a2535a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0b9fb4d82d04e7dbf940c1a3090c56c" id="r_ac0b9fb4d82d04e7dbf940c1a3090c56c"><td class="memTemplParams" colspan="2">template&lt;class T , class... Args&gt; </td></tr>
<tr class="memitem:ac0b9fb4d82d04e7dbf940c1a3090c56c"><td class="memTemplItemLeft" align="right" valign="top">result&lt; <a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1cached__parent__handle__adapter.html">cached_parent_handle_adapter</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellfio__v2__xxx_1_1algorithm.html#ac0b9fb4d82d04e7dbf940c1a3090c56c">cache_parent</a> (Args &amp;&amp;...args) noexcept</td></tr>
<tr class="memdesc:ac0b9fb4d82d04e7dbf940c1a3090c56c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <code>T</code> adapted into a parent handle caching implementation.  <br /></td></tr>
<tr class="separator:ac0b9fb4d82d04e7dbf940c1a3090c56c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Collection of file system based algorithms. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a27450e894b5dab6c18a01350670fa0dc" name="a27450e894b5dab6c18a01350670fa0dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27450e894b5dab6c18a01350670fa0dc">&#9670;&#160;</a></span>xor_handle_adapter</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Target , class Source &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacellfio__v2__xxx_1_1algorithm.html#a27450e894b5dab6c18a01350670fa0dc">llfio_v2_xxx::algorithm::xor_handle_adapter</a> = typedef <a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1combining__handle__adapter.html">combining_handle_adapter</a>&lt;detail::xor_handle_adapter_op, Target, Source&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A handle combining the data from two other handles using XOR. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Target</td><td>The type of the target handle. This is the one written to during any writes i.e. the input and second handle are XORed together and written to the first handle. </td></tr>
    <tr><td class="paramname">Source</td><td>The type of the second handle with which to XOR the target handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This class is still in development, do not use. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ac0b9fb4d82d04e7dbf940c1a3090c56c" name="ac0b9fb4d82d04e7dbf940c1a3090c56c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0b9fb4d82d04e7dbf940c1a3090c56c">&#9670;&#160;</a></span>cache_parent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result&lt; <a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1cached__parent__handle__adapter.html">cached_parent_handle_adapter</a>&lt; T &gt; &gt; llfio_v2_xxx::algorithm::cache_parent </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <code>T</code> adapted into a parent handle caching implementation. </p>
<p>This function works via the <code>construct&lt;T&gt;()</code> free function framework for which your <code>handle</code> implementation must have registered its construction details. </p>
<div class="fragment"><div class="line"><span class="lineno">  184</span>  {</div>
<div class="line"><span class="lineno">  185</span>    <a class="code hl_struct" href="structllfio__v2__xxx_1_1construct.html">construct&lt;T&gt;</a> constructor{std::forward&lt;Args&gt;(args)...};</div>
<div class="line"><span class="lineno">  186</span>    OUTCOME_TRY(<span class="keyword">auto</span> &amp;&amp;h, constructor());</div>
<div class="line"><span class="lineno">  187</span>    LLFIO_EXCEPTION_TRY</div>
<div class="line"><span class="lineno">  188</span>    {</div>
<div class="line"><span class="lineno">  189</span>      <span class="keywordflow">return</span> cached_parent_handle_adapter&lt;T&gt;(std::move(h), constructor.base, constructor._path);</div>
<div class="line"><span class="lineno">  190</span>    }</div>
<div class="line"><span class="lineno">  191</span>    LLFIO_EXCEPTION_CATCH_ALL</div>
<div class="line"><span class="lineno">  192</span>    {</div>
<div class="line"><span class="lineno">  193</span>      <span class="keywordflow">return</span> error_from_exception();</div>
<div class="line"><span class="lineno">  194</span>    }</div>
<div class="line"><span class="lineno">  195</span>  }</div>
<div class="ttc" id="astructllfio__v2__xxx_1_1construct_html"><div class="ttname"><a href="structllfio__v2__xxx_1_1construct.html">llfio_v2_xxx::construct</a></div><div class="ttdoc">Metaprogramming shim for constructing any handle subclass.</div><div class="ttdef"><b>Definition</b> handle.hpp:535</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a0385b9ea365f4aa97dfa73aad2a4e656" name="a0385b9ea365f4aa97dfa73aad2a4e656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0385b9ea365f4aa97dfa73aad2a4e656">&#9670;&#160;</a></span>clone_or_copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result&lt; file_handle::extent_type &gt; llfio_v2_xxx::algorithm::clone_or_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1file__handle.html">file_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllfio__v2__xxx_1_1path__handle.html">path_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>destdir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1path__view.html">path_view</a>&#160;</td>
          <td class="paramname"><em>destleaf</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve_timestamps</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force_copy_now</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1handle.html#af0b352d0f273ba6fa70c178b2c2fee42">file_handle::creation</a>&#160;</td>
          <td class="paramname"><em>creation</em> = <code>file_handle::creation::always_new</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllfio__v2__xxx_1_1deadline.html">deadline</a>&#160;</td>
          <td class="paramname"><em>d</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clone or copy the extents of the filesystem entity identified by <code>src</code> to <code>destdir</code> optionally renamed to <code>destleaf</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes cloned or copied. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The file to clone or copy. </td></tr>
    <tr><td class="paramname">destdir</td><td>The base to lookup <code>destleaf</code> within. </td></tr>
    <tr><td class="paramname">destleaf</td><td>The leafname to use. If empty, use the same leafname as <code>src</code> currently has. </td></tr>
    <tr><td class="paramname">preserve_timestamps</td><td>Use <code>stat_t::stamp()</code> to preserve as much metadata from the original to the clone/copy as possible. </td></tr>
    <tr><td class="paramname">force_copy_now</td><td>Parameter to pass to <code>file_handle::clone_extents()</code> to force extents to be copied now, not copy-on-write lazily later. </td></tr>
    <tr><td class="paramname">creation</td><td>How to create the destination file handle. NOTE that if this is NOT <code>always_new</code>, if the destination has identical maximum extent and last modified timestamp (and permissions on POSIX) to the source, it is NOT copied, and zero is returned. </td></tr>
    <tr><td class="paramname">d</td><td>Deadline by which to complete the operation.</td></tr>
  </table>
  </dd>
</dl>
<p>Firstly, a <code>file_handle</code> is constructed at the destination using <code>creation</code>, which defaults to always creating a new inode. The caching used for the destination handle is replicated from the source handle &ndash; be aware that not caching metadata is expensive.</p>
<p>Next <code>file_handle::clone_extents()</code> with <code>emulate_if_unsupported = false</code> is called on the whole file content. If extent cloning is supported, this will be very fast and not consume new disk space (note: except on networked filesystems). If the source file is sparsely allocated, the destination will have identical sparse allocation.</p>
<p>If the previous operation did not succeed, the disk free space is checked using <code>statfs_t</code>, and if the copy would exceed current disk free space, the destination file is unlinked and an error code comparing equal to <code>errc::no_space_on_device</code> is returned.</p>
<p>Next, <code>file_handle::clone_extents()</code> with <code>emulate_if_unsupported = true</code> is called on the whole file content. This copies only the allocated extents in blocks sized whatever is the large page size on this platform (2Mb on x64).</p>
<p>Finally, if <code>preserve_timestamps</code> is true, the destination file handle is restamped with the metadata from the source file handle just before the destination file handle is closed. </p>

</div>
</div>
<a id="a7b4ff38b8fe0f60babd46f652cedc376" name="a7b4ff38b8fe0f60babd46f652cedc376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b4ff38b8fe0f60babd46f652cedc376">&#9670;&#160;</a></span>compare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result&lt; <a class="el" href="structllfio__v2__xxx_1_1algorithm_1_1comparison__summary.html">comparison_summary</a> &gt; llfio_v2_xxx::algorithm::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllfio__v2__xxx_1_1path__handle.html">path_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>ldirh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllfio__v2__xxx_1_1path__handle.html">path_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>rdirh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">stat_t::want&#160;</td>
          <td class="paramname"><em>want</em> = <code>comparison_summary::default_metadata()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllfio__v2__xxx_1_1algorithm_1_1compare__visitor.html">compare_visitor</a> *&#160;</td>
          <td class="paramname"><em>visitor</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>threads</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force_slow_path</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the directories identified by <code>ldirh</code> and <code>rdirh</code>, and everything therein. </p>
<p>This extends <code>summarize()</code> to summarise two directory hierarchies, also summarising the number of types of differences between them.</p>
<p>It is trivially easy to further extend this implementation to synchronise the contents of a directory tree such that after completion, both trees shall be identical. See the examples directory for an example of this use case.</p>
<p>This is a trivial implementation on top of <code>algorithm::traverse()</code>, indeed it is implemented entirely as header code. You should review the documentation for <code>algorithm::traverse()</code>, as this algorithm is entirely implemented using that algorithm. </p>
<div class="fragment"><div class="line"><span class="lineno">  106</span>  {</div>
<div class="line"><span class="lineno">  107</span>    LLFIO_LOG_FUNCTION_CALL(&amp;dirh);</div>
<div class="line"><span class="lineno">  108</span>    <a class="code hl_struct" href="structllfio__v2__xxx_1_1algorithm_1_1compare__visitor.html">compare_visitor</a> default_visitor;</div>
<div class="line"><span class="lineno">  109</span>    <span class="keywordflow">if</span>(visitor == <span class="keyword">nullptr</span>)</div>
<div class="line"><span class="lineno">  110</span>    {</div>
<div class="line"><span class="lineno">  111</span>      visitor = &amp;default_visitor;</div>
<div class="line"><span class="lineno">  112</span>    }</div>
<div class="line"><span class="lineno">  113</span>    result&lt;comparison_summary&gt; state(in_place_type&lt;comparison_summary&gt;);</div>
<div class="line"><span class="lineno">  114</span>    state.assume_value().want = want;</div>
<div class="line"><span class="lineno">  115</span>    <a class="code hl_struct" href="structllfio__v2__xxx_1_1directory__entry.html">directory_entry</a> entry{{}, stat_t(<span class="keyword">nullptr</span>)};</div>
<div class="line"><span class="lineno">  116</span>    OUTCOME_TRY(entry.stat.fill(dirh, want));</div>
<div class="line"><span class="lineno">  117</span>    OUTCOME_TRY(compare_visitor::accumulate(state.assume_value(), &amp;state.assume_value(), <span class="keyword">nullptr</span>, entry, want));</div>
<div class="line"><span class="lineno">  118</span>    OUTCOME_TRY(<a class="code hl_function" href="namespacellfio__v2__xxx_1_1algorithm.html#a8644948c9db24c787cd818e91c746a36">traverse</a>(dirh, visitor, threads, &amp;state.assume_value(), force_slow_path));</div>
<div class="line"><span class="lineno">  119</span>    <span class="keywordflow">return</span> state;</div>
<div class="line"><span class="lineno">  120</span>  }</div>
<div class="ttc" id="anamespacellfio__v2__xxx_1_1algorithm_html_a8644948c9db24c787cd818e91c746a36"><div class="ttname"><a href="namespacellfio__v2__xxx_1_1algorithm.html#a8644948c9db24c787cd818e91c746a36">llfio_v2_xxx::algorithm::traverse</a></div><div class="ttdeci">result&lt; size_t &gt; traverse(const path_handle &amp;dirh, traverse_visitor *visitor, size_t threads=0, void *data=nullptr, bool force_slow_path=false) noexcept</div><div class="ttdoc">Traverse everything within and under dirh.</div></div>
<div class="ttc" id="astructllfio__v2__xxx_1_1algorithm_1_1compare__visitor_html"><div class="ttname"><a href="structllfio__v2__xxx_1_1algorithm_1_1compare__visitor.html">llfio_v2_xxx::algorithm::compare_visitor</a></div><div class="ttdoc">A visitor for the filesystem traversal and comparison algorithm.</div><div class="ttdef"><b>Definition</b> difference.hpp:63</div></div>
<div class="ttc" id="astructllfio__v2__xxx_1_1directory__entry_html"><div class="ttname"><a href="structllfio__v2__xxx_1_1directory__entry.html">llfio_v2_xxx::directory_entry</a></div><div class="ttdef"><b>Definition</b> directory_handle.hpp:44</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a887fc89f3b55416d6ce4ee69a3dc0146" name="a887fc89f3b55416d6ce4ee69a3dc0146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a887fc89f3b55416d6ce4ee69a3dc0146">&#9670;&#160;</a></span>contents()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result&lt; <a class="el" href="structllfio__v2__xxx_1_1algorithm_1_1contents__visitor_1_1contents__type.html">contents_visitor::contents_type</a> &gt; llfio_v2_xxx::algorithm::contents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllfio__v2__xxx_1_1path__handle.html">path_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>dirh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllfio__v2__xxx_1_1algorithm_1_1contents__visitor.html">contents_visitor</a> *&#160;</td>
          <td class="paramname"><em>visitor</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>threads</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force_slow_path</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the contents of everything within and under <code>dirh</code>. What is returned is unordered. </p>
<p>This is a very thin veneer over <code>traverse()</code> which came out of the fact that I kept writing "get me the contents" traversal visitors again and again, so eventually I just wrote a library edition. Its only "clever" bit is that it stores the contents in thread local storage, and merges the contents afterwards.</p>
<p>It is race free to concurrent relocations of <code>dirh</code>. It is entirely implemented in header-only code, as it is very simple. </p>
<div class="fragment"><div class="line"><span class="lineno">  225</span>  {</div>
<div class="line"><span class="lineno">  226</span>    <a class="code hl_struct" href="structllfio__v2__xxx_1_1algorithm_1_1contents__visitor.html">contents_visitor</a> default_visitor;</div>
<div class="line"><span class="lineno">  227</span>    <span class="keywordflow">if</span>(visitor == <span class="keyword">nullptr</span>)</div>
<div class="line"><span class="lineno">  228</span>    {</div>
<div class="line"><span class="lineno">  229</span>      visitor = &amp;default_visitor;</div>
<div class="line"><span class="lineno">  230</span>    }</div>
<div class="line"><span class="lineno">  231</span>    contents_visitor::_state_type state(dirh);</div>
<div class="line"><span class="lineno">  232</span>    OUTCOME_TRY(<span class="keyword">auto</span> &amp;&amp;dirhpath, dirh.<a class="code hl_function" href="classllfio__v2__xxx_1_1handle.html#a36e8acf23f721dbd26d56cfd0c133406">current_path</a>());</div>
<div class="line"><span class="lineno">  233</span>    state.rootdirpathlen.store(dirhpath.native().size() + 1, std::memory_order_relaxed);</div>
<div class="line"><span class="lineno">  234</span>    OUTCOME_TRY(traverse(dirh, visitor, threads, &amp;state, force_slow_path));</div>
<div class="line"><span class="lineno">  235</span>    <span class="keywordflow">return</span> {std::move(state.contents)};</div>
<div class="line"><span class="lineno">  236</span>  }</div>
<div class="ttc" id="aclassllfio__v2__xxx_1_1handle_html_a36e8acf23f721dbd26d56cfd0c133406"><div class="ttname"><a href="classllfio__v2__xxx_1_1handle.html#a36e8acf23f721dbd26d56cfd0c133406">llfio_v2_xxx::handle::current_path</a></div><div class="ttdeci">virtual result&lt; path_type &gt; current_path() const noexcept</div></div>
<div class="ttc" id="astructllfio__v2__xxx_1_1algorithm_1_1contents__visitor_html"><div class="ttname"><a href="structllfio__v2__xxx_1_1algorithm_1_1contents__visitor.html">llfio_v2_xxx::algorithm::contents_visitor</a></div><div class="ttdoc">A visitor for the filesystem contents algorithm.</div><div class="ttdef"><b>Definition</b> contents.hpp:42</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="accaecb0cf0e0d0b04212a6c451aeb9b8" name="accaecb0cf0e0d0b04212a6c451aeb9b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accaecb0cf0e0d0b04212a6c451aeb9b8">&#9670;&#160;</a></span>reduce()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result&lt; size_t &gt; llfio_v2_xxx::algorithm::reduce </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1directory__handle.html">directory_handle</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>dirh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllfio__v2__xxx_1_1algorithm_1_1reduce__visitor.html">reduce_visitor</a> *&#160;</td>
          <td class="paramname"><em>visitor</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>threads</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force_slow_path</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reduce the directory identified <code>dirh</code>, and everything therein, to the null set. </p>
<p>You might be surprised to learn that most directory tree removal implementations are of poor quality, not leveraging the filesystem facilities that are available, not handling concurrent modification of the filesystem correctly, having poor performance, or failing to handle not uncommon corner cases. This implementation is considerably better quality, indeed it is to my knowledge the highest quality possible on at least Linux and Microsoft Windows.</p>
<p>The algorithm is as follows:</p>
<ol type="1">
<li>Attempt to rename <code>dirh</code> to a uniquely named directory. If successful, this causes concurrent users to no longer see the directory tree. It also usefully detects if permissions problems would prevent whole directory tree removal. Note that on Windows, if any process has a handle open to anything inside the directory tree, it is usually the case that all renames will be prevented.</li>
<li><code>algorithm::traverse()</code> is begun, using the visitor supplied. This will unlink all items using a breadth-first algorithm, from root to tips. With the default visitor, directories which cannot be opened for traversal are ignored; entries which cannot be unlinked are attempted to be renamed into the base directory; entries which cannot be renamed are ignored.</li>
<li>Except for unrenameable files, now the entire directory tree will have been reduced to a minimum possible set of uniquely named items in the base directory, all of which by definition must be undeletable. We now loop attempting to reduce the remaining entries. The default visitor implementation takes a timeout, which if exceeded, an error code comparing equal to <code>errc::timed_out</code> is returned.</li>
</ol>
<p>Even on slow filesystems such as those on Windows, or networked filesystems, this algorithm performs very well. We do not currently inspect the filing system to see if bisect unlinking directories with millions of entries will perform well (some filing systems can store very large directories with multiple independent inode locks, thus using multiple kernel threads on the same directory sees a large performance increase for very large directories). We also remove items based on enumerated order, under the assumption that filesystems will have optimised for this specific use case.</p>
<p>If the function succeeds, <code>dirh</code> is moved into the function, and the total number of filesystem entries removed is returned.</p>
<p>If the function fails, <code>dirh</code> is NOT moved into the function, and continues to refer to the (likely renamed) directory you passed in. You might do something like try to rename it into <code>storage_backed_temporary_files_directory()</code>, or some other hail mary action.</p>
<p>You should review the documentation for <code>algorithm::traverse()</code>, as this algorithm is entirely implemented using that algorithm. </p>

</div>
</div>
<a id="a2cd989e756e0f4a663ba6ab8fd398d42" name="a2cd989e756e0f4a663ba6ab8fd398d42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cd989e756e0f4a663ba6ab8fd398d42">&#9670;&#160;</a></span>relink_or_clone_copy_unlink()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result&lt; bool &gt; llfio_v2_xxx::algorithm::relink_or_clone_copy_unlink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1file__handle.html">file_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllfio__v2__xxx_1_1path__handle.html">path_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>destdir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1path__view.html">path_view</a>&#160;</td>
          <td class="paramname"><em>destleaf</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>atomic_replace</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve_timestamps</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force_copy_now</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllfio__v2__xxx_1_1deadline.html">deadline</a>&#160;</td>
          <td class="paramname"><em>d</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Relink or clone-unlink/copy-unlink the extents of the filesystem entity identified by <code>src</code> to <code>destdir</code> optionally renamed to <code>destleaf</code>. This lets you relink files across filing systems, with as close as possible matching of semantics to atomic relinking. </p>
<dl class="section return"><dt>Returns</dt><dd>True if a clone-unlink or copy-unlink was performed, false if a simple relink was sufficient. <code>src</code> on return is the relinked handle, which will be to a completely different inode if a clone-unlink or copy-unlink was performed. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The file to relink or clone or copy. </td></tr>
    <tr><td class="paramname">destdir</td><td>The base to lookup <code>destleaf</code> within. </td></tr>
    <tr><td class="paramname">destleaf</td><td>The leafname to use. If empty, use the same leafname as <code>src</code> currently has. </td></tr>
    <tr><td class="paramname">atomic_replace</td><td>Whether any file entry at the destination should be atomically replaced, or an error returned instead. </td></tr>
    <tr><td class="paramname">preserve_timestamps</td><td>Use <code>stat_t::stamp()</code> to preserve as much metadata from the original to the clone/copy as possible. </td></tr>
    <tr><td class="paramname">force_copy_now</td><td>Parameter to pass to <code>file_handle::clone_extents()</code> to force extents to be copied now, not copy-on-write lazily later. </td></tr>
    <tr><td class="paramname">d</td><td>Deadline by which to complete the operation.</td></tr>
  </table>
  </dd>
</dl>
<p>Firstly, <code>.relink()</code> is tried, which if successful, there is an immediate return with value <code>false</code>.</p>
<p>If relinking fails, an anonymous inode <code>file_handle</code> is constructed at the destination. The caching used for the destination handle is replicated from the source handle &ndash; be aware that not caching metadata is expensive. If <code>atomic_replace</code> is false, and there is a file entry matching the destination, an error code comparing equal to <code>errc::file_exists</code> will be returned.</p>
<p>Next <code>file_handle::clone_extents()</code> with <code>emulate_if_unsupported = false</code> is called on the whole file content. If extent cloning is supported, this will be very fast and not consume new disk space (note: except on networked filesystems). If the source file is sparsely allocated, the destination will have identical sparse allocation.</p>
<p>If the previous operation did not succeed, the disk free space is checked using <code>statfs_t</code>, and if the copy would exceed current disk free space, the destination file is unlinked and an error code comparing equal to <code>errc::no_space_on_device</code> is returned.</p>
<p>Next, <code>file_handle::clone_extents()</code> with <code>emulate_if_unsupported = true</code> is called on the whole file content. This copies only the allocated extents in blocks sized whatever is the large page size on this platform (2Mb on x64).</p>
<p>Once all the extents have been replicated into temporary inode, a hard link is attempted to the destination leafname. If that fails, if <code>atomic_replace</code> is false then error is returned, otherwise a hard link to a randomly chosen filename is created, and that link is relinked over the destination leafname.</p>
<p>Finally, if <code>preserve_timestamps</code> is true, the destination file handle is restamped with the metadata from the source file handle just before the destination file handle is closed. </p>

</div>
</div>
<a id="a3adbc9371372a9771780ac143c3c63f7" name="a3adbc9371372a9771780ac143c3c63f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3adbc9371372a9771780ac143c3c63f7">&#9670;&#160;</a></span>summarize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result&lt; <a class="el" href="structllfio__v2__xxx_1_1algorithm_1_1traversal__summary.html">traversal_summary</a> &gt; llfio_v2_xxx::algorithm::summarize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllfio__v2__xxx_1_1path__handle.html">path_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>topdirh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">stat_t::want&#160;</td>
          <td class="paramname"><em>want</em> = <code><a class="el" href="structllfio__v2__xxx_1_1algorithm_1_1traversal__summary.html#a8904eee9435edf3562642294046c634e">traversal_summary::default_metadata</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllfio__v2__xxx_1_1algorithm_1_1summarize__visitor.html">summarize_visitor</a> *&#160;</td>
          <td class="paramname"><em>visitor</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>threads</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force_slow_path</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Summarise the directory identified <code>topdirh</code>, and everything therein. </p>
<p>It can be useful to summarise a directory hierarchy, especially to determine how much storage it occupies, but also how many mounted filesystems it straddles etc. You should specify what metadata you wish to summarise, if this is a subset of what metadata <code>directory_handle::read()</code> returns, performance will be considerably better. The default summarises all possible metadata.</p>
<p>Most errors during summary are accumulated into <code>stats_failed</code> and <code>directory_opens_failed</code>, rather than failing the summary.</p>
<p>This is a trivial implementation on top of <code>algorithm::traverse()</code>, indeed it is implemented entirely as header code. You should review the documentation for <code>algorithm::traverse()</code>, as this algorithm is entirely implemented using that algorithm. </p>
<div class="fragment"><div class="line"><span class="lineno">  275</span>  {</div>
<div class="line"><span class="lineno">  276</span>    LLFIO_LOG_FUNCTION_CALL(&amp;topdirh);</div>
<div class="line"><span class="lineno">  277</span>    <a class="code hl_struct" href="structllfio__v2__xxx_1_1algorithm_1_1summarize__visitor.html">summarize_visitor</a> default_visitor;</div>
<div class="line"><span class="lineno">  278</span>    <span class="keywordflow">if</span>(visitor == <span class="keyword">nullptr</span>)</div>
<div class="line"><span class="lineno">  279</span>    {</div>
<div class="line"><span class="lineno">  280</span>      visitor = &amp;default_visitor;</div>
<div class="line"><span class="lineno">  281</span>    }</div>
<div class="line"><span class="lineno">  282</span>    result&lt;traversal_summary&gt; state(in_place_type&lt;traversal_summary&gt;);</div>
<div class="line"><span class="lineno">  283</span>    state.assume_value().want = want;</div>
<div class="line"><span class="lineno">  284</span>    <a class="code hl_struct" href="structllfio__v2__xxx_1_1directory__entry.html">directory_entry</a> entry{{}, stat_t(<span class="keyword">nullptr</span>)};</div>
<div class="line"><span class="lineno">  285</span>    directory_handle _dirh;</div>
<div class="line"><span class="lineno">  286</span>    <span class="keywordflow">if</span>(!topdirh.<a class="code hl_function" href="classllfio__v2__xxx_1_1handle.html#a4ca48bdcd6d6bf8b41d0cebb304fe9ce">is_directory</a>())</div>
<div class="line"><span class="lineno">  287</span>    {</div>
<div class="line"><span class="lineno">  288</span>      OUTCOME_TRY(_dirh, directory_handle::directory(topdirh, {}));</div>
<div class="line"><span class="lineno">  289</span>    }</div>
<div class="line"><span class="lineno">  290</span>    <span class="keyword">const</span> path_handle &amp;dirh = _dirh.is_valid() ? _dirh : topdirh;</div>
<div class="line"><span class="lineno">  291</span>    <span class="comment">// We should fail here if we can&#39;t stat topdirh</span></div>
<div class="line"><span class="lineno">  292</span>    OUTCOME_TRY(entry.stat.fill(dirh, want));</div>
<div class="line"><span class="lineno">  293</span>    summarize_visitor::accumulate(state.assume_value(), &amp;state.assume_value(), <span class="keyword">nullptr</span>, entry, want);</div>
<div class="line"><span class="lineno">  294</span>    OUTCOME_TRY(<a class="code hl_function" href="namespacellfio__v2__xxx_1_1algorithm.html#a8644948c9db24c787cd818e91c746a36">traverse</a>(dirh, visitor, threads, &amp;state.assume_value(), force_slow_path));</div>
<div class="line"><span class="lineno">  295</span>    <span class="keywordflow">return</span> state;</div>
<div class="line"><span class="lineno">  296</span>  }</div>
<div class="ttc" id="aclassllfio__v2__xxx_1_1handle_html_a4ca48bdcd6d6bf8b41d0cebb304fe9ce"><div class="ttname"><a href="classllfio__v2__xxx_1_1handle.html#a4ca48bdcd6d6bf8b41d0cebb304fe9ce">llfio_v2_xxx::handle::is_directory</a></div><div class="ttdeci">bool is_directory() const noexcept</div><div class="ttdoc">True if a directory.</div><div class="ttdef"><b>Definition</b> handle.hpp:357</div></div>
<div class="ttc" id="astructllfio__v2__xxx_1_1algorithm_1_1summarize__visitor_html"><div class="ttname"><a href="structllfio__v2__xxx_1_1algorithm_1_1summarize__visitor.html">llfio_v2_xxx::algorithm::summarize_visitor</a></div><div class="ttdoc">A visitor for the filesystem traversal and summary algorithm.</div><div class="ttdef"><b>Definition</b> summarize.hpp:154</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae0973243c4b58d53d6f11ce5a2535a8c" name="ae0973243c4b58d53d6f11ce5a2535a8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0973243c4b58d53d6f11ce5a2535a8c">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void llfio_v2_xxx::algorithm::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1trivial__vector.html">trivial_vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1algorithm_1_1trivial__vector.html">trivial_vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap. </p>
<div class="fragment"><div class="line"><span class="lineno">  711</span>{ a.<a class="code hl_function" href="structllfio__v2__xxx_1_1algorithm_1_1impl_1_1trivial__vector__impl.html#a3fb1e66f29e8d90eec09316946d3d4f0">swap</a>(b); }</div>
<div class="ttc" id="astructllfio__v2__xxx_1_1algorithm_1_1impl_1_1trivial__vector__impl_html_a3fb1e66f29e8d90eec09316946d3d4f0"><div class="ttname"><a href="structllfio__v2__xxx_1_1algorithm_1_1impl_1_1trivial__vector__impl.html#a3fb1e66f29e8d90eec09316946d3d4f0">llfio_v2_xxx::algorithm::impl::trivial_vector_impl::swap</a></div><div class="ttdeci">void swap(trivial_vector_impl &amp;o) noexcept</div><div class="ttdoc">Swaps.</div><div class="ttdef"><b>Definition</b> trivial_vector.hpp:537</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a8644948c9db24c787cd818e91c746a36" name="a8644948c9db24c787cd818e91c746a36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8644948c9db24c787cd818e91c746a36">&#9670;&#160;</a></span>traverse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result&lt; size_t &gt; llfio_v2_xxx::algorithm::traverse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllfio__v2__xxx_1_1path__handle.html">path_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>dirh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllfio__v2__xxx_1_1algorithm_1_1traverse__visitor.html">traverse_visitor</a> *&#160;</td>
          <td class="paramname"><em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>threads</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force_slow_path</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Traverse everything within and under <code>dirh</code>. </p>
<p>The algorithm is as follows:</p>
<ol type="1">
<li>Call <code>pre_enumeration()</code> of the visitor on the <code>directory_handle</code> about to be enumerated.</li>
<li>Enumerate the contents of the directory.</li>
<li>Call <code>post_enumeration()</code> of the visitor on the contents just enumerated.</li>
<li>For each directory in the contents, append a base directory handle and a directory fragment to its hierarchy depth level in a stack of lists.</li>
<li>Loop, using the least deep available item in the stack, until the stack is empty.</li>
</ol>
<p>If <code>known_dirs_remaining</code> exceeds four, a threadpool of not more than <code>threads</code> threads is spun up in order to traverse the hierarchy more quickly.</p>
<p>This algorithm is therefore primarily a breadth-first algorithm, in that we proceed from root, level by level, to the tips. The number returned is the total number of directories traversed.</p>
<h2><a class="anchor" id="autotoc_md20"></a>
Notes</h2>
<p>The implementation tries hard to not open too many file descriptors at a time in order to not exceed the system limit, which may be as low as 1024 on POSIX. On POSIX, it checks <code>getrlimit(RLIMIT_NOFILE)</code> for the soft limit on open file descriptors, and if the remaining unused open file descriptors is less than 65536, it will prefer a slow path implementation which exchanges file descriptor usage for lots more dynamic memory allocation and memory copying. You can force this slow path on any platform using <code>force_slow_path</code>, and in correct code you should always check for failures in <code>directory_open_failed()</code> comparing equal to <code>errc::too_many_files_open</code>, and if encountered restart the traversal using the slow path forced.</p>
<p>Almost every modern POSIX system allows a <code>RLIMIT_NOFILE</code> of over a million nowadays, so you should <code>setrlimit(RLIMIT_NOFILE)</code> appropriately in your program if you are absolutely sure that doing so will not break code in your program (e.g. <code>select()</code> fails spectacularly if file descriptors exceed 1024 on most POSIX).</p>
<p>To give an idea of the difference slow path makes, for Linux ext4:</p>
<ul>
<li>Slow path, 1 thread, traversed 131,915 directories and 8,254,162 entries in 3.10 seconds.</li>
<li>Slow path, 16 threads, traversed 131,915 directories and 8,254,162 entries in 0.966 seconds.</li>
<li>Fast path, 1 thread, traversed 131,915 directories and 8,254,162 entries in 2.73 seconds (+12%).</li>
<li>Fast path, 16 threads, traversed 131,915 directories and 8,254,162 entries in 0.525 seconds (+46%). </li>
</ul>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacellfio__v2__xxx.html">llfio_v2_xxx</a></li><li class="navelem"><a class="el" href="namespacellfio__v2__xxx_1_1algorithm.html">algorithm</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
